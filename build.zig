const std = @import("std");

const Build = std.Build;
const Step = Build.Step;
const Module = Build.Module;
const ModuleImport = Module.Import;
const CrossTarget = std.zig.CrossTarget;
const CompileStep = std.Build.Step.Compile;

const CSources = struct {
    files: std.ArrayList([]const u8),
    b: *Build,

    fn init(b: *Build) CSources {
        return .{
            .files = std.ArrayList([]const u8).init(b.allocator),
            .b = b,
        };
    }

    fn collect(sources: *CSources, path: []const u8) !void {
        const cwd: std.fs.Dir = sources.b.build_root.handle;
        const dir: std.fs.Dir = try cwd.openDir(path, .{ .iterate = true });
        var iter: std.fs.Dir.Iterator = dir.iterate();
        while (try iter.next()) |entry| {
            if (entry.kind == .file and std.mem.endsWith(u8, entry.name, ".c")) {
                const filepath = try std.fs.path.join(sources.b.allocator, &.{ path, entry.name });
                try sources.files.append(filepath);
            }
        }
    }

    fn deinit(sources: CSources) void {
        for (sources.files.items) |path| {
            sources.b.allocator.free(path);
        }
        sources.files.deinit();
    }
};

var stringpool_data: std.ArrayList([]const u8) = undefined;
fn printf(comptime fmt: []const u8, args: anytype) ![]const u8 {
    const str: []const u8 = try std.fmt.allocPrint(stringpool_data.allocator, fmt, args);
    try stringpool_data.append(str);
    return str;
}

fn basenameNoExtension(path: []const u8) []const u8 {
    const filename: []const u8 = std.fs.path.basename(path);
    if (std.mem.lastIndexOf(u8, filename, ".")) |index| {
        return filename[0..index];
    }
    return filename;
}

fn generateFileForStrings(b: *Build, comptime path: []const u8, prefix: []const u8, input_paths: []const []const u8) !*std.Build.Step.WriteFile {
    var concat = std.ArrayList(u8).init(b.allocator);
    defer concat.deinit();

    const filename: []const u8 = std.fs.path.basename(path);
    const filename_no_ext: []const u8 = basenameNoExtension(filename);
    const uppercase_filename: []u8 = try b.allocator.dupe(u8, filename_no_ext);
    for (uppercase_filename) |*c| {
        c.* = std.ascii.toUpper(c.*);
    }

    var writer = concat.writer();

    try writer.print("/*********************************************************************\n", .{});
    try writer.print("*\n", .{});
    try writer.print("*\tfile: {s}\n", .{filename});
    try writer.print("*\tnote: string literals auto-generated by build.zig\n", .{});
    // writer.print("*\tdate: {s}\n", .{datetime.now().strftime("%d/%m%Y")}) // TODO datetime
    try writer.print("*\n", .{});
    try writer.print("**********************************************************************/\n", .{});

    try writer.print("#ifndef __{s}_H__\n", .{uppercase_filename});
    try writer.print("#define __{s}_H__\n", .{uppercase_filename});
    try writer.print("\n\n", .{});

    const cwd = b.build_root;
    for (input_paths) |input_path| {
        const file_contents = try cwd.handle.readFileAlloc(b.allocator, input_path, 1024 * 1024 * 128);
        defer b.allocator.free(file_contents);

        const input_path_filename = std.fs.path.basename(input_path);
        try writer.print("//NOTE: string imported from {s}\n", .{input_path});
        try writer.print("const char* {s}{s} = ", .{ prefix, input_path_filename });
        try writer.print("{s}\n\n", .{file_contents});
    }

    try writer.print("#endif // __{s}_H__\n", .{uppercase_filename});

    return b.addWriteFile(path, concat.items);
}

const Sort = struct {
    fn lessThanString(_: void, lhs: []const u8, rhs: []const u8) bool {
        return std.mem.lessThan(u8, lhs, rhs);
    }
};

const Checksum = struct {
    const Sha256 = std.crypto.hash.sha2.Sha256;
    const MAX_FILE_SIZE = 1024 * 1024 * 128;

    fn strings(b: *Build, _strings: []const []const u8) ![]const u8 {
        var hasher = Checksum.Sha256.init(.{});
        for (_strings) |str| {
            hasher.update(str);
        }

        const out: []u8 = try b.allocator.alloc(u8, Sha256.digest_length);
        hasher.final(out[0..Sha256.digest_length]);

        try stringpool_data.append(out);
        return out;
    }

    fn file(b: *Build, path: []const u8) ![]const u8 {
        const cwd: std.fs.Dir = b.build_root.handle;
        const file_contents: []const u8 = try cwd.readFileAlloc(b.allocator, path, MAX_FILE_SIZE);
        defer b.allocator.free(file_contents);

        var h = Sha256.init(.{});
        const out: []u8 = try b.allocator.alloc(u8, Sha256.digest_length);
        h.hash(file_contents, out[0..Sha256.digest_length], .{});

        try stringpool_data.append(out);
        return out;
    }

    fn dir(b: *Build, path: []const u8, exclude_paths: []const []const u8) ![]const u8 {
        var cwd: std.fs.Dir = b.build_root.handle;
        var root_dir: std.fs.Dir = try cwd.openDir(path, .{ .iterate = true, .no_follow = true });
        defer root_dir.close();

        var dir_iter: std.fs.Dir.Walker = try root_dir.walk(b.allocator);
        defer dir_iter.deinit();

        var files_to_hash = std.ArrayList([]const u8).init(b.allocator);
        defer {
            for (files_to_hash.items) |file_path| {
                b.allocator.free(file_path);
            }
            files_to_hash.deinit();
        }

        while (try dir_iter.next()) |entry| {
            if (entry.kind == .file) {
                for (exclude_paths) |exclusion| {
                    if (!std.mem.startsWith(u8, entry.path, exclusion) and !std.mem.eql(u8, entry.basename, exclusion)) {
                        try files_to_hash.append(try b.allocator.dupe(u8, entry.path));
                    }
                }
            }
        }

        std.mem.sort([]const u8, files_to_hash.items, {}, Sort.lessThanString);

        var hash = Sha256.init(.{});
        for (files_to_hash.items) |file_path| {
            const file_contents: []const u8 = try root_dir.readFileAlloc(b.allocator, file_path, MAX_FILE_SIZE);
            defer b.allocator.free(file_contents);

            hash.update(file_contents);
        }

        const out: []u8 = try b.allocator.alloc(u8, Sha256.digest_length);
        hash.final(out[0..Sha256.digest_length]);

        try stringpool_data.append(out);
        return out;
    }
};

const AngleDawnHelpers = struct {
    const Lib = enum {
        Angle,
        Dawn,

        fn str(comptime lib: Lib) []const u8 {
            return switch (lib) {
                .Angle => "Angle",
                .Dawn => "Dawn",
            };
        }
    };

    // expects file contents to be a single hash blob like "8a8c8fc280d74b34731e0e417b19bff7c967388a"
    fn readStampFile(b: *Build, path: []const u8) ![]const u8 {
        const file_contents: []const u8 = try b.build_root.handle.readFileAlloc(b.allocator, path, 1024 * 4);
        try stringpool_data.append(file_contents);

        var stamp: []const u8 = file_contents;
        stamp = std.mem.trimRight(u8, stamp, "\n");
        stamp = std.mem.trimRight(u8, stamp, "\r");
        return stamp;
    }

    fn generateCheckfileContents(b: *Build, comptime lib: Lib) ![]const u8 {
        const commit_stamp_path = if (lib == .Angle) "deps/angle-commit.txt" else "deps/dawn-commit.txt";
        const artifact_dir = if (lib == .Angle) "build/angle.out" else "build/dawn.out";

        const commit_stamp = try readStampFile(b, commit_stamp_path);
        const artifacts_hash = try Checksum.dir(b, artifact_dir, &.{ ".DS_Store", "hash.txt" });

        const checkfile_contents = try Checksum.strings(b, &.{ commit_stamp, artifacts_hash });
        return checkfile_contents;
    }

    fn checkUpToDate(b: *Build, comptime lib: Lib) !*Build.Step.CheckFile {
        const checkfile_path = if (lib == .Angle) "build/angle.out/hash.txt" else "build/dawn.out/hash.txt";
        const checkfile_contents = try generateCheckfileContents(b, lib);
        var checkfile = b.addCheckFile(b.path(checkfile_path), .{ .expected_exact = checkfile_contents });

        const name = if (lib == .Angle) "Angle up-to-date check" else "Dawn up-to-date check";
        checkfile.setName(name);

        return checkfile;
    }
};

pub fn build(b: *Build) !void {
    stringpool_data = std.ArrayList([]const u8).init(b.allocator);
    defer {
        for (stringpool_data.items) |s| {
            b.allocator.free(s);
        }
        stringpool_data.deinit();
    }

    const git_version_opt: ?[]const u8 = b.option([]const u8, "version", "Specify the specific git version you want to package") orelse null;

    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    // NOTE - can use this to remove the default install/uninstall steps to fully customize the build menu
    // b.top_level_steps.clearRetainingCapacity();

    // Modify the default top-level build steps to reflect Orca's dev workflow
    {
        // b.top_level_steps.get("install").?.description = "Install a dev build of the Orca tools into the system Orca directory.";

        // var uninstall_step = b.top_level_steps.fetchSwapRemove("install").?.value;
        // uninstall_step.step.name = "all";
        // uninstall_step.description = "Delete all build artifacts and start fresh.";
        // try b.top_level_steps.put(b.allocator, uninstall_step.step.name, uninstall_step);

        var uninstall_step = b.top_level_steps.fetchSwapRemove("uninstall").?.value;
        uninstall_step.step.name = "clean";
        uninstall_step.description = "Delete all build artifacts and start fresh.";
        try b.top_level_steps.put(b.allocator, uninstall_step.step.name, uninstall_step);
    }

    // b.install_prefix = "build/zig-out";

    // const python_build_libc = b.addSystemCommand(&[_][]const u8{ "python", "orcadev", "build-orca-libc" });
    // const python_build_sdk = b.addSystemCommand(&[_][]const u8{ "python", "orcadev", "build-wasm-sdk" });

    /////////////////////////////////////////////////////////
    // TODO angle

    var depot_tools_dep = b.dependency("depot_tools", .{});
    var angle_dep = b.dependency("angle", .{});

    const build_angle_step = b.step("angle", "Build Angle libs");
    // build_angle_step.dependOn(cmake_build_angle);

    /////////////////////////////////////////////////////////
    // TODO dawn

    /////////////////////////////////////////////////////////
    // Orca runtime and dependencies

    // wasm3

    var wasm3_sources = CSources.init(b);
    defer wasm3_sources.deinit();
    try wasm3_sources.collect("src/ext/wasm3/source");

    var wasm3_lib = b.addStaticLibrary(.{
        .name = "wasm3",
        .target = target,
        .optimize = optimize,
    });

    wasm3_lib.addIncludePath(b.path("src/ext/wasm3/source"));
    wasm3_lib.addCSourceFiles(.{
        .files = wasm3_sources.files.items,
        .flags = &.{},
    });
    wasm3_lib.linkLibC();

    // platform lib

    var angle_uptodate_check: *Build.Step.CheckFile = try AngleDawnHelpers.checkUpToDate(b, .Angle);
    var dawn_uptodate_check: *Build.Step.CheckFile = try AngleDawnHelpers.checkUpToDate(b, .Dawn);

    var copy_angle_files: *Build.Step.WriteFile = b.addWriteFiles();
    _ = copy_angle_files.addCopyDirectory(b.path("build/angle.out/include/"), "src/ext/angle/include", .{});
    _ = copy_angle_files.addCopyDirectory(b.path("build/angle.out/bin/"), "build/bin", .{});
    copy_angle_files.step.dependOn(&angle_uptodate_check.step);

    var copy_dawn_files: *Build.Step.WriteFile = b.addWriteFiles();
    _ = copy_dawn_files.addCopyDirectory(b.path("build/dawn.out/include/"), "src/ext/dawn/include", .{});
    _ = copy_dawn_files.addCopyDirectory(b.path("build/dawn.out/bin/"), "build/bin", .{});
    copy_dawn_files.step.dependOn(&dawn_uptodate_check.step);

    // var install_dawn_artifacts: *Build.Step.installDirectory(.{
    //     .source_dir = b.paht
    //     })

    // os.makedirs("src/ext/dawn/include", exist_ok=True)
    // shutil.copytree("build/dawn.out/include", "src/ext/dawn/include/", dirs_exist_ok=True)

    // os.makedirs("build/bin", exist_ok=True)
    // shutil.copytree("build/dawn.out/bin", "build/bin", dirs_exist_ok=True)

    const wgpu_shaders_file = try generateFileForStrings(b, "src/graphics/wgpu_renderer_shaders.h", "oc_wgsl_", &.{
        "src/graphics/wgsl_shaders/common.wgsl",
        "src/graphics/wgsl_shaders/path_setup.wgsl",
        "src/graphics/wgsl_shaders/segment_setup.wgsl",
        "src/graphics/wgsl_shaders/backprop.wgsl",
        "src/graphics/wgsl_shaders/chunk.wgsl",
        "src/graphics/wgsl_shaders/merge.wgsl",
        "src/graphics/wgsl_shaders/balance_workgroups.wgsl",
        "src/graphics/wgsl_shaders/raster.wgsl",
        "src/graphics/wgsl_shaders/blit.wgsl",
        "src/graphics/wgsl_shaders/final_blit.wgsl",
    });

    var orca_platform_compile_flags = std.ArrayList([]const u8).init(b.allocator);
    defer orca_platform_compile_flags.deinit();
    try orca_platform_compile_flags.append("-DOC_BUILD_DLL");
    if (optimize == .Debug) {
        try orca_platform_compile_flags.append("-DOC_DEBUG");
        try orca_platform_compile_flags.append("-DOC_LOG_COMPILE_DEBUG");
    }

    // TODO add manifest file
    // "/MANIFEST:EMBED", "/MANIFESTINPUT:src/app/win32_manifest.xml",

    var orca_platform_lib = b.addSharedLibrary(.{
        .name = "orca_platform",
        .target = target,
        .optimize = optimize,
    });

    orca_platform_lib.addIncludePath(b.path("src"));
    orca_platform_lib.addIncludePath(b.path("src/ext"));
    orca_platform_lib.addIncludePath(b.path("src/ext/angle/include"));

    orca_platform_lib.addCSourceFiles(.{
        .files = &.{"src/orca.c"},
        .flags = orca_platform_compile_flags.items,
    });

    orca_platform_lib.addLibraryPath(b.path("build/lib"));
    orca_platform_lib.addLibraryPath(b.path("build/bin"));

    orca_platform_lib.linkSystemLibrary("user32");
    orca_platform_lib.linkSystemLibrary("opengl32");
    orca_platform_lib.linkSystemLibrary("gdi32");
    orca_platform_lib.linkSystemLibrary("dxgi");
    orca_platform_lib.linkSystemLibrary("dxguid");
    orca_platform_lib.linkSystemLibrary("d3d11");
    orca_platform_lib.linkSystemLibrary("dcomp");
    orca_platform_lib.linkSystemLibrary("shcore");
    // orca_platform_lib.linkSystemLibrary("delayimp");
    orca_platform_lib.linkSystemLibrary("dwmapi");
    orca_platform_lib.linkSystemLibrary("comctl32");
    orca_platform_lib.linkSystemLibrary("ole32");
    orca_platform_lib.linkSystemLibrary("shell32");
    orca_platform_lib.linkSystemLibrary("shlwapi");

    orca_platform_lib.linkSystemLibrary("libEGL.dll"); // todo DELAYLOAD?
    orca_platform_lib.linkSystemLibrary("libGLESv2.dll"); // todo DELAYLOAD?
    orca_platform_lib.linkSystemLibrary("webgpu");

    orca_platform_lib.step.dependOn(&copy_dawn_files.step);
    orca_platform_lib.step.dependOn(&copy_angle_files.step);
    orca_platform_lib.step.dependOn(&wgpu_shaders_file.step);

    b.installArtifact(orca_platform_lib);

    // orca runtime exe

    // TODO generate all wasm bindings

    var orca_runtime_compile_flags = std.ArrayList([]const u8).init(b.allocator);
    defer orca_runtime_compile_flags.deinit();
    try orca_runtime_compile_flags.append("-DOC_WASM_BACKEND_WASM3=1");
    try orca_runtime_compile_flags.append("-DOC_WASM_BACKEND_BYTEBOX=0");
    if (optimize == .Debug) {
        try orca_runtime_compile_flags.append("-DOC_DEBUG");
        try orca_runtime_compile_flags.append("-DOC_LOG_COMPILE_DEBUG");
    }

    const orca_runtime_exe = b.addExecutable(.{
        .name = "orca_runtime",
        .target = target,
        .optimize = optimize,
    });

    orca_runtime_exe.addIncludePath(b.path("src"));
    orca_runtime_exe.addIncludePath(b.path("src/ext"));
    orca_runtime_exe.addIncludePath(b.path("src/ext/angle/include"));
    orca_runtime_exe.addIncludePath(b.path("src/ext/wasm3/source"));

    orca_runtime_exe.addCSourceFiles(.{
        .files = &.{"src/runtime.c"},
        .flags = orca_runtime_compile_flags.items,
    });

    orca_runtime_exe.linkLibrary(wasm3_lib);
    orca_runtime_exe.linkLibrary(orca_platform_lib);
    orca_runtime_exe.linkLibC();

    b.installArtifact(orca_runtime_exe);

    // TODO write checksum file
    // with open("build/orcaruntime.sum", "w") as f:
    //     f.write(runtime_checksum())

    /////////////////////////////////////////////////////////
    // Orca CLI tool and dependencies

    // curl

    var curl_compile_flags = std.ArrayList([]const u8).init(b.allocator);
    defer curl_compile_flags.deinit();
    try curl_compile_flags.append("-DCURL_STATICLIB");
    try curl_compile_flags.append("-DBUILDING_LIBCURL");
    if (optimize == .Debug) {
        try curl_compile_flags.append("-D_DEBUG");
    } else {
        try curl_compile_flags.append("-DNDEBUG");
    }

    var curl_sources = CSources.init(b);
    defer curl_sources.deinit();
    try curl_sources.collect("src/ext/curl/lib");
    try curl_sources.collect("src/ext/curl/lib/vauth");
    try curl_sources.collect("src/ext/curl/lib/vtls");
    try curl_sources.collect("src/ext/curl/lib/vssh");
    try curl_sources.collect("src/ext/curl/lib/vquic");

    var curl_lib = b.addStaticLibrary(.{
        .name = "curl",
        .target = target,
        .optimize = optimize,
    });
    curl_lib.addIncludePath(b.path("src/ext/curl/include"));
    curl_lib.addIncludePath(b.path("src/ext/curl/lib"));
    curl_lib.addCSourceFiles(.{
        .files = curl_sources.files.items,
        .flags = curl_compile_flags.items,
    });

    // TOOD figure out if we need to include the RC file

    curl_lib.linkSystemLibrary("ws2_32");
    curl_lib.linkSystemLibrary("wldap32");
    curl_lib.linkSystemLibrary("advapi32");
    curl_lib.linkSystemLibrary("crypt32");
    curl_lib.linkSystemLibrary("gdi32");
    curl_lib.linkSystemLibrary("user32");
    curl_lib.linkSystemLibrary("bcrypt");
    curl_lib.linkLibC();

    // zlib

    var z_sources = CSources.init(b);
    defer z_sources.deinit();
    try z_sources.collect("src/ext/zlib/");

    var z_lib = b.addStaticLibrary(.{
        .name = "z",
        .target = target,
        .optimize = optimize,
    });
    z_lib.addIncludePath(b.path("src/ext/zlib/"));
    z_lib.addCSourceFiles(.{
        .files = z_sources.files.items,
        .flags = &.{
            "-DHAVE_SYS_TYPES_H",
            "-DHAVE_STDINT_H",
            "-DHAVE_STDDEF_H",
            "-DZ_HAVE_UNISTD_H",
        },
    });
    z_lib.linkLibC();

    // orca cli tool

    const version: []const u8 = blk: {
        if (git_version_opt) |git_version| {
            break :blk try b.allocator.dupe(u8, git_version);
        } else {
            const git_version = b.run(&.{ "git", "rev-parse", "--short", "HEAD" });
            try stringpool_data.append(git_version);
            break :blk std.mem.trimRight(u8, git_version, "\n");
        }
    };
    defer b.allocator.free(version);

    var orca_tool_compile_flags = std.ArrayList([]const u8).init(b.allocator);
    defer orca_tool_compile_flags.deinit();
    try orca_tool_compile_flags.append("-DFLAG_IMPLEMENTATION");
    try orca_tool_compile_flags.append("-DOC_NO_APP_LAYER");
    try orca_tool_compile_flags.append("-DOC_BUILD_DLL");
    try orca_tool_compile_flags.append("-DCURL_STATICLIB");
    try orca_tool_compile_flags.append(try printf("-DORCA_TOOL_VERSION={s}", .{version}));

    if (optimize == .Debug) {
        try orca_tool_compile_flags.append("-DOC_DEBUG");
        try orca_tool_compile_flags.append("-DOC_LOG_COMPILE_DEBUG");
    }

    const orca_tool_exe = b.addExecutable(.{
        .name = "orca_tool",
        .target = target,
        .optimize = optimize,
    });
    orca_tool_exe.addIncludePath(b.path("src/"));
    orca_tool_exe.addIncludePath(b.path("src/tool"));
    orca_tool_exe.addIncludePath(b.path("src/ext/stb"));
    orca_tool_exe.addIncludePath(b.path("src/ext/curl/include"));
    orca_tool_exe.addIncludePath(b.path("src/ext/zlib"));
    orca_tool_exe.addIncludePath(b.path("src/ext/microtar"));

    orca_tool_exe.addCSourceFiles(.{
        .files = &.{"src/tool/main.c"},
        .flags = orca_tool_compile_flags.items,
    });

    orca_tool_exe.linkLibrary(curl_lib);
    orca_tool_exe.linkLibrary(z_lib);
    orca_tool_exe.linkSystemLibrary("shlwapi");
    orca_tool_exe.linkSystemLibrary("shell32");
    orca_tool_exe.linkSystemLibrary("ole32");
    orca_tool_exe.linkSystemLibrary("kernel32");

    orca_tool_exe.step.dependOn(&curl_lib.step);
    orca_tool_exe.step.dependOn(&z_lib.step);
    orca_tool_exe.linkLibC();

    b.installArtifact(orca_tool_exe);

    /////////////////////////////////////////////////////////////////
    // TODO bundle

    // python_build_libc.step.dependOn(&orca_runtime_exe.step);
    // python_build_sdk.step.dependOn(&python_build_libc.step);
    // orca_tool_exe.step.dependOn(&python_build_sdk.step);
    // python_build_tool.step.dependOn(&python_build_sdk.step);

    // b.getInstallStep().dependOn(&orca_tool_exe.step);

    // ensure_programs()

    // build_runtime_internal(args.release, args.wasm_backend) # this also builds the platform layer
    // build_libc_internal(args.release)
    // build_sdk_internal(args.release)
    // build_tool(args)

    // const python_install =

    // b.getInstallStep().dependOn(&python_install.step);

    /////////////////////////////////////////////////////////////////
    // zig build clean

    // TODO consider making a standalone step different from the default uninstall
    {
        var uninstall_step = b.getUninstallStep();
        const paths = [_][]const u8{
            ".zig-cache",
            "build",
            "src/ext/angle",
            "src/ext/dawn",
            "scripts/files",
            "scripts/__pycache",
            // TODO generated wasm bindings?
        };
        for (paths) |path| {
            var remove_dir = b.addRemoveDirTree(path);
            uninstall_step.dependOn(&remove_dir.step);
        }
    }

    /////////////////////////////////////////////////////////////////
    // tests

    // print("Removing build artifacts...")
    // yeetdir("build")
    // yeetdir("src/ext/angle")
    // yeetdir("src/ext/dawn")
    // yeetdir("scripts/files")
    // yeetdir("scripts/__pycache__")

    // build_all_step.dependOn(&python_build_all.step);

    // test_step.dependOn(&run_lib_unit_tests.step);
    // test_step.dependOn(&run_exe_unit_tests.step);

    // const run_lib_unit_tests = b.addRunArtifact(lib_unit_tests);

    // const exe = b.addExecutable(.{
    //     .name = "zig_init",
    //     .root_source_file = b.path("src/main.zig"),
    //     .target = target,
    //     .optimize = optimize,
    // });

    // // This declares intent for the executable to be installed into the
    // // standard location when the user invokes the "install" step (the default
    // // step when running `zig build`).
    // b.installArtifact(exe);

    // // This *creates* a Run step in the build graph, to be executed when another
    // // step is evaluated that depends on it. The next line below will establish
    // // such a dependency.
    // const run_cmd = b.addRunArtifact(exe);

    // // By making the run step depend on the install step, it will be run from the
    // // installation directory rather than directly from within the cache directory.
    // // This is not necessary, however, if the application depends on other installed
    // // files, this ensures they will be present and in the expected location.
    // run_cmd.step.dependOn(b.getInstallStep());

    // // This allows the user to pass arguments to the application in the build
    // // command itself, like this: `zig build run -- arg1 arg2 etc`
    // if (b.args) |args| {
    //     run_cmd.addArgs(args);
    // }

    // This creates a build step. It will be visible in the `zig build --help` menu,
    // and can be selected like this: `zig build run`
    // This will evaluate the `run` step rather than the default, which is "install".
    // const run_step = b.step("run", "Run the app");
    // run_step.dependOn(&run_cmd.step);

    // // Creates a step for unit testing. This only builds the test executable
    // // but does not run it.
    // const lib_unit_tests = b.addTest(.{
    //     .root_source_file = b.path("src/root.zig"),
    //     .target = target,
    //     .optimize = optimize,
    // });

    // const run_lib_unit_tests = b.addRunArtifact(lib_unit_tests);

    // const exe_unit_tests = b.addTest(.{
    //     .root_source_file = b.path("src/main.zig"),
    //     .target = target,
    //     .optimize = optimize,
    // });

    // const run_exe_unit_tests = b.addRunArtifact(exe_unit_tests);

    // // Similar to creating the run step earlier, this exposes a `test` step to
    // // the `zig build --help` menu, providing a way for the user to request
    // // running the unit tests.
    // const test_step = b.step("test", "Run unit tests");
    // test_step.dependOn(&run_lib_unit_tests.step);
    // test_step.dependOn(&run_exe_unit_tests.step);
}
