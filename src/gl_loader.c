/********************************************************
*
*	@file: gl_loader.c
*	@note: auto-generated by glapi.py from gl.xml
*	@date: 07/082023
*
*********************************************************/
#include"gl_loader.h"
#include"platform.h"

mp_thread_local mg_gl_api* __mgGLAPI = 0;
mg_gl_api __mgGLNoAPI;

void mg_glPointParameterfv_noimpl(GLenum pname, const GLfloat * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPointParameterfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform3fv_noimpl(GLint location, GLsizei count, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform3fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform1i_noimpl(GLint location, GLint v0)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform1i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribP3ui_noimpl(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribP3ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4sv_noimpl(GLuint index, const GLshort * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4sv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetBufferParameteriv_noimpl(GLenum target, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetBufferParameteriv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform2dv_noimpl(GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform2dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glClampColor_noimpl(GLenum target, GLenum clamp)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClampColor is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCompressedTexImage3D_noimpl(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCompressedTexImage3D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix2x4fv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix2x4fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform2d_noimpl(GLuint program, GLint location, GLdouble v0, GLdouble v1)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform2d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindBuffer_noimpl(GLenum target, GLuint buffer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindBuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLuint mg_glGetUniformBlockIndex_noimpl(GLuint program, const GLchar * uniformBlockName)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetUniformBlockIndex is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLuint)0);
}
void mg_glInvalidateFramebuffer_noimpl(GLenum target, GLsizei numAttachments, const GLenum * attachments)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glInvalidateFramebuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPixelStorei_noimpl(GLenum pname, GLint param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPixelStorei is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindTexture_noimpl(GLenum target, GLuint texture)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindTexture is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4Nuiv_noimpl(GLuint index, const GLuint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4Nuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsTexture_noimpl(GLuint texture)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsTexture is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glVertexAttrib4d_noimpl(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix2x4dv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix2x4dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetObjectLabel_noimpl(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetObjectLabel is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBeginConditionalRender_noimpl(GLuint id, GLenum mode)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBeginConditionalRender is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsFramebuffer_noimpl(GLuint framebuffer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsFramebuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glCompileShader_noimpl(GLuint shader)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCompileShader is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribBinding_noimpl(GLuint attribindex, GLuint bindingindex)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribBinding is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribL1dv_noimpl(GLuint index, const GLdouble * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribL1dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform1fv_noimpl(GLint location, GLsizei count, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform1fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexImage2D_noimpl(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void * pixels)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexImage2D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glFlush_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFlush is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribP2uiv_noimpl(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribP2uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsProgram_noimpl(GLuint program)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsProgram is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glProgramUniform4fv_noimpl(GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform4fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribLPointer_noimpl(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribLPointer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLenum mg_glClientWaitSync_noimpl(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClientWaitSync is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLenum)0);
}
void mg_glUniform1d_noimpl(GLint location, GLdouble x)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform1d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform1ui_noimpl(GLuint program, GLint location, GLuint v0)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform1ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glColorMask_noimpl(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glColorMask is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glClearDepth_noimpl(GLdouble depth)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearDepth is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetInteger64v_noimpl(GLenum pname, GLint64 * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetInteger64v is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribP2ui_noimpl(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribP2ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib2dv_noimpl(GLuint index, const GLdouble * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib2dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI4ui_noimpl(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI4ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBlendEquationi_noimpl(GLuint buf, GLenum mode)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBlendEquationi is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawRangeElements_noimpl(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawRangeElements is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glInvalidateTexImage_noimpl(GLuint texture, GLint level)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glInvalidateTexImage is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glSampleMaski_noimpl(GLuint maskNumber, GLbitfield mask)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glSampleMaski is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLint mg_glGetProgramResourceLocationIndex_noimpl(GLuint program, GLenum programInterface, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramResourceLocationIndex is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLint)0);
}
void mg_glVertexAttrib4dv_noimpl(GLuint index, const GLdouble * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindFragDataLocation_noimpl(GLuint program, GLuint color, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindFragDataLocation is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLint mg_glGetFragDataIndex_noimpl(GLuint program, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetFragDataIndex is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLint)0);
}
void mg_glGetTexLevelParameterfv_noimpl(GLenum target, GLint level, GLenum pname, GLfloat * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetTexLevelParameterfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribP4uiv_noimpl(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribP4uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glMultiDrawArrays_noimpl(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glMultiDrawArrays is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsTransformFeedback_noimpl(GLuint id)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsTransformFeedback is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glGetUniformiv_noimpl(GLuint program, GLint location, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetUniformiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBufferData_noimpl(GLenum target, GLsizeiptr size, const void * data, GLenum usage)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBufferData is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetCompressedTexImage_noimpl(GLenum target, GLint level, void * img)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetCompressedTexImage is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib3sv_noimpl(GLuint index, const GLshort * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib3sv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsQuery_noimpl(GLuint id)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsQuery is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glClearColor_noimpl(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearColor is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBlendFunc_noimpl(GLenum sfactor, GLenum dfactor)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBlendFunc is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetDoublei_v_noimpl(GLenum target, GLuint index, GLdouble * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetDoublei_v is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glFramebufferTexture_noimpl(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFramebufferTexture is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glStencilMaskSeparate_noimpl(GLenum face, GLuint mask)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glStencilMaskSeparate is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPrimitiveRestartIndex_noimpl(GLuint index)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPrimitiveRestartIndex is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribP1ui_noimpl(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribP1ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribIFormat_noimpl(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribIFormat is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glMemoryBarrier_noimpl(GLbitfield barriers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glMemoryBarrier is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLint mg_glGetSubroutineUniformLocation_noimpl(GLuint program, GLenum shadertype, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetSubroutineUniformLocation is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLint)0);
}
void mg_glBindRenderbuffer_noimpl(GLenum target, GLuint renderbuffer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindRenderbuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPushDebugGroup_noimpl(GLenum source, GLuint id, GLsizei length, const GLchar * message)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPushDebugGroup is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGenTextures_noimpl(GLsizei n, GLuint * textures)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGenTextures is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetIntegerv_noimpl(GLenum pname, GLint * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetIntegerv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetQueryObjectuiv_noimpl(GLuint id, GLenum pname, GLuint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetQueryObjectuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform4fv_noimpl(GLint location, GLsizei count, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform4fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glHint_noimpl(GLenum target, GLenum mode)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glHint is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexParameterf_noimpl(GLenum target, GLenum pname, GLfloat param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexParameterf is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform2fv_noimpl(GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform2fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawRangeElementsBaseVertex_noimpl(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawRangeElementsBaseVertex is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glClear_noimpl(GLbitfield mask)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClear is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindBufferBase_noimpl(GLenum target, GLuint index, GLuint buffer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindBufferBase is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetQueryiv_noimpl(GLenum target, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetQueryiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramBinary_noimpl(GLuint program, GLenum binaryFormat, const void * binary, GLsizei length)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramBinary is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glScissorIndexedv_noimpl(GLuint index, const GLint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glScissorIndexedv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib1fv_noimpl(GLuint index, const GLfloat * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib1fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexStorage2D_noimpl(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexStorage2D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4f_noimpl(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramParameteri_noimpl(GLuint program, GLenum pname, GLint value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramParameteri is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glEnable_noimpl(GLenum cap)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glEnable is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetBufferPointerv_noimpl(GLenum target, GLenum pname, void ** params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetBufferPointerv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glLogicOp_noimpl(GLenum opcode)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glLogicOp is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDepthFunc_noimpl(GLenum func)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDepthFunc is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib1dv_noimpl(GLuint index, const GLdouble * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib1dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform2d_noimpl(GLint location, GLdouble x, GLdouble y)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform2d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDetachShader_noimpl(GLuint program, GLuint shader)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDetachShader is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexBindingDivisor_noimpl(GLuint bindingindex, GLuint divisor)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexBindingDivisor is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsProgramPipeline_noimpl(GLuint pipeline)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsProgramPipeline is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glProgramUniform1fv_noimpl(GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform1fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCopyTexSubImage2D_noimpl(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCopyTexSubImage2D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib2fv_noimpl(GLuint index, const GLfloat * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib2fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetDoublev_noimpl(GLenum pname, GLdouble * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetDoublev is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glResumeTransformFeedback_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glResumeTransformFeedback is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform4d_noimpl(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform4d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform4uiv_noimpl(GLuint program, GLint location, GLsizei count, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform4uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDispatchCompute_noimpl(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDispatchCompute is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4bv_noimpl(GLuint index, const GLbyte * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4bv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetSamplerParameterfv_noimpl(GLuint sampler, GLenum pname, GLfloat * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetSamplerParameterfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform3iv_noimpl(GLuint program, GLint location, GLsizei count, const GLint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform3iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib1s_noimpl(GLuint index, GLshort x)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib1s is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI2i_noimpl(GLuint index, GLint x, GLint y)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI2i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glSampleCoverage_noimpl(GLfloat value, GLboolean invert)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glSampleCoverage is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBufferSubData_noimpl(GLenum target, GLintptr offset, GLsizeiptr size, const void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBufferSubData is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI1ui_noimpl(GLuint index, GLuint x)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI1ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glEndConditionalRender_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glEndConditionalRender is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetPointerv_noimpl(GLenum pname, void ** params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetPointerv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetnUniformiv_noimpl(GLuint program, GLint location, GLsizei bufSize, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetnUniformiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBlendEquation_noimpl(GLenum mode)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBlendEquation is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI4iv_noimpl(GLuint index, const GLint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI4iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetnUniformfv_noimpl(GLuint program, GLint location, GLsizei bufSize, GLfloat * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetnUniformfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4Nsv_noimpl(GLuint index, const GLshort * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4Nsv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform2fv_noimpl(GLint location, GLsizei count, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform2fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform3f_noimpl(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform3f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGenerateMipmap_noimpl(GLenum target)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGenerateMipmap is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGenRenderbuffers_noimpl(GLsizei n, GLuint * renderbuffers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGenRenderbuffers is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawElementsBaseVertex_noimpl(GLenum mode, GLsizei count, GLenum type, const void * indices, GLint basevertex)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawElementsBaseVertex is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindVertexBuffers_noimpl(GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindVertexBuffers is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glScissor_noimpl(GLint x, GLint y, GLsizei width, GLsizei height)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glScissor is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void * mg_glMapBufferRange_noimpl(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glMapBufferRange is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((void *)0);
}
void mg_glProgramUniformMatrix4x2fv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix4x2fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetTexParameterfv_noimpl(GLenum target, GLenum pname, GLfloat * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetTexParameterfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform2f_noimpl(GLint location, GLfloat v0, GLfloat v1)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform2f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribFormat_noimpl(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribFormat is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix2dv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix2dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsEnabled_noimpl(GLenum cap)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsEnabled is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glClearBufferfi_noimpl(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearBufferfi is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetRenderbufferParameteriv_noimpl(GLenum target, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetRenderbufferParameteriv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glFramebufferTextureLayer_noimpl(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFramebufferTextureLayer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPointParameterf_noimpl(GLenum pname, GLfloat param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPointParameterf is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGenVertexArrays_noimpl(GLsizei n, GLuint * arrays)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGenVertexArrays is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetAttachedShaders_noimpl(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * shaders)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetAttachedShaders is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glFramebufferRenderbuffer_noimpl(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFramebufferRenderbuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDeleteTextures_noimpl(GLsizei n, const GLuint * textures)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteTextures is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBeginQuery_noimpl(GLenum target, GLuint id)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBeginQuery is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform4dv_noimpl(GLint location, GLsizei count, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform4dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribIPointer_noimpl(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribIPointer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetSamplerParameterIiv_noimpl(GLuint sampler, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetSamplerParameterIiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBeginQueryIndexed_noimpl(GLenum target, GLuint index, GLuint id)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBeginQueryIndexed is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBeginTransformFeedback_noimpl(GLenum primitiveMode)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBeginTransformFeedback is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform3i_noimpl(GLint location, GLint v0, GLint v1, GLint v2)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform3i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetActiveUniformName_noimpl(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetActiveUniformName is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLint mg_glGetProgramResourceLocation_noimpl(GLuint program, GLenum programInterface, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramResourceLocation is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLint)0);
}
void mg_glShaderSource_noimpl(GLuint shader, GLsizei count, const GLchar *const* string, const GLint * length)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glShaderSource is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glSamplerParameterIiv_noimpl(GLuint sampler, GLenum pname, const GLint * param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glSamplerParameterIiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glFinish_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFinish is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawArraysInstancedBaseInstance_noimpl(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawArraysInstancedBaseInstance is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDeleteProgram_noimpl(GLuint program)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteProgram is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glMultiDrawElementsBaseVertex_noimpl(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount, const GLint * basevertex)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glMultiDrawElementsBaseVertex is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glReadBuffer_noimpl(GLenum src)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glReadBuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGenBuffers_noimpl(GLsizei n, GLuint * buffers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGenBuffers is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glClearDepthf_noimpl(GLfloat d)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearDepthf is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribPointer_noimpl(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribPointer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribL4dv_noimpl(GLuint index, const GLdouble * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribL4dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexStorage2DMultisample_noimpl(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexStorage2DMultisample is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindSamplers_noimpl(GLuint first, GLsizei count, const GLuint * samplers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindSamplers is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glEnableVertexAttribArray_noimpl(GLuint index)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glEnableVertexAttribArray is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4ubv_noimpl(GLuint index, const GLubyte * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4ubv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLuint mg_glGetDebugMessageLog_noimpl(GLuint count, GLsizei bufSize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetDebugMessageLog is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLuint)0);
}
void mg_glDisableVertexAttribArray_noimpl(GLuint index)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDisableVertexAttribArray is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawElementsInstancedBaseInstance_noimpl(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawElementsInstancedBaseInstance is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPolygonMode_noimpl(GLenum face, GLenum mode)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPolygonMode is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribP1uiv_noimpl(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribP1uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform1iv_noimpl(GLuint program, GLint location, GLsizei count, const GLint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform1iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI1i_noimpl(GLuint index, GLint x)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI1i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetTexLevelParameteriv_noimpl(GLenum target, GLint level, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetTexLevelParameteriv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsSync_noimpl(GLsync sync)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsSync is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glTexStorage1D_noimpl(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexStorage1D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetVertexAttribIiv_noimpl(GLuint index, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetVertexAttribIiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsEnabledi_noimpl(GLenum target, GLuint index)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsEnabledi is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glMultiDrawElementsIndirect_noimpl(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glMultiDrawElementsIndirect is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetBooleani_v_noimpl(GLenum target, GLuint index, GLboolean * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetBooleani_v is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetInternalformativ_noimpl(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetInternalformativ is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI4ubv_noimpl(GLuint index, const GLubyte * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI4ubv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib2s_noimpl(GLuint index, GLshort x, GLshort y)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib2s is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetBooleanv_noimpl(GLenum pname, GLboolean * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetBooleanv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4iv_noimpl(GLuint index, const GLint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetObjectPtrLabel_noimpl(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetObjectPtrLabel is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix2x4dv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix2x4dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform4ui_noimpl(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform4ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetVertexAttribdv_noimpl(GLuint index, GLenum pname, GLdouble * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetVertexAttribdv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glViewportIndexedf_noimpl(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glViewportIndexedf is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDeleteSync_noimpl(GLsync sync)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteSync is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCopyImageSubData_noimpl(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCopyImageSubData is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPrimitiveBoundingBox_noimpl(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPrimitiveBoundingBox is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glScissorIndexed_noimpl(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glScissorIndexed is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGenTransformFeedbacks_noimpl(GLsizei n, GLuint * ids)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGenTransformFeedbacks is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glMemoryBarrierByRegion_noimpl(GLbitfield barriers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glMemoryBarrierByRegion is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDeleteTransformFeedbacks_noimpl(GLsizei n, const GLuint * ids)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteTransformFeedbacks is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform4f_noimpl(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform4f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindBuffersBase_noimpl(GLenum target, GLuint first, GLsizei count, const GLuint * buffers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindBuffersBase is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetTexParameterIuiv_noimpl(GLenum target, GLenum pname, GLuint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetTexParameterIuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsShader_noimpl(GLuint shader)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsShader is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glProgramUniform3i_noimpl(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform3i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetActiveAtomicCounterBufferiv_noimpl(GLuint program, GLuint bufferIndex, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetActiveAtomicCounterBufferiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix3x4fv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix3x4fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBufferStorage_noimpl(GLenum target, GLsizeiptr size, const void * data, GLbitfield flags)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBufferStorage is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetUniformSubroutineuiv_noimpl(GLenum shadertype, GLint location, GLuint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetUniformSubroutineuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glRenderbufferStorageMultisample_noimpl(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glRenderbufferStorageMultisample is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetMultisamplefv_noimpl(GLenum pname, GLuint index, GLfloat * val)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetMultisamplefv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribDivisor_noimpl(GLuint index, GLuint divisor)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribDivisor is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glStencilMask_noimpl(GLuint mask)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glStencilMask is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindSampler_noimpl(GLuint unit, GLuint sampler)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindSampler is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix4dv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix4dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindImageTexture_noimpl(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindImageTexture is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawBuffers_noimpl(GLsizei n, const GLenum * bufs)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawBuffers is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4Nub_noimpl(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4Nub is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetTexImage_noimpl(GLenum target, GLint level, GLenum format, GLenum type, void * pixels)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetTexImage is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib3dv_noimpl(GLuint index, const GLdouble * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib3dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBlitFramebuffer_noimpl(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBlitFramebuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib2d_noimpl(GLuint index, GLdouble x, GLdouble y)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib2d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform1ui_noimpl(GLint location, GLuint v0)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform1ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glInvalidateBufferSubData_noimpl(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glInvalidateBufferSubData is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glEndQuery_noimpl(GLenum target)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glEndQuery is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetUniformuiv_noimpl(GLuint program, GLint location, GLuint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetUniformuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetFramebufferAttachmentParameteriv_noimpl(GLenum target, GLenum attachment, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetFramebufferAttachmentParameteriv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform2f_noimpl(GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform2f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix3x2fv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix3x2fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindVertexBuffer_noimpl(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindVertexBuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib2sv_noimpl(GLuint index, const GLshort * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib2sv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform1f_noimpl(GLint location, GLfloat v0)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform1f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDebugMessageCallback_noimpl(GLDEBUGPROC callback, const void * userParam)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDebugMessageCallback is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glReadPixels_noimpl(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void * pixels)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glReadPixels is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCompressedTexSubImage1D_noimpl(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCompressedTexSubImage1D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawArraysIndirect_noimpl(GLenum mode, const void * indirect)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawArraysIndirect is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBlendFuncSeparate_noimpl(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBlendFuncSeparate is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLuint mg_glCreateShader_noimpl(GLenum type)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCreateShader is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLuint)0);
}
void mg_glGetTransformFeedbackVarying_noimpl(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetTransformFeedbackVarying is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glAttachShader_noimpl(GLuint program, GLuint shader)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glAttachShader is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix2x3dv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix2x3dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform3uiv_noimpl(GLuint program, GLint location, GLsizei count, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform3uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glMultiDrawArraysIndirect_noimpl(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glMultiDrawArraysIndirect is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform2iv_noimpl(GLint location, GLsizei count, const GLint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform2iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindBufferRange_noimpl(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindBufferRange is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexParameteriv_noimpl(GLenum target, GLenum pname, const GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexParameteriv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribL3d_noimpl(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribL3d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexImage3DMultisample_noimpl(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexImage3DMultisample is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glClearTexSubImage_noimpl(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearTexSubImage is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4Nusv_noimpl(GLuint index, const GLushort * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4Nusv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glInvalidateSubFramebuffer_noimpl(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glInvalidateSubFramebuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetShaderInfoLog_noimpl(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetShaderInfoLog is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribP4ui_noimpl(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribP4ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glViewport_noimpl(GLint x, GLint y, GLsizei width, GLsizei height)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glViewport is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBlendFunci_noimpl(GLuint buf, GLenum src, GLenum dst)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBlendFunci is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPolygonOffset_noimpl(GLfloat factor, GLfloat units)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPolygonOffset is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform2ui_noimpl(GLuint program, GLint location, GLuint v0, GLuint v1)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform2ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glSamplerParameteri_noimpl(GLuint sampler, GLenum pname, GLint param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glSamplerParameteri is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetFramebufferParameteriv_noimpl(GLenum target, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetFramebufferParameteriv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI2iv_noimpl(GLuint index, const GLint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI2iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glObjectLabel_noimpl(GLenum identifier, GLuint name, GLsizei length, const GLchar * label)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glObjectLabel is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCompressedTexImage1D_noimpl(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCompressedTexImage1D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glInvalidateTexSubImage_noimpl(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glInvalidateTexSubImage is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindBuffersRange_noimpl(GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizeiptr * sizes)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindBuffersRange is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCopyBufferSubData_noimpl(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCopyBufferSubData is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4Nbv_noimpl(GLuint index, const GLbyte * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4Nbv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glObjectPtrLabel_noimpl(const void * ptr, GLsizei length, const GLchar * label)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glObjectPtrLabel is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform3d_noimpl(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform3d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetProgramPipelineiv_noimpl(GLuint pipeline, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramPipelineiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexStorage3DMultisample_noimpl(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexStorage3DMultisample is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribL3dv_noimpl(GLuint index, const GLdouble * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribL3dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDeleteFramebuffers_noimpl(GLsizei n, const GLuint * framebuffers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteFramebuffers is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLenum mg_glCheckFramebufferStatus_noimpl(GLenum target)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCheckFramebufferStatus is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLenum)0);
}
void mg_glVertexAttribL2dv_noimpl(GLuint index, const GLdouble * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribL2dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform1dv_noimpl(GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform1dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib2f_noimpl(GLuint index, GLfloat x, GLfloat y)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib2f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetVertexAttribIuiv_noimpl(GLuint index, GLenum pname, GLuint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetVertexAttribIuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glStencilOp_noimpl(GLenum fail, GLenum zfail, GLenum zpass)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glStencilOp is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib3d_noimpl(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib3d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPointParameteri_noimpl(GLenum pname, GLint param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPointParameteri is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI1uiv_noimpl(GLuint index, const GLuint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI1uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glClearBufferfv_noimpl(GLenum buffer, GLint drawbuffer, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearBufferfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindFragDataLocationIndexed_noimpl(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindFragDataLocationIndexed is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform1d_noimpl(GLuint program, GLint location, GLdouble v0)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform1d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPointParameteriv_noimpl(GLenum pname, const GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPointParameteriv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glFlushMappedBufferRange_noimpl(GLenum target, GLintptr offset, GLsizeiptr length)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFlushMappedBufferRange is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTextureView_noimpl(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTextureView is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetProgramPipelineInfoLog_noimpl(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramPipelineInfoLog is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCopyTexImage2D_noimpl(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCopyTexImage2D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform3dv_noimpl(GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform3dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glQueryCounter_noimpl(GLuint id, GLenum target)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glQueryCounter is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetUniformfv_noimpl(GLuint program, GLint location, GLfloat * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetUniformfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glClearStencil_noimpl(GLint s)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearStencil is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetProgramiv_noimpl(GLuint program, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformSubroutinesuiv_noimpl(GLenum shadertype, GLsizei count, const GLuint * indices)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformSubroutinesuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetProgramStageiv_noimpl(GLuint program, GLenum shadertype, GLenum pname, GLint * values)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramStageiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform1iv_noimpl(GLint location, GLsizei count, const GLint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform1iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetVertexAttribPointerv_noimpl(GLuint index, GLenum pname, void ** pointer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetVertexAttribPointerv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexSubImage1D_noimpl(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexSubImage1D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glStencilFuncSeparate_noimpl(GLenum face, GLenum func, GLint ref, GLuint mask)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glStencilFuncSeparate is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLuint mg_glGetSubroutineIndex_noimpl(GLuint program, GLenum shadertype, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetSubroutineIndex is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLuint)0);
}
void mg_glDrawElementsInstanced_noimpl(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawElementsInstanced is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBlendFuncSeparatei_noimpl(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBlendFuncSeparatei is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix3x2dv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix3x2dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetActiveUniformsiv_noimpl(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetActiveUniformsiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix3fv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix3fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix3x4dv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix3x4dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetSamplerParameterIuiv_noimpl(GLuint sampler, GLenum pname, GLuint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetSamplerParameterIuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI4i_noimpl(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI4i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBlendEquationSeparate_noimpl(GLenum modeRGB, GLenum modeAlpha)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBlendEquationSeparate is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix4x2fv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix4x2fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexParameterIiv_noimpl(GLenum target, GLenum pname, const GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexParameterIiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawTransformFeedbackStream_noimpl(GLenum mode, GLuint id, GLuint stream)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawTransformFeedbackStream is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI1iv_noimpl(GLuint index, const GLint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI1iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetUniformIndices_noimpl(GLuint program, GLsizei uniformCount, const GLchar *const* uniformNames, GLuint * uniformIndices)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetUniformIndices is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetShaderiv_noimpl(GLuint shader, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetShaderiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetActiveUniform_noimpl(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetActiveUniform is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform3uiv_noimpl(GLint location, GLsizei count, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform3uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPatchParameteri_noimpl(GLenum pname, GLint value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPatchParameteri is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix2dv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix2dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glWaitSync_noimpl(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glWaitSync is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glClearTexImage_noimpl(GLuint texture, GLint level, GLenum format, GLenum type, const void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearTexImage is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDepthRangeIndexed_noimpl(GLuint index, GLdouble n, GLdouble f)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDepthRangeIndexed is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetTexParameterIiv_noimpl(GLenum target, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetTexParameterIiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDepthRange_noimpl(GLdouble n, GLdouble f)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDepthRange is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetActiveAttrib_noimpl(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetActiveAttrib is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsRenderbuffer_noimpl(GLuint renderbuffer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsRenderbuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glClearBufferiv_noimpl(GLenum buffer, GLint drawbuffer, const GLint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearBufferiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform3fv_noimpl(GLuint program, GLint location, GLsizei count, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform3fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI3uiv_noimpl(GLuint index, const GLuint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI3uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUseProgram_noimpl(GLuint program)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUseProgram is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetActiveSubroutineName_noimpl(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetActiveSubroutineName is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix3fv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix3fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix4x3dv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix4x3dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix4x3dv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix4x3dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform4dv_noimpl(GLuint program, GLint location, GLsizei count, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform4dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetBufferSubData_noimpl(GLenum target, GLintptr offset, GLsizeiptr size, void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetBufferSubData is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4uiv_noimpl(GLuint index, const GLuint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib1f_noimpl(GLuint index, GLfloat x)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib1f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4usv_noimpl(GLuint index, const GLushort * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4usv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDebugMessageInsert_noimpl(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDebugMessageInsert is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glEndTransformFeedback_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glEndTransformFeedback is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexImage2DMultisample_noimpl(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexImage2DMultisample is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindTransformFeedback_noimpl(GLenum target, GLuint id)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindTransformFeedback is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform3dv_noimpl(GLint location, GLsizei count, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform3dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix3x2dv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix3x2dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetSamplerParameteriv_noimpl(GLuint sampler, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetSamplerParameteriv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribP3uiv_noimpl(GLuint index, GLenum type, GLboolean normalized, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribP3uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform4d_noimpl(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform4d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix3dv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix3dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform3ui_noimpl(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform3ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDeleteVertexArrays_noimpl(GLsizei n, const GLuint * arrays)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteVertexArrays is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexParameteri_noimpl(GLenum target, GLenum pname, GLint param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexParameteri is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawElementsInstancedBaseVertex_noimpl(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawElementsInstancedBaseVertex is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetQueryObjectui64v_noimpl(GLuint id, GLenum pname, GLuint64 * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetQueryObjectui64v is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4Niv_noimpl(GLuint index, const GLint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4Niv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glSamplerParameterfv_noimpl(GLuint sampler, GLenum pname, const GLfloat * param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glSamplerParameterfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI4bv_noimpl(GLuint index, const GLbyte * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI4bv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform1i_noimpl(GLuint program, GLint location, GLint v0)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform1i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix4x2dv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix4x2dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetSynciv_noimpl(GLsync sync, GLenum pname, GLsizei count, GLsizei * length, GLint * values)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetSynciv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib3f_noimpl(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib3f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetQueryObjectiv_noimpl(GLuint id, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetQueryObjectiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetProgramInfoLog_noimpl(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramInfoLog is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetActiveUniformBlockiv_noimpl(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetActiveUniformBlockiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGenQueries_noimpl(GLsizei n, GLuint * ids)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGenQueries is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix4x3fv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix4x3fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexBuffer_noimpl(GLenum target, GLenum internalformat, GLuint buffer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexBuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glShaderStorageBlockBinding_noimpl(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glShaderStorageBlockBinding is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDisable_noimpl(GLenum cap)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDisable is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI3ui_noimpl(GLuint index, GLuint x, GLuint y, GLuint z)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI3ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsSampler_noimpl(GLuint sampler)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsSampler is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glActiveShaderProgram_noimpl(GLuint pipeline, GLuint program)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glActiveShaderProgram is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindVertexArray_noimpl(GLuint array)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindVertexArray is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix2x3fv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix2x3fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawArraysInstanced_noimpl(GLenum mode, GLint first, GLsizei count, GLsizei instancecount)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawArraysInstanced is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI2uiv_noimpl(GLuint index, const GLuint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI2uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetQueryObjecti64v_noimpl(GLuint id, GLenum pname, GLint64 * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetQueryObjecti64v is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
const GLubyte * mg_glGetStringi_noimpl(GLenum name, GLuint index)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetStringi is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((const GLubyte *)0);
}
void mg_glBindProgramPipeline_noimpl(GLuint pipeline)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindProgramPipeline is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindFramebuffer_noimpl(GLenum target, GLuint framebuffer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindFramebuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib1d_noimpl(GLuint index, GLdouble x)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib1d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glRenderbufferStorage_noimpl(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glRenderbufferStorage is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glReleaseShaderCompiler_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glReleaseShaderCompiler is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform2i_noimpl(GLint location, GLint v0, GLint v1)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform2i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawBuffer_noimpl(GLenum buf)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawBuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDeleteRenderbuffers_noimpl(GLsizei n, const GLuint * renderbuffers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteRenderbuffers is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDeleteBuffers_noimpl(GLsizei n, const GLuint * buffers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteBuffers is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGenFramebuffers_noimpl(GLsizei n, GLuint * framebuffers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGenFramebuffers is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix4dv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix4dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform3f_noimpl(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform3f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform2iv_noimpl(GLuint program, GLint location, GLsizei count, const GLint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform2iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBlendBarrier_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBlendBarrier is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribL2d_noimpl(GLuint index, GLdouble x, GLdouble y)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribL2d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCompressedTexSubImage2D_noimpl(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCompressedTexSubImage2D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix2fv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix2fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glSamplerParameterf_noimpl(GLuint sampler, GLenum pname, GLfloat param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glSamplerParameterf is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix4fv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix4fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI2ui_noimpl(GLuint index, GLuint x, GLuint y)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI2ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindTextures_noimpl(GLuint first, GLsizei count, const GLuint * textures)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindTextures is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform3d_noimpl(GLint location, GLdouble x, GLdouble y, GLdouble z)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform3d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glViewportIndexedfv_noimpl(GLuint index, const GLfloat * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glViewportIndexedfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI4sv_noimpl(GLuint index, const GLshort * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI4sv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glLineWidth_noimpl(GLfloat width)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glLineWidth is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetVertexAttribfv_noimpl(GLuint index, GLenum pname, GLfloat * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetVertexAttribfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI3iv_noimpl(GLuint index, const GLint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI3iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform1dv_noimpl(GLint location, GLsizei count, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform1dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCullFace_noimpl(GLenum mode)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCullFace is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLuint mg_glCreateProgram_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCreateProgram is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLuint)0);
}
void mg_glUniform4i_noimpl(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform4i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix4x3fv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix4x3fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLint mg_glGetAttribLocation_noimpl(GLuint program, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetAttribLocation is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLint)0);
}
void mg_glGetShaderPrecisionFormat_noimpl(GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetShaderPrecisionFormat is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform4iv_noimpl(GLint location, GLsizei count, const GLint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform4iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCompressedTexSubImage3D_noimpl(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCompressedTexSubImage3D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindImageTextures_noimpl(GLuint first, GLsizei count, const GLuint * textures)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindImageTextures is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetBufferParameteri64v_noimpl(GLenum target, GLenum pname, GLint64 * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetBufferParameteri64v is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glFrontFace_noimpl(GLenum mode)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFrontFace is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPopDebugGroup_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPopDebugGroup is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib1sv_noimpl(GLuint index, const GLshort * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib1sv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glInvalidateBufferData_noimpl(GLuint buffer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glInvalidateBufferData is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glIsVertexArray_noimpl(GLuint array)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsVertexArray is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glScissorArrayv_noimpl(GLuint first, GLsizei count, const GLint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glScissorArrayv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glValidateProgram_noimpl(GLuint program)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glValidateProgram is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform2uiv_noimpl(GLint location, GLsizei count, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform2uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexSubImage2D_noimpl(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexSubImage2D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDebugMessageControl_noimpl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDebugMessageControl is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glFramebufferParameteri_noimpl(GLenum target, GLenum pname, GLint param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFramebufferParameteri is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLint mg_glGetUniformLocation_noimpl(GLuint program, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetUniformLocation is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLint)0);
}
void mg_glTexStorage3D_noimpl(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexStorage3D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPixelStoref_noimpl(GLenum pname, GLfloat param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPixelStoref is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDepthRangef_noimpl(GLfloat n, GLfloat f)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDepthRangef is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI3i_noimpl(GLuint index, GLint x, GLint y, GLint z)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI3i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform1uiv_noimpl(GLint location, GLsizei count, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform1uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDisablei_noimpl(GLenum target, GLuint index)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDisablei is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetInternalformati64v_noimpl(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetInternalformati64v is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix2x3dv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix2x3dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLuint mg_glGetProgramResourceIndex_noimpl(GLuint program, GLenum programInterface, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramResourceIndex is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLuint)0);
}
void mg_glBlendColor_noimpl(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBlendColor is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGenSamplers_noimpl(GLsizei count, GLuint * samplers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGenSamplers is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glColorMaski_noimpl(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glColorMaski is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLenum mg_glGetGraphicsResetStatus_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetGraphicsResetStatus is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLenum)0);
}
void mg_glVertexAttribI4uiv_noimpl(GLuint index, const GLuint * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI4uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLuint mg_glCreateShaderProgramv_noimpl(GLenum type, GLsizei count, const GLchar *const* strings)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCreateShaderProgramv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLuint)0);
}
void mg_glDeleteSamplers_noimpl(GLsizei count, const GLuint * samplers)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteSamplers is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib3s_noimpl(GLuint index, GLshort x, GLshort y, GLshort z)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib3s is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawTransformFeedback_noimpl(GLenum mode, GLuint id)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawTransformFeedback is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribL1d_noimpl(GLuint index, GLdouble x)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribL1d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawElementsInstancedBaseVertexBaseInstance_noimpl(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawElementsInstancedBaseVertexBaseInstance is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glClearBufferSubData_noimpl(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearBufferSubData is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribLFormat_noimpl(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribLFormat is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform2dv_noimpl(GLint location, GLsizei count, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform2dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCopyTexSubImage3D_noimpl(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCopyTexSubImage3D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCopyTexImage1D_noimpl(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCopyTexImage1D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glFramebufferTexture3D_noimpl(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFramebufferTexture3D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribL4d_noimpl(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribL4d is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLboolean mg_glUnmapBuffer_noimpl(GLenum target)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUnmapBuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glGetQueryIndexediv_noimpl(GLenum target, GLuint index, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetQueryIndexediv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLsync mg_glFenceSync_noimpl(GLenum condition, GLbitfield flags)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFenceSync is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLsync)0);
}
void mg_glDispatchComputeIndirect_noimpl(GLintptr indirect)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDispatchComputeIndirect is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glSamplerParameterIuiv_noimpl(GLuint sampler, GLenum pname, const GLuint * param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glSamplerParameterIuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLint mg_glGetFragDataLocation_noimpl(GLuint program, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetFragDataLocation is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLint)0);
}
void mg_glGetUniformdv_noimpl(GLuint program, GLint location, GLdouble * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetUniformdv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexImage3D_noimpl(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void * pixels)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexImage3D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glValidateProgramPipeline_noimpl(GLuint pipeline)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glValidateProgramPipeline is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glLinkProgram_noimpl(GLuint program)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glLinkProgram is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDeleteQueries_noimpl(GLsizei n, const GLuint * ids)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteQueries is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glFramebufferTexture1D_noimpl(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFramebufferTexture1D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetActiveSubroutineUniformName_noimpl(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetActiveSubroutineUniformName is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix3x2fv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix3x2fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetTexParameteriv_noimpl(GLenum target, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetTexParameteriv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProvokingVertex_noimpl(GLenum mode)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProvokingVertex is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBindAttribLocation_noimpl(GLuint program, GLuint index, const GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBindAttribLocation is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib3fv_noimpl(GLuint index, const GLfloat * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib3fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetActiveUniformBlockName_noimpl(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetActiveUniformBlockName is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawArrays_noimpl(GLenum mode, GLint first, GLsizei count)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawArrays is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetnUniformuiv_noimpl(GLuint program, GLint location, GLsizei bufSize, GLuint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetnUniformuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform1uiv_noimpl(GLuint program, GLint location, GLsizei count, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform1uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawElementsIndirect_noimpl(GLenum mode, GLenum type, const void * indirect)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawElementsIndirect is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttribI4usv_noimpl(GLuint index, const GLushort * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttribI4usv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glBlendEquationSeparatei_noimpl(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glBlendEquationSeparatei is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawElements_noimpl(GLenum mode, GLsizei count, GLenum type, const void * indices)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawElements is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetShaderSource_noimpl(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetShaderSource is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTransformFeedbackVaryings_noimpl(GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTransformFeedbackVaryings is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
GLenum mg_glGetError_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetError is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLenum)0);
}
GLboolean mg_glIsBuffer_noimpl(GLuint buffer)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glIsBuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((GLboolean)0);
}
void mg_glClearBufferuiv_noimpl(GLenum buffer, GLint drawbuffer, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearBufferuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetVertexAttribiv_noimpl(GLuint index, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetVertexAttribiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetProgramResourceName_noimpl(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramResourceName is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform2ui_noimpl(GLint location, GLuint v0, GLuint v1)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform2ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glStencilFunc_noimpl(GLenum func, GLint ref, GLuint mask)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glStencilFunc is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glEnablei_noimpl(GLenum target, GLuint index)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glEnablei is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glSamplerParameteriv_noimpl(GLuint sampler, GLenum pname, const GLint * param)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glSamplerParameteriv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetInteger64i_v_noimpl(GLenum target, GLuint index, GLint64 * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetInteger64i_v is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform4i_noimpl(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform4i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform4ui_noimpl(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform4ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix2x4fv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix2x4fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glReadnPixels_noimpl(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glReadnPixels is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawTransformFeedbackInstanced_noimpl(GLenum mode, GLuint id, GLsizei instancecount)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawTransformFeedbackInstanced is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPointSize_noimpl(GLfloat size)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPointSize is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix4fv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix4fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glViewportArrayv_noimpl(GLuint first, GLsizei count, const GLfloat * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glViewportArrayv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glStencilOpSeparate_noimpl(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glStencilOpSeparate is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform3ui_noimpl(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform3ui is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform4uiv_noimpl(GLint location, GLsizei count, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform4uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform3iv_noimpl(GLint location, GLsizei count, const GLint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform3iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniform4f_noimpl(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniform4f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glFramebufferTexture2D_noimpl(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glFramebufferTexture2D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetIntegeri_v_noimpl(GLenum target, GLuint index, GLint * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetIntegeri_v is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glMultiDrawElements_noimpl(GLenum mode, const GLsizei * count, GLenum type, const void *const* indices, GLsizei drawcount)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glMultiDrawElements is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix4x2dv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix4x2dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniformMatrix2x3fv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix2x3fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCopyTexSubImage1D_noimpl(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCopyTexSubImage1D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexSubImage3D_noimpl(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexSubImage3D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetActiveSubroutineUniformiv_noimpl(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetActiveSubroutineUniformiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGenProgramPipelines_noimpl(GLsizei n, GLuint * pipelines)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGenProgramPipelines is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform4iv_noimpl(GLuint program, GLint location, GLsizei count, const GLint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform4iv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix3x4fv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix3x4fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformBlockBinding_noimpl(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformBlockBinding is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDepthRangeArrayv_noimpl(GLuint first, GLsizei count, const GLdouble * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDepthRangeArrayv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexParameterfv_noimpl(GLenum target, GLenum pname, const GLfloat * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexParameterfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void * mg_glMapBuffer_noimpl(GLenum target, GLenum access)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glMapBuffer is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((void *)0);
}
void mg_glDeleteProgramPipelines_noimpl(GLsizei n, const GLuint * pipelines)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteProgramPipelines is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glMinSampleShading_noimpl(GLfloat value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glMinSampleShading is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPauseTransformFeedback_noimpl()
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPauseTransformFeedback is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glEndQueryIndexed_noimpl(GLenum target, GLuint index)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glEndQueryIndexed is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetProgramBinary_noimpl(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, void * binary)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramBinary is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform2i_noimpl(GLuint program, GLint location, GLint v0, GLint v1)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform2i is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDepthMask_noimpl(GLboolean flag)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDepthMask is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glActiveTexture_noimpl(GLenum texture)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glActiveTexture is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUseProgramStages_noimpl(GLuint pipeline, GLbitfield stages, GLuint program)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUseProgramStages is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glPatchParameterfv_noimpl(GLenum pname, const GLfloat * values)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glPatchParameterfv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glShaderBinary_noimpl(GLsizei count, const GLuint * shaders, GLenum binaryFormat, const void * binary, GLsizei length)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glShaderBinary is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetFloatv_noimpl(GLenum pname, GLfloat * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetFloatv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform1f_noimpl(GLuint program, GLint location, GLfloat v0)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform1f is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexImage1D_noimpl(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void * pixels)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexImage1D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glProgramUniform2uiv_noimpl(GLuint program, GLint location, GLsizei count, const GLuint * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniform2uiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glClearBufferData_noimpl(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glClearBufferData is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix3dv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix3dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glCompressedTexImage2D_noimpl(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glCompressedTexImage2D is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4fv_noimpl(GLuint index, const GLfloat * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetProgramResourceiv_noimpl(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei count, GLsizei * length, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramResourceiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
const GLubyte * mg_glGetString_noimpl(GLenum name)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetString is not part of currently selected %s API\n", __mgGLAPI->name);
	}
	return((const GLubyte *)0);
}
void mg_glProgramUniformMatrix2fv_noimpl(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glProgramUniformMatrix2fv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetVertexAttribLdv_noimpl(GLuint index, GLenum pname, GLdouble * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetVertexAttribLdv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4Nubv_noimpl(GLuint index, const GLubyte * v)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4Nubv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexBufferRange_noimpl(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexBufferRange is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glUniformMatrix3x4dv_noimpl(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glUniformMatrix3x4dv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetProgramInterfaceiv_noimpl(GLuint program, GLenum programInterface, GLenum pname, GLint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetProgramInterfaceiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glTexParameterIuiv_noimpl(GLenum target, GLenum pname, const GLuint * params)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glTexParameterIuiv is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDeleteShader_noimpl(GLuint shader)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDeleteShader is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glGetFloati_v_noimpl(GLenum target, GLuint index, GLfloat * data)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glGetFloati_v is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glDrawTransformFeedbackStreamInstanced_noimpl(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glDrawTransformFeedbackStreamInstanced is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
void mg_glVertexAttrib4s_noimpl(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
	if(__mgGLAPI == &__mgGLNoAPI)
	{
		log_error("No GL or GLES API is selected. Make sure you call mg_surface_prepare() before calling OpenGL API functions.\n");
	}
	else
	{
		log_error("glVertexAttrib4s is not part of currently selected %s API\n", __mgGLAPI->name);
	}
}
mg_gl_api __mgGLNoAPI = {
	.PointParameterfv = mg_glPointParameterfv_noimpl,
	.Uniform3fv = mg_glUniform3fv_noimpl,
	.Uniform1i = mg_glUniform1i_noimpl,
	.VertexAttribP3ui = mg_glVertexAttribP3ui_noimpl,
	.VertexAttrib4sv = mg_glVertexAttrib4sv_noimpl,
	.GetBufferParameteriv = mg_glGetBufferParameteriv_noimpl,
	.ProgramUniform2dv = mg_glProgramUniform2dv_noimpl,
	.ClampColor = mg_glClampColor_noimpl,
	.CompressedTexImage3D = mg_glCompressedTexImage3D_noimpl,
	.ProgramUniformMatrix2x4fv = mg_glProgramUniformMatrix2x4fv_noimpl,
	.ProgramUniform2d = mg_glProgramUniform2d_noimpl,
	.BindBuffer = mg_glBindBuffer_noimpl,
	.GetUniformBlockIndex = mg_glGetUniformBlockIndex_noimpl,
	.InvalidateFramebuffer = mg_glInvalidateFramebuffer_noimpl,
	.PixelStorei = mg_glPixelStorei_noimpl,
	.BindTexture = mg_glBindTexture_noimpl,
	.VertexAttrib4Nuiv = mg_glVertexAttrib4Nuiv_noimpl,
	.IsTexture = mg_glIsTexture_noimpl,
	.VertexAttrib4d = mg_glVertexAttrib4d_noimpl,
	.ProgramUniformMatrix2x4dv = mg_glProgramUniformMatrix2x4dv_noimpl,
	.GetObjectLabel = mg_glGetObjectLabel_noimpl,
	.BeginConditionalRender = mg_glBeginConditionalRender_noimpl,
	.IsFramebuffer = mg_glIsFramebuffer_noimpl,
	.CompileShader = mg_glCompileShader_noimpl,
	.VertexAttribBinding = mg_glVertexAttribBinding_noimpl,
	.VertexAttribL1dv = mg_glVertexAttribL1dv_noimpl,
	.Uniform1fv = mg_glUniform1fv_noimpl,
	.TexImage2D = mg_glTexImage2D_noimpl,
	.Flush = mg_glFlush_noimpl,
	.VertexAttribP2uiv = mg_glVertexAttribP2uiv_noimpl,
	.IsProgram = mg_glIsProgram_noimpl,
	.ProgramUniform4fv = mg_glProgramUniform4fv_noimpl,
	.VertexAttribLPointer = mg_glVertexAttribLPointer_noimpl,
	.ClientWaitSync = mg_glClientWaitSync_noimpl,
	.Uniform1d = mg_glUniform1d_noimpl,
	.ProgramUniform1ui = mg_glProgramUniform1ui_noimpl,
	.ColorMask = mg_glColorMask_noimpl,
	.ClearDepth = mg_glClearDepth_noimpl,
	.GetInteger64v = mg_glGetInteger64v_noimpl,
	.VertexAttribP2ui = mg_glVertexAttribP2ui_noimpl,
	.VertexAttrib2dv = mg_glVertexAttrib2dv_noimpl,
	.VertexAttribI4ui = mg_glVertexAttribI4ui_noimpl,
	.BlendEquationi = mg_glBlendEquationi_noimpl,
	.DrawRangeElements = mg_glDrawRangeElements_noimpl,
	.InvalidateTexImage = mg_glInvalidateTexImage_noimpl,
	.SampleMaski = mg_glSampleMaski_noimpl,
	.GetProgramResourceLocationIndex = mg_glGetProgramResourceLocationIndex_noimpl,
	.VertexAttrib4dv = mg_glVertexAttrib4dv_noimpl,
	.BindFragDataLocation = mg_glBindFragDataLocation_noimpl,
	.GetFragDataIndex = mg_glGetFragDataIndex_noimpl,
	.GetTexLevelParameterfv = mg_glGetTexLevelParameterfv_noimpl,
	.VertexAttribP4uiv = mg_glVertexAttribP4uiv_noimpl,
	.MultiDrawArrays = mg_glMultiDrawArrays_noimpl,
	.IsTransformFeedback = mg_glIsTransformFeedback_noimpl,
	.GetUniformiv = mg_glGetUniformiv_noimpl,
	.BufferData = mg_glBufferData_noimpl,
	.GetCompressedTexImage = mg_glGetCompressedTexImage_noimpl,
	.VertexAttrib3sv = mg_glVertexAttrib3sv_noimpl,
	.IsQuery = mg_glIsQuery_noimpl,
	.ClearColor = mg_glClearColor_noimpl,
	.BlendFunc = mg_glBlendFunc_noimpl,
	.GetDoublei_v = mg_glGetDoublei_v_noimpl,
	.FramebufferTexture = mg_glFramebufferTexture_noimpl,
	.StencilMaskSeparate = mg_glStencilMaskSeparate_noimpl,
	.PrimitiveRestartIndex = mg_glPrimitiveRestartIndex_noimpl,
	.VertexAttribP1ui = mg_glVertexAttribP1ui_noimpl,
	.VertexAttribIFormat = mg_glVertexAttribIFormat_noimpl,
	.MemoryBarrier = mg_glMemoryBarrier_noimpl,
	.GetSubroutineUniformLocation = mg_glGetSubroutineUniformLocation_noimpl,
	.BindRenderbuffer = mg_glBindRenderbuffer_noimpl,
	.PushDebugGroup = mg_glPushDebugGroup_noimpl,
	.GenTextures = mg_glGenTextures_noimpl,
	.GetIntegerv = mg_glGetIntegerv_noimpl,
	.GetQueryObjectuiv = mg_glGetQueryObjectuiv_noimpl,
	.Uniform4fv = mg_glUniform4fv_noimpl,
	.Hint = mg_glHint_noimpl,
	.TexParameterf = mg_glTexParameterf_noimpl,
	.ProgramUniform2fv = mg_glProgramUniform2fv_noimpl,
	.DrawRangeElementsBaseVertex = mg_glDrawRangeElementsBaseVertex_noimpl,
	.Clear = mg_glClear_noimpl,
	.BindBufferBase = mg_glBindBufferBase_noimpl,
	.GetQueryiv = mg_glGetQueryiv_noimpl,
	.ProgramBinary = mg_glProgramBinary_noimpl,
	.ScissorIndexedv = mg_glScissorIndexedv_noimpl,
	.VertexAttrib1fv = mg_glVertexAttrib1fv_noimpl,
	.TexStorage2D = mg_glTexStorage2D_noimpl,
	.VertexAttrib4f = mg_glVertexAttrib4f_noimpl,
	.ProgramParameteri = mg_glProgramParameteri_noimpl,
	.Enable = mg_glEnable_noimpl,
	.GetBufferPointerv = mg_glGetBufferPointerv_noimpl,
	.LogicOp = mg_glLogicOp_noimpl,
	.DepthFunc = mg_glDepthFunc_noimpl,
	.VertexAttrib1dv = mg_glVertexAttrib1dv_noimpl,
	.Uniform2d = mg_glUniform2d_noimpl,
	.DetachShader = mg_glDetachShader_noimpl,
	.VertexBindingDivisor = mg_glVertexBindingDivisor_noimpl,
	.IsProgramPipeline = mg_glIsProgramPipeline_noimpl,
	.ProgramUniform1fv = mg_glProgramUniform1fv_noimpl,
	.CopyTexSubImage2D = mg_glCopyTexSubImage2D_noimpl,
	.VertexAttrib2fv = mg_glVertexAttrib2fv_noimpl,
	.GetDoublev = mg_glGetDoublev_noimpl,
	.ResumeTransformFeedback = mg_glResumeTransformFeedback_noimpl,
	.ProgramUniform4d = mg_glProgramUniform4d_noimpl,
	.ProgramUniform4uiv = mg_glProgramUniform4uiv_noimpl,
	.DispatchCompute = mg_glDispatchCompute_noimpl,
	.VertexAttrib4bv = mg_glVertexAttrib4bv_noimpl,
	.GetSamplerParameterfv = mg_glGetSamplerParameterfv_noimpl,
	.ProgramUniform3iv = mg_glProgramUniform3iv_noimpl,
	.VertexAttrib1s = mg_glVertexAttrib1s_noimpl,
	.VertexAttribI2i = mg_glVertexAttribI2i_noimpl,
	.SampleCoverage = mg_glSampleCoverage_noimpl,
	.BufferSubData = mg_glBufferSubData_noimpl,
	.VertexAttribI1ui = mg_glVertexAttribI1ui_noimpl,
	.EndConditionalRender = mg_glEndConditionalRender_noimpl,
	.GetPointerv = mg_glGetPointerv_noimpl,
	.GetnUniformiv = mg_glGetnUniformiv_noimpl,
	.BlendEquation = mg_glBlendEquation_noimpl,
	.VertexAttribI4iv = mg_glVertexAttribI4iv_noimpl,
	.GetnUniformfv = mg_glGetnUniformfv_noimpl,
	.VertexAttrib4Nsv = mg_glVertexAttrib4Nsv_noimpl,
	.Uniform2fv = mg_glUniform2fv_noimpl,
	.Uniform3f = mg_glUniform3f_noimpl,
	.GenerateMipmap = mg_glGenerateMipmap_noimpl,
	.GenRenderbuffers = mg_glGenRenderbuffers_noimpl,
	.DrawElementsBaseVertex = mg_glDrawElementsBaseVertex_noimpl,
	.BindVertexBuffers = mg_glBindVertexBuffers_noimpl,
	.Scissor = mg_glScissor_noimpl,
	.MapBufferRange = mg_glMapBufferRange_noimpl,
	.ProgramUniformMatrix4x2fv = mg_glProgramUniformMatrix4x2fv_noimpl,
	.GetTexParameterfv = mg_glGetTexParameterfv_noimpl,
	.Uniform2f = mg_glUniform2f_noimpl,
	.VertexAttribFormat = mg_glVertexAttribFormat_noimpl,
	.UniformMatrix2dv = mg_glUniformMatrix2dv_noimpl,
	.IsEnabled = mg_glIsEnabled_noimpl,
	.ClearBufferfi = mg_glClearBufferfi_noimpl,
	.GetRenderbufferParameteriv = mg_glGetRenderbufferParameteriv_noimpl,
	.FramebufferTextureLayer = mg_glFramebufferTextureLayer_noimpl,
	.PointParameterf = mg_glPointParameterf_noimpl,
	.GenVertexArrays = mg_glGenVertexArrays_noimpl,
	.GetAttachedShaders = mg_glGetAttachedShaders_noimpl,
	.FramebufferRenderbuffer = mg_glFramebufferRenderbuffer_noimpl,
	.DeleteTextures = mg_glDeleteTextures_noimpl,
	.BeginQuery = mg_glBeginQuery_noimpl,
	.Uniform4dv = mg_glUniform4dv_noimpl,
	.VertexAttribIPointer = mg_glVertexAttribIPointer_noimpl,
	.GetSamplerParameterIiv = mg_glGetSamplerParameterIiv_noimpl,
	.BeginQueryIndexed = mg_glBeginQueryIndexed_noimpl,
	.BeginTransformFeedback = mg_glBeginTransformFeedback_noimpl,
	.Uniform3i = mg_glUniform3i_noimpl,
	.GetActiveUniformName = mg_glGetActiveUniformName_noimpl,
	.GetProgramResourceLocation = mg_glGetProgramResourceLocation_noimpl,
	.ShaderSource = mg_glShaderSource_noimpl,
	.SamplerParameterIiv = mg_glSamplerParameterIiv_noimpl,
	.Finish = mg_glFinish_noimpl,
	.DrawArraysInstancedBaseInstance = mg_glDrawArraysInstancedBaseInstance_noimpl,
	.DeleteProgram = mg_glDeleteProgram_noimpl,
	.MultiDrawElementsBaseVertex = mg_glMultiDrawElementsBaseVertex_noimpl,
	.ReadBuffer = mg_glReadBuffer_noimpl,
	.GenBuffers = mg_glGenBuffers_noimpl,
	.ClearDepthf = mg_glClearDepthf_noimpl,
	.VertexAttribPointer = mg_glVertexAttribPointer_noimpl,
	.VertexAttribL4dv = mg_glVertexAttribL4dv_noimpl,
	.TexStorage2DMultisample = mg_glTexStorage2DMultisample_noimpl,
	.BindSamplers = mg_glBindSamplers_noimpl,
	.EnableVertexAttribArray = mg_glEnableVertexAttribArray_noimpl,
	.VertexAttrib4ubv = mg_glVertexAttrib4ubv_noimpl,
	.GetDebugMessageLog = mg_glGetDebugMessageLog_noimpl,
	.DisableVertexAttribArray = mg_glDisableVertexAttribArray_noimpl,
	.DrawElementsInstancedBaseInstance = mg_glDrawElementsInstancedBaseInstance_noimpl,
	.PolygonMode = mg_glPolygonMode_noimpl,
	.VertexAttribP1uiv = mg_glVertexAttribP1uiv_noimpl,
	.ProgramUniform1iv = mg_glProgramUniform1iv_noimpl,
	.VertexAttribI1i = mg_glVertexAttribI1i_noimpl,
	.GetTexLevelParameteriv = mg_glGetTexLevelParameteriv_noimpl,
	.IsSync = mg_glIsSync_noimpl,
	.TexStorage1D = mg_glTexStorage1D_noimpl,
	.GetVertexAttribIiv = mg_glGetVertexAttribIiv_noimpl,
	.IsEnabledi = mg_glIsEnabledi_noimpl,
	.MultiDrawElementsIndirect = mg_glMultiDrawElementsIndirect_noimpl,
	.GetBooleani_v = mg_glGetBooleani_v_noimpl,
	.GetInternalformativ = mg_glGetInternalformativ_noimpl,
	.VertexAttribI4ubv = mg_glVertexAttribI4ubv_noimpl,
	.VertexAttrib2s = mg_glVertexAttrib2s_noimpl,
	.GetBooleanv = mg_glGetBooleanv_noimpl,
	.VertexAttrib4iv = mg_glVertexAttrib4iv_noimpl,
	.GetObjectPtrLabel = mg_glGetObjectPtrLabel_noimpl,
	.UniformMatrix2x4dv = mg_glUniformMatrix2x4dv_noimpl,
	.ProgramUniform4ui = mg_glProgramUniform4ui_noimpl,
	.GetVertexAttribdv = mg_glGetVertexAttribdv_noimpl,
	.ViewportIndexedf = mg_glViewportIndexedf_noimpl,
	.DeleteSync = mg_glDeleteSync_noimpl,
	.CopyImageSubData = mg_glCopyImageSubData_noimpl,
	.PrimitiveBoundingBox = mg_glPrimitiveBoundingBox_noimpl,
	.ScissorIndexed = mg_glScissorIndexed_noimpl,
	.GenTransformFeedbacks = mg_glGenTransformFeedbacks_noimpl,
	.MemoryBarrierByRegion = mg_glMemoryBarrierByRegion_noimpl,
	.DeleteTransformFeedbacks = mg_glDeleteTransformFeedbacks_noimpl,
	.ProgramUniform4f = mg_glProgramUniform4f_noimpl,
	.BindBuffersBase = mg_glBindBuffersBase_noimpl,
	.GetTexParameterIuiv = mg_glGetTexParameterIuiv_noimpl,
	.IsShader = mg_glIsShader_noimpl,
	.ProgramUniform3i = mg_glProgramUniform3i_noimpl,
	.GetActiveAtomicCounterBufferiv = mg_glGetActiveAtomicCounterBufferiv_noimpl,
	.ProgramUniformMatrix3x4fv = mg_glProgramUniformMatrix3x4fv_noimpl,
	.BufferStorage = mg_glBufferStorage_noimpl,
	.GetUniformSubroutineuiv = mg_glGetUniformSubroutineuiv_noimpl,
	.RenderbufferStorageMultisample = mg_glRenderbufferStorageMultisample_noimpl,
	.GetMultisamplefv = mg_glGetMultisamplefv_noimpl,
	.VertexAttribDivisor = mg_glVertexAttribDivisor_noimpl,
	.StencilMask = mg_glStencilMask_noimpl,
	.BindSampler = mg_glBindSampler_noimpl,
	.UniformMatrix4dv = mg_glUniformMatrix4dv_noimpl,
	.BindImageTexture = mg_glBindImageTexture_noimpl,
	.DrawBuffers = mg_glDrawBuffers_noimpl,
	.VertexAttrib4Nub = mg_glVertexAttrib4Nub_noimpl,
	.GetTexImage = mg_glGetTexImage_noimpl,
	.VertexAttrib3dv = mg_glVertexAttrib3dv_noimpl,
	.BlitFramebuffer = mg_glBlitFramebuffer_noimpl,
	.VertexAttrib2d = mg_glVertexAttrib2d_noimpl,
	.Uniform1ui = mg_glUniform1ui_noimpl,
	.InvalidateBufferSubData = mg_glInvalidateBufferSubData_noimpl,
	.EndQuery = mg_glEndQuery_noimpl,
	.GetUniformuiv = mg_glGetUniformuiv_noimpl,
	.GetFramebufferAttachmentParameteriv = mg_glGetFramebufferAttachmentParameteriv_noimpl,
	.ProgramUniform2f = mg_glProgramUniform2f_noimpl,
	.UniformMatrix3x2fv = mg_glUniformMatrix3x2fv_noimpl,
	.BindVertexBuffer = mg_glBindVertexBuffer_noimpl,
	.VertexAttrib2sv = mg_glVertexAttrib2sv_noimpl,
	.Uniform1f = mg_glUniform1f_noimpl,
	.DebugMessageCallback = mg_glDebugMessageCallback_noimpl,
	.ReadPixels = mg_glReadPixels_noimpl,
	.CompressedTexSubImage1D = mg_glCompressedTexSubImage1D_noimpl,
	.DrawArraysIndirect = mg_glDrawArraysIndirect_noimpl,
	.BlendFuncSeparate = mg_glBlendFuncSeparate_noimpl,
	.CreateShader = mg_glCreateShader_noimpl,
	.GetTransformFeedbackVarying = mg_glGetTransformFeedbackVarying_noimpl,
	.AttachShader = mg_glAttachShader_noimpl,
	.UniformMatrix2x3dv = mg_glUniformMatrix2x3dv_noimpl,
	.ProgramUniform3uiv = mg_glProgramUniform3uiv_noimpl,
	.MultiDrawArraysIndirect = mg_glMultiDrawArraysIndirect_noimpl,
	.Uniform2iv = mg_glUniform2iv_noimpl,
	.BindBufferRange = mg_glBindBufferRange_noimpl,
	.TexParameteriv = mg_glTexParameteriv_noimpl,
	.VertexAttribL3d = mg_glVertexAttribL3d_noimpl,
	.TexImage3DMultisample = mg_glTexImage3DMultisample_noimpl,
	.ClearTexSubImage = mg_glClearTexSubImage_noimpl,
	.VertexAttrib4Nusv = mg_glVertexAttrib4Nusv_noimpl,
	.InvalidateSubFramebuffer = mg_glInvalidateSubFramebuffer_noimpl,
	.GetShaderInfoLog = mg_glGetShaderInfoLog_noimpl,
	.VertexAttribP4ui = mg_glVertexAttribP4ui_noimpl,
	.Viewport = mg_glViewport_noimpl,
	.BlendFunci = mg_glBlendFunci_noimpl,
	.PolygonOffset = mg_glPolygonOffset_noimpl,
	.ProgramUniform2ui = mg_glProgramUniform2ui_noimpl,
	.SamplerParameteri = mg_glSamplerParameteri_noimpl,
	.GetFramebufferParameteriv = mg_glGetFramebufferParameteriv_noimpl,
	.VertexAttribI2iv = mg_glVertexAttribI2iv_noimpl,
	.ObjectLabel = mg_glObjectLabel_noimpl,
	.CompressedTexImage1D = mg_glCompressedTexImage1D_noimpl,
	.InvalidateTexSubImage = mg_glInvalidateTexSubImage_noimpl,
	.BindBuffersRange = mg_glBindBuffersRange_noimpl,
	.CopyBufferSubData = mg_glCopyBufferSubData_noimpl,
	.VertexAttrib4Nbv = mg_glVertexAttrib4Nbv_noimpl,
	.ObjectPtrLabel = mg_glObjectPtrLabel_noimpl,
	.ProgramUniform3d = mg_glProgramUniform3d_noimpl,
	.GetProgramPipelineiv = mg_glGetProgramPipelineiv_noimpl,
	.TexStorage3DMultisample = mg_glTexStorage3DMultisample_noimpl,
	.VertexAttribL3dv = mg_glVertexAttribL3dv_noimpl,
	.DeleteFramebuffers = mg_glDeleteFramebuffers_noimpl,
	.CheckFramebufferStatus = mg_glCheckFramebufferStatus_noimpl,
	.VertexAttribL2dv = mg_glVertexAttribL2dv_noimpl,
	.ProgramUniform1dv = mg_glProgramUniform1dv_noimpl,
	.VertexAttrib2f = mg_glVertexAttrib2f_noimpl,
	.GetVertexAttribIuiv = mg_glGetVertexAttribIuiv_noimpl,
	.StencilOp = mg_glStencilOp_noimpl,
	.VertexAttrib3d = mg_glVertexAttrib3d_noimpl,
	.PointParameteri = mg_glPointParameteri_noimpl,
	.VertexAttribI1uiv = mg_glVertexAttribI1uiv_noimpl,
	.ClearBufferfv = mg_glClearBufferfv_noimpl,
	.BindFragDataLocationIndexed = mg_glBindFragDataLocationIndexed_noimpl,
	.ProgramUniform1d = mg_glProgramUniform1d_noimpl,
	.PointParameteriv = mg_glPointParameteriv_noimpl,
	.FlushMappedBufferRange = mg_glFlushMappedBufferRange_noimpl,
	.TextureView = mg_glTextureView_noimpl,
	.GetProgramPipelineInfoLog = mg_glGetProgramPipelineInfoLog_noimpl,
	.CopyTexImage2D = mg_glCopyTexImage2D_noimpl,
	.ProgramUniform3dv = mg_glProgramUniform3dv_noimpl,
	.QueryCounter = mg_glQueryCounter_noimpl,
	.GetUniformfv = mg_glGetUniformfv_noimpl,
	.ClearStencil = mg_glClearStencil_noimpl,
	.GetProgramiv = mg_glGetProgramiv_noimpl,
	.UniformSubroutinesuiv = mg_glUniformSubroutinesuiv_noimpl,
	.GetProgramStageiv = mg_glGetProgramStageiv_noimpl,
	.Uniform1iv = mg_glUniform1iv_noimpl,
	.GetVertexAttribPointerv = mg_glGetVertexAttribPointerv_noimpl,
	.TexSubImage1D = mg_glTexSubImage1D_noimpl,
	.StencilFuncSeparate = mg_glStencilFuncSeparate_noimpl,
	.GetSubroutineIndex = mg_glGetSubroutineIndex_noimpl,
	.DrawElementsInstanced = mg_glDrawElementsInstanced_noimpl,
	.BlendFuncSeparatei = mg_glBlendFuncSeparatei_noimpl,
	.ProgramUniformMatrix3x2dv = mg_glProgramUniformMatrix3x2dv_noimpl,
	.GetActiveUniformsiv = mg_glGetActiveUniformsiv_noimpl,
	.UniformMatrix3fv = mg_glUniformMatrix3fv_noimpl,
	.ProgramUniformMatrix3x4dv = mg_glProgramUniformMatrix3x4dv_noimpl,
	.GetSamplerParameterIuiv = mg_glGetSamplerParameterIuiv_noimpl,
	.VertexAttribI4i = mg_glVertexAttribI4i_noimpl,
	.BlendEquationSeparate = mg_glBlendEquationSeparate_noimpl,
	.UniformMatrix4x2fv = mg_glUniformMatrix4x2fv_noimpl,
	.TexParameterIiv = mg_glTexParameterIiv_noimpl,
	.DrawTransformFeedbackStream = mg_glDrawTransformFeedbackStream_noimpl,
	.VertexAttribI1iv = mg_glVertexAttribI1iv_noimpl,
	.GetUniformIndices = mg_glGetUniformIndices_noimpl,
	.GetShaderiv = mg_glGetShaderiv_noimpl,
	.GetActiveUniform = mg_glGetActiveUniform_noimpl,
	.Uniform3uiv = mg_glUniform3uiv_noimpl,
	.PatchParameteri = mg_glPatchParameteri_noimpl,
	.ProgramUniformMatrix2dv = mg_glProgramUniformMatrix2dv_noimpl,
	.WaitSync = mg_glWaitSync_noimpl,
	.ClearTexImage = mg_glClearTexImage_noimpl,
	.DepthRangeIndexed = mg_glDepthRangeIndexed_noimpl,
	.GetTexParameterIiv = mg_glGetTexParameterIiv_noimpl,
	.DepthRange = mg_glDepthRange_noimpl,
	.GetActiveAttrib = mg_glGetActiveAttrib_noimpl,
	.IsRenderbuffer = mg_glIsRenderbuffer_noimpl,
	.ClearBufferiv = mg_glClearBufferiv_noimpl,
	.ProgramUniform3fv = mg_glProgramUniform3fv_noimpl,
	.VertexAttribI3uiv = mg_glVertexAttribI3uiv_noimpl,
	.UseProgram = mg_glUseProgram_noimpl,
	.GetActiveSubroutineName = mg_glGetActiveSubroutineName_noimpl,
	.ProgramUniformMatrix3fv = mg_glProgramUniformMatrix3fv_noimpl,
	.ProgramUniformMatrix4x3dv = mg_glProgramUniformMatrix4x3dv_noimpl,
	.UniformMatrix4x3dv = mg_glUniformMatrix4x3dv_noimpl,
	.ProgramUniform4dv = mg_glProgramUniform4dv_noimpl,
	.GetBufferSubData = mg_glGetBufferSubData_noimpl,
	.VertexAttrib4uiv = mg_glVertexAttrib4uiv_noimpl,
	.VertexAttrib1f = mg_glVertexAttrib1f_noimpl,
	.VertexAttrib4usv = mg_glVertexAttrib4usv_noimpl,
	.DebugMessageInsert = mg_glDebugMessageInsert_noimpl,
	.EndTransformFeedback = mg_glEndTransformFeedback_noimpl,
	.TexImage2DMultisample = mg_glTexImage2DMultisample_noimpl,
	.BindTransformFeedback = mg_glBindTransformFeedback_noimpl,
	.Uniform3dv = mg_glUniform3dv_noimpl,
	.UniformMatrix3x2dv = mg_glUniformMatrix3x2dv_noimpl,
	.GetSamplerParameteriv = mg_glGetSamplerParameteriv_noimpl,
	.VertexAttribP3uiv = mg_glVertexAttribP3uiv_noimpl,
	.Uniform4d = mg_glUniform4d_noimpl,
	.ProgramUniformMatrix3dv = mg_glProgramUniformMatrix3dv_noimpl,
	.ProgramUniform3ui = mg_glProgramUniform3ui_noimpl,
	.DeleteVertexArrays = mg_glDeleteVertexArrays_noimpl,
	.TexParameteri = mg_glTexParameteri_noimpl,
	.DrawElementsInstancedBaseVertex = mg_glDrawElementsInstancedBaseVertex_noimpl,
	.GetQueryObjectui64v = mg_glGetQueryObjectui64v_noimpl,
	.VertexAttrib4Niv = mg_glVertexAttrib4Niv_noimpl,
	.SamplerParameterfv = mg_glSamplerParameterfv_noimpl,
	.VertexAttribI4bv = mg_glVertexAttribI4bv_noimpl,
	.ProgramUniform1i = mg_glProgramUniform1i_noimpl,
	.ProgramUniformMatrix4x2dv = mg_glProgramUniformMatrix4x2dv_noimpl,
	.GetSynciv = mg_glGetSynciv_noimpl,
	.VertexAttrib3f = mg_glVertexAttrib3f_noimpl,
	.GetQueryObjectiv = mg_glGetQueryObjectiv_noimpl,
	.GetProgramInfoLog = mg_glGetProgramInfoLog_noimpl,
	.GetActiveUniformBlockiv = mg_glGetActiveUniformBlockiv_noimpl,
	.GenQueries = mg_glGenQueries_noimpl,
	.ProgramUniformMatrix4x3fv = mg_glProgramUniformMatrix4x3fv_noimpl,
	.TexBuffer = mg_glTexBuffer_noimpl,
	.ShaderStorageBlockBinding = mg_glShaderStorageBlockBinding_noimpl,
	.Disable = mg_glDisable_noimpl,
	.VertexAttribI3ui = mg_glVertexAttribI3ui_noimpl,
	.IsSampler = mg_glIsSampler_noimpl,
	.ActiveShaderProgram = mg_glActiveShaderProgram_noimpl,
	.BindVertexArray = mg_glBindVertexArray_noimpl,
	.UniformMatrix2x3fv = mg_glUniformMatrix2x3fv_noimpl,
	.DrawArraysInstanced = mg_glDrawArraysInstanced_noimpl,
	.VertexAttribI2uiv = mg_glVertexAttribI2uiv_noimpl,
	.GetQueryObjecti64v = mg_glGetQueryObjecti64v_noimpl,
	.GetStringi = mg_glGetStringi_noimpl,
	.BindProgramPipeline = mg_glBindProgramPipeline_noimpl,
	.BindFramebuffer = mg_glBindFramebuffer_noimpl,
	.VertexAttrib1d = mg_glVertexAttrib1d_noimpl,
	.RenderbufferStorage = mg_glRenderbufferStorage_noimpl,
	.ReleaseShaderCompiler = mg_glReleaseShaderCompiler_noimpl,
	.Uniform2i = mg_glUniform2i_noimpl,
	.DrawBuffer = mg_glDrawBuffer_noimpl,
	.DeleteRenderbuffers = mg_glDeleteRenderbuffers_noimpl,
	.DeleteBuffers = mg_glDeleteBuffers_noimpl,
	.GenFramebuffers = mg_glGenFramebuffers_noimpl,
	.ProgramUniformMatrix4dv = mg_glProgramUniformMatrix4dv_noimpl,
	.ProgramUniform3f = mg_glProgramUniform3f_noimpl,
	.ProgramUniform2iv = mg_glProgramUniform2iv_noimpl,
	.BlendBarrier = mg_glBlendBarrier_noimpl,
	.VertexAttribL2d = mg_glVertexAttribL2d_noimpl,
	.CompressedTexSubImage2D = mg_glCompressedTexSubImage2D_noimpl,
	.UniformMatrix2fv = mg_glUniformMatrix2fv_noimpl,
	.SamplerParameterf = mg_glSamplerParameterf_noimpl,
	.UniformMatrix4fv = mg_glUniformMatrix4fv_noimpl,
	.VertexAttribI2ui = mg_glVertexAttribI2ui_noimpl,
	.BindTextures = mg_glBindTextures_noimpl,
	.Uniform3d = mg_glUniform3d_noimpl,
	.ViewportIndexedfv = mg_glViewportIndexedfv_noimpl,
	.VertexAttribI4sv = mg_glVertexAttribI4sv_noimpl,
	.LineWidth = mg_glLineWidth_noimpl,
	.GetVertexAttribfv = mg_glGetVertexAttribfv_noimpl,
	.VertexAttribI3iv = mg_glVertexAttribI3iv_noimpl,
	.Uniform1dv = mg_glUniform1dv_noimpl,
	.CullFace = mg_glCullFace_noimpl,
	.CreateProgram = mg_glCreateProgram_noimpl,
	.Uniform4i = mg_glUniform4i_noimpl,
	.UniformMatrix4x3fv = mg_glUniformMatrix4x3fv_noimpl,
	.GetAttribLocation = mg_glGetAttribLocation_noimpl,
	.GetShaderPrecisionFormat = mg_glGetShaderPrecisionFormat_noimpl,
	.Uniform4iv = mg_glUniform4iv_noimpl,
	.CompressedTexSubImage3D = mg_glCompressedTexSubImage3D_noimpl,
	.BindImageTextures = mg_glBindImageTextures_noimpl,
	.GetBufferParameteri64v = mg_glGetBufferParameteri64v_noimpl,
	.FrontFace = mg_glFrontFace_noimpl,
	.PopDebugGroup = mg_glPopDebugGroup_noimpl,
	.VertexAttrib1sv = mg_glVertexAttrib1sv_noimpl,
	.InvalidateBufferData = mg_glInvalidateBufferData_noimpl,
	.IsVertexArray = mg_glIsVertexArray_noimpl,
	.ScissorArrayv = mg_glScissorArrayv_noimpl,
	.ValidateProgram = mg_glValidateProgram_noimpl,
	.Uniform2uiv = mg_glUniform2uiv_noimpl,
	.TexSubImage2D = mg_glTexSubImage2D_noimpl,
	.DebugMessageControl = mg_glDebugMessageControl_noimpl,
	.FramebufferParameteri = mg_glFramebufferParameteri_noimpl,
	.GetUniformLocation = mg_glGetUniformLocation_noimpl,
	.TexStorage3D = mg_glTexStorage3D_noimpl,
	.PixelStoref = mg_glPixelStoref_noimpl,
	.DepthRangef = mg_glDepthRangef_noimpl,
	.VertexAttribI3i = mg_glVertexAttribI3i_noimpl,
	.Uniform1uiv = mg_glUniform1uiv_noimpl,
	.Disablei = mg_glDisablei_noimpl,
	.GetInternalformati64v = mg_glGetInternalformati64v_noimpl,
	.ProgramUniformMatrix2x3dv = mg_glProgramUniformMatrix2x3dv_noimpl,
	.GetProgramResourceIndex = mg_glGetProgramResourceIndex_noimpl,
	.BlendColor = mg_glBlendColor_noimpl,
	.GenSamplers = mg_glGenSamplers_noimpl,
	.ColorMaski = mg_glColorMaski_noimpl,
	.GetGraphicsResetStatus = mg_glGetGraphicsResetStatus_noimpl,
	.VertexAttribI4uiv = mg_glVertexAttribI4uiv_noimpl,
	.CreateShaderProgramv = mg_glCreateShaderProgramv_noimpl,
	.DeleteSamplers = mg_glDeleteSamplers_noimpl,
	.VertexAttrib3s = mg_glVertexAttrib3s_noimpl,
	.DrawTransformFeedback = mg_glDrawTransformFeedback_noimpl,
	.VertexAttribL1d = mg_glVertexAttribL1d_noimpl,
	.DrawElementsInstancedBaseVertexBaseInstance = mg_glDrawElementsInstancedBaseVertexBaseInstance_noimpl,
	.ClearBufferSubData = mg_glClearBufferSubData_noimpl,
	.VertexAttribLFormat = mg_glVertexAttribLFormat_noimpl,
	.Uniform2dv = mg_glUniform2dv_noimpl,
	.CopyTexSubImage3D = mg_glCopyTexSubImage3D_noimpl,
	.CopyTexImage1D = mg_glCopyTexImage1D_noimpl,
	.FramebufferTexture3D = mg_glFramebufferTexture3D_noimpl,
	.VertexAttribL4d = mg_glVertexAttribL4d_noimpl,
	.UnmapBuffer = mg_glUnmapBuffer_noimpl,
	.GetQueryIndexediv = mg_glGetQueryIndexediv_noimpl,
	.FenceSync = mg_glFenceSync_noimpl,
	.DispatchComputeIndirect = mg_glDispatchComputeIndirect_noimpl,
	.SamplerParameterIuiv = mg_glSamplerParameterIuiv_noimpl,
	.GetFragDataLocation = mg_glGetFragDataLocation_noimpl,
	.GetUniformdv = mg_glGetUniformdv_noimpl,
	.TexImage3D = mg_glTexImage3D_noimpl,
	.ValidateProgramPipeline = mg_glValidateProgramPipeline_noimpl,
	.LinkProgram = mg_glLinkProgram_noimpl,
	.DeleteQueries = mg_glDeleteQueries_noimpl,
	.FramebufferTexture1D = mg_glFramebufferTexture1D_noimpl,
	.GetActiveSubroutineUniformName = mg_glGetActiveSubroutineUniformName_noimpl,
	.ProgramUniformMatrix3x2fv = mg_glProgramUniformMatrix3x2fv_noimpl,
	.GetTexParameteriv = mg_glGetTexParameteriv_noimpl,
	.ProvokingVertex = mg_glProvokingVertex_noimpl,
	.BindAttribLocation = mg_glBindAttribLocation_noimpl,
	.VertexAttrib3fv = mg_glVertexAttrib3fv_noimpl,
	.GetActiveUniformBlockName = mg_glGetActiveUniformBlockName_noimpl,
	.DrawArrays = mg_glDrawArrays_noimpl,
	.GetnUniformuiv = mg_glGetnUniformuiv_noimpl,
	.ProgramUniform1uiv = mg_glProgramUniform1uiv_noimpl,
	.DrawElementsIndirect = mg_glDrawElementsIndirect_noimpl,
	.VertexAttribI4usv = mg_glVertexAttribI4usv_noimpl,
	.BlendEquationSeparatei = mg_glBlendEquationSeparatei_noimpl,
	.DrawElements = mg_glDrawElements_noimpl,
	.GetShaderSource = mg_glGetShaderSource_noimpl,
	.TransformFeedbackVaryings = mg_glTransformFeedbackVaryings_noimpl,
	.GetError = mg_glGetError_noimpl,
	.IsBuffer = mg_glIsBuffer_noimpl,
	.ClearBufferuiv = mg_glClearBufferuiv_noimpl,
	.GetVertexAttribiv = mg_glGetVertexAttribiv_noimpl,
	.GetProgramResourceName = mg_glGetProgramResourceName_noimpl,
	.Uniform2ui = mg_glUniform2ui_noimpl,
	.StencilFunc = mg_glStencilFunc_noimpl,
	.Enablei = mg_glEnablei_noimpl,
	.SamplerParameteriv = mg_glSamplerParameteriv_noimpl,
	.GetInteger64i_v = mg_glGetInteger64i_v_noimpl,
	.ProgramUniform4i = mg_glProgramUniform4i_noimpl,
	.Uniform4ui = mg_glUniform4ui_noimpl,
	.UniformMatrix2x4fv = mg_glUniformMatrix2x4fv_noimpl,
	.ReadnPixels = mg_glReadnPixels_noimpl,
	.DrawTransformFeedbackInstanced = mg_glDrawTransformFeedbackInstanced_noimpl,
	.PointSize = mg_glPointSize_noimpl,
	.ProgramUniformMatrix4fv = mg_glProgramUniformMatrix4fv_noimpl,
	.ViewportArrayv = mg_glViewportArrayv_noimpl,
	.StencilOpSeparate = mg_glStencilOpSeparate_noimpl,
	.Uniform3ui = mg_glUniform3ui_noimpl,
	.Uniform4uiv = mg_glUniform4uiv_noimpl,
	.Uniform3iv = mg_glUniform3iv_noimpl,
	.Uniform4f = mg_glUniform4f_noimpl,
	.FramebufferTexture2D = mg_glFramebufferTexture2D_noimpl,
	.GetIntegeri_v = mg_glGetIntegeri_v_noimpl,
	.MultiDrawElements = mg_glMultiDrawElements_noimpl,
	.UniformMatrix4x2dv = mg_glUniformMatrix4x2dv_noimpl,
	.ProgramUniformMatrix2x3fv = mg_glProgramUniformMatrix2x3fv_noimpl,
	.CopyTexSubImage1D = mg_glCopyTexSubImage1D_noimpl,
	.TexSubImage3D = mg_glTexSubImage3D_noimpl,
	.GetActiveSubroutineUniformiv = mg_glGetActiveSubroutineUniformiv_noimpl,
	.GenProgramPipelines = mg_glGenProgramPipelines_noimpl,
	.ProgramUniform4iv = mg_glProgramUniform4iv_noimpl,
	.UniformMatrix3x4fv = mg_glUniformMatrix3x4fv_noimpl,
	.UniformBlockBinding = mg_glUniformBlockBinding_noimpl,
	.DepthRangeArrayv = mg_glDepthRangeArrayv_noimpl,
	.TexParameterfv = mg_glTexParameterfv_noimpl,
	.MapBuffer = mg_glMapBuffer_noimpl,
	.DeleteProgramPipelines = mg_glDeleteProgramPipelines_noimpl,
	.MinSampleShading = mg_glMinSampleShading_noimpl,
	.PauseTransformFeedback = mg_glPauseTransformFeedback_noimpl,
	.EndQueryIndexed = mg_glEndQueryIndexed_noimpl,
	.GetProgramBinary = mg_glGetProgramBinary_noimpl,
	.ProgramUniform2i = mg_glProgramUniform2i_noimpl,
	.DepthMask = mg_glDepthMask_noimpl,
	.ActiveTexture = mg_glActiveTexture_noimpl,
	.UseProgramStages = mg_glUseProgramStages_noimpl,
	.PatchParameterfv = mg_glPatchParameterfv_noimpl,
	.ShaderBinary = mg_glShaderBinary_noimpl,
	.GetFloatv = mg_glGetFloatv_noimpl,
	.ProgramUniform1f = mg_glProgramUniform1f_noimpl,
	.TexImage1D = mg_glTexImage1D_noimpl,
	.ProgramUniform2uiv = mg_glProgramUniform2uiv_noimpl,
	.ClearBufferData = mg_glClearBufferData_noimpl,
	.UniformMatrix3dv = mg_glUniformMatrix3dv_noimpl,
	.CompressedTexImage2D = mg_glCompressedTexImage2D_noimpl,
	.VertexAttrib4fv = mg_glVertexAttrib4fv_noimpl,
	.GetProgramResourceiv = mg_glGetProgramResourceiv_noimpl,
	.GetString = mg_glGetString_noimpl,
	.ProgramUniformMatrix2fv = mg_glProgramUniformMatrix2fv_noimpl,
	.GetVertexAttribLdv = mg_glGetVertexAttribLdv_noimpl,
	.VertexAttrib4Nubv = mg_glVertexAttrib4Nubv_noimpl,
	.TexBufferRange = mg_glTexBufferRange_noimpl,
	.UniformMatrix3x4dv = mg_glUniformMatrix3x4dv_noimpl,
	.GetProgramInterfaceiv = mg_glGetProgramInterfaceiv_noimpl,
	.TexParameterIuiv = mg_glTexParameterIuiv_noimpl,
	.DeleteShader = mg_glDeleteShader_noimpl,
	.GetFloati_v = mg_glGetFloati_v_noimpl,
	.DrawTransformFeedbackStreamInstanced = mg_glDrawTransformFeedbackStreamInstanced_noimpl,
	.VertexAttrib4s = mg_glVertexAttrib4s_noimpl,
};

void mg_gl_load_gl41(mg_gl_api* api, mg_gl_load_proc loadProc)
{
	api->name = "gl41";
	api->PointParameterfv = loadProc("glPointParameterfv");
	api->Uniform3fv = loadProc("glUniform3fv");
	api->Uniform1i = loadProc("glUniform1i");
	api->VertexAttribP3ui = loadProc("glVertexAttribP3ui");
	api->VertexAttrib4sv = loadProc("glVertexAttrib4sv");
	api->GetBufferParameteriv = loadProc("glGetBufferParameteriv");
	api->ProgramUniform2dv = loadProc("glProgramUniform2dv");
	api->ClampColor = loadProc("glClampColor");
	api->CompressedTexImage3D = loadProc("glCompressedTexImage3D");
	api->ProgramUniformMatrix2x4fv = loadProc("glProgramUniformMatrix2x4fv");
	api->ProgramUniform2d = loadProc("glProgramUniform2d");
	api->BindBuffer = loadProc("glBindBuffer");
	api->GetUniformBlockIndex = loadProc("glGetUniformBlockIndex");
	api->InvalidateFramebuffer = mg_glInvalidateFramebuffer_noimpl;
	api->PixelStorei = loadProc("glPixelStorei");
	api->BindTexture = loadProc("glBindTexture");
	api->VertexAttrib4Nuiv = loadProc("glVertexAttrib4Nuiv");
	api->IsTexture = loadProc("glIsTexture");
	api->VertexAttrib4d = loadProc("glVertexAttrib4d");
	api->ProgramUniformMatrix2x4dv = loadProc("glProgramUniformMatrix2x4dv");
	api->GetObjectLabel = mg_glGetObjectLabel_noimpl;
	api->BeginConditionalRender = loadProc("glBeginConditionalRender");
	api->IsFramebuffer = loadProc("glIsFramebuffer");
	api->CompileShader = loadProc("glCompileShader");
	api->VertexAttribBinding = mg_glVertexAttribBinding_noimpl;
	api->VertexAttribL1dv = loadProc("glVertexAttribL1dv");
	api->Uniform1fv = loadProc("glUniform1fv");
	api->TexImage2D = loadProc("glTexImage2D");
	api->Flush = loadProc("glFlush");
	api->VertexAttribP2uiv = loadProc("glVertexAttribP2uiv");
	api->IsProgram = loadProc("glIsProgram");
	api->ProgramUniform4fv = loadProc("glProgramUniform4fv");
	api->VertexAttribLPointer = loadProc("glVertexAttribLPointer");
	api->ClientWaitSync = loadProc("glClientWaitSync");
	api->Uniform1d = loadProc("glUniform1d");
	api->ProgramUniform1ui = loadProc("glProgramUniform1ui");
	api->ColorMask = loadProc("glColorMask");
	api->ClearDepth = loadProc("glClearDepth");
	api->GetInteger64v = loadProc("glGetInteger64v");
	api->VertexAttribP2ui = loadProc("glVertexAttribP2ui");
	api->VertexAttrib2dv = loadProc("glVertexAttrib2dv");
	api->VertexAttribI4ui = loadProc("glVertexAttribI4ui");
	api->BlendEquationi = loadProc("glBlendEquationi");
	api->DrawRangeElements = loadProc("glDrawRangeElements");
	api->InvalidateTexImage = mg_glInvalidateTexImage_noimpl;
	api->SampleMaski = loadProc("glSampleMaski");
	api->GetProgramResourceLocationIndex = mg_glGetProgramResourceLocationIndex_noimpl;
	api->VertexAttrib4dv = loadProc("glVertexAttrib4dv");
	api->BindFragDataLocation = loadProc("glBindFragDataLocation");
	api->GetFragDataIndex = loadProc("glGetFragDataIndex");
	api->GetTexLevelParameterfv = loadProc("glGetTexLevelParameterfv");
	api->VertexAttribP4uiv = loadProc("glVertexAttribP4uiv");
	api->MultiDrawArrays = loadProc("glMultiDrawArrays");
	api->IsTransformFeedback = loadProc("glIsTransformFeedback");
	api->GetUniformiv = loadProc("glGetUniformiv");
	api->BufferData = loadProc("glBufferData");
	api->GetCompressedTexImage = loadProc("glGetCompressedTexImage");
	api->VertexAttrib3sv = loadProc("glVertexAttrib3sv");
	api->IsQuery = loadProc("glIsQuery");
	api->ClearColor = loadProc("glClearColor");
	api->BlendFunc = loadProc("glBlendFunc");
	api->GetDoublei_v = loadProc("glGetDoublei_v");
	api->FramebufferTexture = loadProc("glFramebufferTexture");
	api->StencilMaskSeparate = loadProc("glStencilMaskSeparate");
	api->PrimitiveRestartIndex = loadProc("glPrimitiveRestartIndex");
	api->VertexAttribP1ui = loadProc("glVertexAttribP1ui");
	api->VertexAttribIFormat = mg_glVertexAttribIFormat_noimpl;
	api->MemoryBarrier = mg_glMemoryBarrier_noimpl;
	api->GetSubroutineUniformLocation = loadProc("glGetSubroutineUniformLocation");
	api->BindRenderbuffer = loadProc("glBindRenderbuffer");
	api->PushDebugGroup = mg_glPushDebugGroup_noimpl;
	api->GenTextures = loadProc("glGenTextures");
	api->GetIntegerv = loadProc("glGetIntegerv");
	api->GetQueryObjectuiv = loadProc("glGetQueryObjectuiv");
	api->Uniform4fv = loadProc("glUniform4fv");
	api->Hint = loadProc("glHint");
	api->TexParameterf = loadProc("glTexParameterf");
	api->ProgramUniform2fv = loadProc("glProgramUniform2fv");
	api->DrawRangeElementsBaseVertex = loadProc("glDrawRangeElementsBaseVertex");
	api->Clear = loadProc("glClear");
	api->BindBufferBase = loadProc("glBindBufferBase");
	api->GetQueryiv = loadProc("glGetQueryiv");
	api->ProgramBinary = loadProc("glProgramBinary");
	api->ScissorIndexedv = loadProc("glScissorIndexedv");
	api->VertexAttrib1fv = loadProc("glVertexAttrib1fv");
	api->TexStorage2D = mg_glTexStorage2D_noimpl;
	api->VertexAttrib4f = loadProc("glVertexAttrib4f");
	api->ProgramParameteri = loadProc("glProgramParameteri");
	api->Enable = loadProc("glEnable");
	api->GetBufferPointerv = loadProc("glGetBufferPointerv");
	api->LogicOp = loadProc("glLogicOp");
	api->DepthFunc = loadProc("glDepthFunc");
	api->VertexAttrib1dv = loadProc("glVertexAttrib1dv");
	api->Uniform2d = loadProc("glUniform2d");
	api->DetachShader = loadProc("glDetachShader");
	api->VertexBindingDivisor = mg_glVertexBindingDivisor_noimpl;
	api->IsProgramPipeline = loadProc("glIsProgramPipeline");
	api->ProgramUniform1fv = loadProc("glProgramUniform1fv");
	api->CopyTexSubImage2D = loadProc("glCopyTexSubImage2D");
	api->VertexAttrib2fv = loadProc("glVertexAttrib2fv");
	api->GetDoublev = loadProc("glGetDoublev");
	api->ResumeTransformFeedback = loadProc("glResumeTransformFeedback");
	api->ProgramUniform4d = loadProc("glProgramUniform4d");
	api->ProgramUniform4uiv = loadProc("glProgramUniform4uiv");
	api->DispatchCompute = mg_glDispatchCompute_noimpl;
	api->VertexAttrib4bv = loadProc("glVertexAttrib4bv");
	api->GetSamplerParameterfv = loadProc("glGetSamplerParameterfv");
	api->ProgramUniform3iv = loadProc("glProgramUniform3iv");
	api->VertexAttrib1s = loadProc("glVertexAttrib1s");
	api->VertexAttribI2i = loadProc("glVertexAttribI2i");
	api->SampleCoverage = loadProc("glSampleCoverage");
	api->BufferSubData = loadProc("glBufferSubData");
	api->VertexAttribI1ui = loadProc("glVertexAttribI1ui");
	api->EndConditionalRender = loadProc("glEndConditionalRender");
	api->GetPointerv = mg_glGetPointerv_noimpl;
	api->GetnUniformiv = mg_glGetnUniformiv_noimpl;
	api->BlendEquation = loadProc("glBlendEquation");
	api->VertexAttribI4iv = loadProc("glVertexAttribI4iv");
	api->GetnUniformfv = mg_glGetnUniformfv_noimpl;
	api->VertexAttrib4Nsv = loadProc("glVertexAttrib4Nsv");
	api->Uniform2fv = loadProc("glUniform2fv");
	api->Uniform3f = loadProc("glUniform3f");
	api->GenerateMipmap = loadProc("glGenerateMipmap");
	api->GenRenderbuffers = loadProc("glGenRenderbuffers");
	api->DrawElementsBaseVertex = loadProc("glDrawElementsBaseVertex");
	api->BindVertexBuffers = mg_glBindVertexBuffers_noimpl;
	api->Scissor = loadProc("glScissor");
	api->MapBufferRange = loadProc("glMapBufferRange");
	api->ProgramUniformMatrix4x2fv = loadProc("glProgramUniformMatrix4x2fv");
	api->GetTexParameterfv = loadProc("glGetTexParameterfv");
	api->Uniform2f = loadProc("glUniform2f");
	api->VertexAttribFormat = mg_glVertexAttribFormat_noimpl;
	api->UniformMatrix2dv = loadProc("glUniformMatrix2dv");
	api->IsEnabled = loadProc("glIsEnabled");
	api->ClearBufferfi = loadProc("glClearBufferfi");
	api->GetRenderbufferParameteriv = loadProc("glGetRenderbufferParameteriv");
	api->FramebufferTextureLayer = loadProc("glFramebufferTextureLayer");
	api->PointParameterf = loadProc("glPointParameterf");
	api->GenVertexArrays = loadProc("glGenVertexArrays");
	api->GetAttachedShaders = loadProc("glGetAttachedShaders");
	api->FramebufferRenderbuffer = loadProc("glFramebufferRenderbuffer");
	api->DeleteTextures = loadProc("glDeleteTextures");
	api->BeginQuery = loadProc("glBeginQuery");
	api->Uniform4dv = loadProc("glUniform4dv");
	api->VertexAttribIPointer = loadProc("glVertexAttribIPointer");
	api->GetSamplerParameterIiv = loadProc("glGetSamplerParameterIiv");
	api->BeginQueryIndexed = loadProc("glBeginQueryIndexed");
	api->BeginTransformFeedback = loadProc("glBeginTransformFeedback");
	api->Uniform3i = loadProc("glUniform3i");
	api->GetActiveUniformName = loadProc("glGetActiveUniformName");
	api->GetProgramResourceLocation = mg_glGetProgramResourceLocation_noimpl;
	api->ShaderSource = loadProc("glShaderSource");
	api->SamplerParameterIiv = loadProc("glSamplerParameterIiv");
	api->Finish = loadProc("glFinish");
	api->DrawArraysInstancedBaseInstance = mg_glDrawArraysInstancedBaseInstance_noimpl;
	api->DeleteProgram = loadProc("glDeleteProgram");
	api->MultiDrawElementsBaseVertex = loadProc("glMultiDrawElementsBaseVertex");
	api->ReadBuffer = loadProc("glReadBuffer");
	api->GenBuffers = loadProc("glGenBuffers");
	api->ClearDepthf = loadProc("glClearDepthf");
	api->VertexAttribPointer = loadProc("glVertexAttribPointer");
	api->VertexAttribL4dv = loadProc("glVertexAttribL4dv");
	api->TexStorage2DMultisample = mg_glTexStorage2DMultisample_noimpl;
	api->BindSamplers = mg_glBindSamplers_noimpl;
	api->EnableVertexAttribArray = loadProc("glEnableVertexAttribArray");
	api->VertexAttrib4ubv = loadProc("glVertexAttrib4ubv");
	api->GetDebugMessageLog = mg_glGetDebugMessageLog_noimpl;
	api->DisableVertexAttribArray = loadProc("glDisableVertexAttribArray");
	api->DrawElementsInstancedBaseInstance = mg_glDrawElementsInstancedBaseInstance_noimpl;
	api->PolygonMode = loadProc("glPolygonMode");
	api->VertexAttribP1uiv = loadProc("glVertexAttribP1uiv");
	api->ProgramUniform1iv = loadProc("glProgramUniform1iv");
	api->VertexAttribI1i = loadProc("glVertexAttribI1i");
	api->GetTexLevelParameteriv = loadProc("glGetTexLevelParameteriv");
	api->IsSync = loadProc("glIsSync");
	api->TexStorage1D = mg_glTexStorage1D_noimpl;
	api->GetVertexAttribIiv = loadProc("glGetVertexAttribIiv");
	api->IsEnabledi = loadProc("glIsEnabledi");
	api->MultiDrawElementsIndirect = mg_glMultiDrawElementsIndirect_noimpl;
	api->GetBooleani_v = loadProc("glGetBooleani_v");
	api->GetInternalformativ = mg_glGetInternalformativ_noimpl;
	api->VertexAttribI4ubv = loadProc("glVertexAttribI4ubv");
	api->VertexAttrib2s = loadProc("glVertexAttrib2s");
	api->GetBooleanv = loadProc("glGetBooleanv");
	api->VertexAttrib4iv = loadProc("glVertexAttrib4iv");
	api->GetObjectPtrLabel = mg_glGetObjectPtrLabel_noimpl;
	api->UniformMatrix2x4dv = loadProc("glUniformMatrix2x4dv");
	api->ProgramUniform4ui = loadProc("glProgramUniform4ui");
	api->GetVertexAttribdv = loadProc("glGetVertexAttribdv");
	api->ViewportIndexedf = loadProc("glViewportIndexedf");
	api->DeleteSync = loadProc("glDeleteSync");
	api->CopyImageSubData = mg_glCopyImageSubData_noimpl;
	api->PrimitiveBoundingBox = mg_glPrimitiveBoundingBox_noimpl;
	api->ScissorIndexed = loadProc("glScissorIndexed");
	api->GenTransformFeedbacks = loadProc("glGenTransformFeedbacks");
	api->MemoryBarrierByRegion = mg_glMemoryBarrierByRegion_noimpl;
	api->DeleteTransformFeedbacks = loadProc("glDeleteTransformFeedbacks");
	api->ProgramUniform4f = loadProc("glProgramUniform4f");
	api->BindBuffersBase = mg_glBindBuffersBase_noimpl;
	api->GetTexParameterIuiv = loadProc("glGetTexParameterIuiv");
	api->IsShader = loadProc("glIsShader");
	api->ProgramUniform3i = loadProc("glProgramUniform3i");
	api->GetActiveAtomicCounterBufferiv = mg_glGetActiveAtomicCounterBufferiv_noimpl;
	api->ProgramUniformMatrix3x4fv = loadProc("glProgramUniformMatrix3x4fv");
	api->BufferStorage = mg_glBufferStorage_noimpl;
	api->GetUniformSubroutineuiv = loadProc("glGetUniformSubroutineuiv");
	api->RenderbufferStorageMultisample = loadProc("glRenderbufferStorageMultisample");
	api->GetMultisamplefv = loadProc("glGetMultisamplefv");
	api->VertexAttribDivisor = loadProc("glVertexAttribDivisor");
	api->StencilMask = loadProc("glStencilMask");
	api->BindSampler = loadProc("glBindSampler");
	api->UniformMatrix4dv = loadProc("glUniformMatrix4dv");
	api->BindImageTexture = mg_glBindImageTexture_noimpl;
	api->DrawBuffers = loadProc("glDrawBuffers");
	api->VertexAttrib4Nub = loadProc("glVertexAttrib4Nub");
	api->GetTexImage = loadProc("glGetTexImage");
	api->VertexAttrib3dv = loadProc("glVertexAttrib3dv");
	api->BlitFramebuffer = loadProc("glBlitFramebuffer");
	api->VertexAttrib2d = loadProc("glVertexAttrib2d");
	api->Uniform1ui = loadProc("glUniform1ui");
	api->InvalidateBufferSubData = mg_glInvalidateBufferSubData_noimpl;
	api->EndQuery = loadProc("glEndQuery");
	api->GetUniformuiv = loadProc("glGetUniformuiv");
	api->GetFramebufferAttachmentParameteriv = loadProc("glGetFramebufferAttachmentParameteriv");
	api->ProgramUniform2f = loadProc("glProgramUniform2f");
	api->UniformMatrix3x2fv = loadProc("glUniformMatrix3x2fv");
	api->BindVertexBuffer = mg_glBindVertexBuffer_noimpl;
	api->VertexAttrib2sv = loadProc("glVertexAttrib2sv");
	api->Uniform1f = loadProc("glUniform1f");
	api->DebugMessageCallback = mg_glDebugMessageCallback_noimpl;
	api->ReadPixels = loadProc("glReadPixels");
	api->CompressedTexSubImage1D = loadProc("glCompressedTexSubImage1D");
	api->DrawArraysIndirect = loadProc("glDrawArraysIndirect");
	api->BlendFuncSeparate = loadProc("glBlendFuncSeparate");
	api->CreateShader = loadProc("glCreateShader");
	api->GetTransformFeedbackVarying = loadProc("glGetTransformFeedbackVarying");
	api->AttachShader = loadProc("glAttachShader");
	api->UniformMatrix2x3dv = loadProc("glUniformMatrix2x3dv");
	api->ProgramUniform3uiv = loadProc("glProgramUniform3uiv");
	api->MultiDrawArraysIndirect = mg_glMultiDrawArraysIndirect_noimpl;
	api->Uniform2iv = loadProc("glUniform2iv");
	api->BindBufferRange = loadProc("glBindBufferRange");
	api->TexParameteriv = loadProc("glTexParameteriv");
	api->VertexAttribL3d = loadProc("glVertexAttribL3d");
	api->TexImage3DMultisample = loadProc("glTexImage3DMultisample");
	api->ClearTexSubImage = mg_glClearTexSubImage_noimpl;
	api->VertexAttrib4Nusv = loadProc("glVertexAttrib4Nusv");
	api->InvalidateSubFramebuffer = mg_glInvalidateSubFramebuffer_noimpl;
	api->GetShaderInfoLog = loadProc("glGetShaderInfoLog");
	api->VertexAttribP4ui = loadProc("glVertexAttribP4ui");
	api->Viewport = loadProc("glViewport");
	api->BlendFunci = loadProc("glBlendFunci");
	api->PolygonOffset = loadProc("glPolygonOffset");
	api->ProgramUniform2ui = loadProc("glProgramUniform2ui");
	api->SamplerParameteri = loadProc("glSamplerParameteri");
	api->GetFramebufferParameteriv = mg_glGetFramebufferParameteriv_noimpl;
	api->VertexAttribI2iv = loadProc("glVertexAttribI2iv");
	api->ObjectLabel = mg_glObjectLabel_noimpl;
	api->CompressedTexImage1D = loadProc("glCompressedTexImage1D");
	api->InvalidateTexSubImage = mg_glInvalidateTexSubImage_noimpl;
	api->BindBuffersRange = mg_glBindBuffersRange_noimpl;
	api->CopyBufferSubData = loadProc("glCopyBufferSubData");
	api->VertexAttrib4Nbv = loadProc("glVertexAttrib4Nbv");
	api->ObjectPtrLabel = mg_glObjectPtrLabel_noimpl;
	api->ProgramUniform3d = loadProc("glProgramUniform3d");
	api->GetProgramPipelineiv = loadProc("glGetProgramPipelineiv");
	api->TexStorage3DMultisample = mg_glTexStorage3DMultisample_noimpl;
	api->VertexAttribL3dv = loadProc("glVertexAttribL3dv");
	api->DeleteFramebuffers = loadProc("glDeleteFramebuffers");
	api->CheckFramebufferStatus = loadProc("glCheckFramebufferStatus");
	api->VertexAttribL2dv = loadProc("glVertexAttribL2dv");
	api->ProgramUniform1dv = loadProc("glProgramUniform1dv");
	api->VertexAttrib2f = loadProc("glVertexAttrib2f");
	api->GetVertexAttribIuiv = loadProc("glGetVertexAttribIuiv");
	api->StencilOp = loadProc("glStencilOp");
	api->VertexAttrib3d = loadProc("glVertexAttrib3d");
	api->PointParameteri = loadProc("glPointParameteri");
	api->VertexAttribI1uiv = loadProc("glVertexAttribI1uiv");
	api->ClearBufferfv = loadProc("glClearBufferfv");
	api->BindFragDataLocationIndexed = loadProc("glBindFragDataLocationIndexed");
	api->ProgramUniform1d = loadProc("glProgramUniform1d");
	api->PointParameteriv = loadProc("glPointParameteriv");
	api->FlushMappedBufferRange = loadProc("glFlushMappedBufferRange");
	api->TextureView = mg_glTextureView_noimpl;
	api->GetProgramPipelineInfoLog = loadProc("glGetProgramPipelineInfoLog");
	api->CopyTexImage2D = loadProc("glCopyTexImage2D");
	api->ProgramUniform3dv = loadProc("glProgramUniform3dv");
	api->QueryCounter = loadProc("glQueryCounter");
	api->GetUniformfv = loadProc("glGetUniformfv");
	api->ClearStencil = loadProc("glClearStencil");
	api->GetProgramiv = loadProc("glGetProgramiv");
	api->UniformSubroutinesuiv = loadProc("glUniformSubroutinesuiv");
	api->GetProgramStageiv = loadProc("glGetProgramStageiv");
	api->Uniform1iv = loadProc("glUniform1iv");
	api->GetVertexAttribPointerv = loadProc("glGetVertexAttribPointerv");
	api->TexSubImage1D = loadProc("glTexSubImage1D");
	api->StencilFuncSeparate = loadProc("glStencilFuncSeparate");
	api->GetSubroutineIndex = loadProc("glGetSubroutineIndex");
	api->DrawElementsInstanced = loadProc("glDrawElementsInstanced");
	api->BlendFuncSeparatei = loadProc("glBlendFuncSeparatei");
	api->ProgramUniformMatrix3x2dv = loadProc("glProgramUniformMatrix3x2dv");
	api->GetActiveUniformsiv = loadProc("glGetActiveUniformsiv");
	api->UniformMatrix3fv = loadProc("glUniformMatrix3fv");
	api->ProgramUniformMatrix3x4dv = loadProc("glProgramUniformMatrix3x4dv");
	api->GetSamplerParameterIuiv = loadProc("glGetSamplerParameterIuiv");
	api->VertexAttribI4i = loadProc("glVertexAttribI4i");
	api->BlendEquationSeparate = loadProc("glBlendEquationSeparate");
	api->UniformMatrix4x2fv = loadProc("glUniformMatrix4x2fv");
	api->TexParameterIiv = loadProc("glTexParameterIiv");
	api->DrawTransformFeedbackStream = loadProc("glDrawTransformFeedbackStream");
	api->VertexAttribI1iv = loadProc("glVertexAttribI1iv");
	api->GetUniformIndices = loadProc("glGetUniformIndices");
	api->GetShaderiv = loadProc("glGetShaderiv");
	api->GetActiveUniform = loadProc("glGetActiveUniform");
	api->Uniform3uiv = loadProc("glUniform3uiv");
	api->PatchParameteri = loadProc("glPatchParameteri");
	api->ProgramUniformMatrix2dv = loadProc("glProgramUniformMatrix2dv");
	api->WaitSync = loadProc("glWaitSync");
	api->ClearTexImage = mg_glClearTexImage_noimpl;
	api->DepthRangeIndexed = loadProc("glDepthRangeIndexed");
	api->GetTexParameterIiv = loadProc("glGetTexParameterIiv");
	api->DepthRange = loadProc("glDepthRange");
	api->GetActiveAttrib = loadProc("glGetActiveAttrib");
	api->IsRenderbuffer = loadProc("glIsRenderbuffer");
	api->ClearBufferiv = loadProc("glClearBufferiv");
	api->ProgramUniform3fv = loadProc("glProgramUniform3fv");
	api->VertexAttribI3uiv = loadProc("glVertexAttribI3uiv");
	api->UseProgram = loadProc("glUseProgram");
	api->GetActiveSubroutineName = loadProc("glGetActiveSubroutineName");
	api->ProgramUniformMatrix3fv = loadProc("glProgramUniformMatrix3fv");
	api->ProgramUniformMatrix4x3dv = loadProc("glProgramUniformMatrix4x3dv");
	api->UniformMatrix4x3dv = loadProc("glUniformMatrix4x3dv");
	api->ProgramUniform4dv = loadProc("glProgramUniform4dv");
	api->GetBufferSubData = loadProc("glGetBufferSubData");
	api->VertexAttrib4uiv = loadProc("glVertexAttrib4uiv");
	api->VertexAttrib1f = loadProc("glVertexAttrib1f");
	api->VertexAttrib4usv = loadProc("glVertexAttrib4usv");
	api->DebugMessageInsert = mg_glDebugMessageInsert_noimpl;
	api->EndTransformFeedback = loadProc("glEndTransformFeedback");
	api->TexImage2DMultisample = loadProc("glTexImage2DMultisample");
	api->BindTransformFeedback = loadProc("glBindTransformFeedback");
	api->Uniform3dv = loadProc("glUniform3dv");
	api->UniformMatrix3x2dv = loadProc("glUniformMatrix3x2dv");
	api->GetSamplerParameteriv = loadProc("glGetSamplerParameteriv");
	api->VertexAttribP3uiv = loadProc("glVertexAttribP3uiv");
	api->Uniform4d = loadProc("glUniform4d");
	api->ProgramUniformMatrix3dv = loadProc("glProgramUniformMatrix3dv");
	api->ProgramUniform3ui = loadProc("glProgramUniform3ui");
	api->DeleteVertexArrays = loadProc("glDeleteVertexArrays");
	api->TexParameteri = loadProc("glTexParameteri");
	api->DrawElementsInstancedBaseVertex = loadProc("glDrawElementsInstancedBaseVertex");
	api->GetQueryObjectui64v = loadProc("glGetQueryObjectui64v");
	api->VertexAttrib4Niv = loadProc("glVertexAttrib4Niv");
	api->SamplerParameterfv = loadProc("glSamplerParameterfv");
	api->VertexAttribI4bv = loadProc("glVertexAttribI4bv");
	api->ProgramUniform1i = loadProc("glProgramUniform1i");
	api->ProgramUniformMatrix4x2dv = loadProc("glProgramUniformMatrix4x2dv");
	api->GetSynciv = loadProc("glGetSynciv");
	api->VertexAttrib3f = loadProc("glVertexAttrib3f");
	api->GetQueryObjectiv = loadProc("glGetQueryObjectiv");
	api->GetProgramInfoLog = loadProc("glGetProgramInfoLog");
	api->GetActiveUniformBlockiv = loadProc("glGetActiveUniformBlockiv");
	api->GenQueries = loadProc("glGenQueries");
	api->ProgramUniformMatrix4x3fv = loadProc("glProgramUniformMatrix4x3fv");
	api->TexBuffer = loadProc("glTexBuffer");
	api->ShaderStorageBlockBinding = mg_glShaderStorageBlockBinding_noimpl;
	api->Disable = loadProc("glDisable");
	api->VertexAttribI3ui = loadProc("glVertexAttribI3ui");
	api->IsSampler = loadProc("glIsSampler");
	api->ActiveShaderProgram = loadProc("glActiveShaderProgram");
	api->BindVertexArray = loadProc("glBindVertexArray");
	api->UniformMatrix2x3fv = loadProc("glUniformMatrix2x3fv");
	api->DrawArraysInstanced = loadProc("glDrawArraysInstanced");
	api->VertexAttribI2uiv = loadProc("glVertexAttribI2uiv");
	api->GetQueryObjecti64v = loadProc("glGetQueryObjecti64v");
	api->GetStringi = loadProc("glGetStringi");
	api->BindProgramPipeline = loadProc("glBindProgramPipeline");
	api->BindFramebuffer = loadProc("glBindFramebuffer");
	api->VertexAttrib1d = loadProc("glVertexAttrib1d");
	api->RenderbufferStorage = loadProc("glRenderbufferStorage");
	api->ReleaseShaderCompiler = loadProc("glReleaseShaderCompiler");
	api->Uniform2i = loadProc("glUniform2i");
	api->DrawBuffer = loadProc("glDrawBuffer");
	api->DeleteRenderbuffers = loadProc("glDeleteRenderbuffers");
	api->DeleteBuffers = loadProc("glDeleteBuffers");
	api->GenFramebuffers = loadProc("glGenFramebuffers");
	api->ProgramUniformMatrix4dv = loadProc("glProgramUniformMatrix4dv");
	api->ProgramUniform3f = loadProc("glProgramUniform3f");
	api->ProgramUniform2iv = loadProc("glProgramUniform2iv");
	api->BlendBarrier = mg_glBlendBarrier_noimpl;
	api->VertexAttribL2d = loadProc("glVertexAttribL2d");
	api->CompressedTexSubImage2D = loadProc("glCompressedTexSubImage2D");
	api->UniformMatrix2fv = loadProc("glUniformMatrix2fv");
	api->SamplerParameterf = loadProc("glSamplerParameterf");
	api->UniformMatrix4fv = loadProc("glUniformMatrix4fv");
	api->VertexAttribI2ui = loadProc("glVertexAttribI2ui");
	api->BindTextures = mg_glBindTextures_noimpl;
	api->Uniform3d = loadProc("glUniform3d");
	api->ViewportIndexedfv = loadProc("glViewportIndexedfv");
	api->VertexAttribI4sv = loadProc("glVertexAttribI4sv");
	api->LineWidth = loadProc("glLineWidth");
	api->GetVertexAttribfv = loadProc("glGetVertexAttribfv");
	api->VertexAttribI3iv = loadProc("glVertexAttribI3iv");
	api->Uniform1dv = loadProc("glUniform1dv");
	api->CullFace = loadProc("glCullFace");
	api->CreateProgram = loadProc("glCreateProgram");
	api->Uniform4i = loadProc("glUniform4i");
	api->UniformMatrix4x3fv = loadProc("glUniformMatrix4x3fv");
	api->GetAttribLocation = loadProc("glGetAttribLocation");
	api->GetShaderPrecisionFormat = loadProc("glGetShaderPrecisionFormat");
	api->Uniform4iv = loadProc("glUniform4iv");
	api->CompressedTexSubImage3D = loadProc("glCompressedTexSubImage3D");
	api->BindImageTextures = mg_glBindImageTextures_noimpl;
	api->GetBufferParameteri64v = loadProc("glGetBufferParameteri64v");
	api->FrontFace = loadProc("glFrontFace");
	api->PopDebugGroup = mg_glPopDebugGroup_noimpl;
	api->VertexAttrib1sv = loadProc("glVertexAttrib1sv");
	api->InvalidateBufferData = mg_glInvalidateBufferData_noimpl;
	api->IsVertexArray = loadProc("glIsVertexArray");
	api->ScissorArrayv = loadProc("glScissorArrayv");
	api->ValidateProgram = loadProc("glValidateProgram");
	api->Uniform2uiv = loadProc("glUniform2uiv");
	api->TexSubImage2D = loadProc("glTexSubImage2D");
	api->DebugMessageControl = mg_glDebugMessageControl_noimpl;
	api->FramebufferParameteri = mg_glFramebufferParameteri_noimpl;
	api->GetUniformLocation = loadProc("glGetUniformLocation");
	api->TexStorage3D = mg_glTexStorage3D_noimpl;
	api->PixelStoref = loadProc("glPixelStoref");
	api->DepthRangef = loadProc("glDepthRangef");
	api->VertexAttribI3i = loadProc("glVertexAttribI3i");
	api->Uniform1uiv = loadProc("glUniform1uiv");
	api->Disablei = loadProc("glDisablei");
	api->GetInternalformati64v = mg_glGetInternalformati64v_noimpl;
	api->ProgramUniformMatrix2x3dv = loadProc("glProgramUniformMatrix2x3dv");
	api->GetProgramResourceIndex = mg_glGetProgramResourceIndex_noimpl;
	api->BlendColor = loadProc("glBlendColor");
	api->GenSamplers = loadProc("glGenSamplers");
	api->ColorMaski = loadProc("glColorMaski");
	api->GetGraphicsResetStatus = mg_glGetGraphicsResetStatus_noimpl;
	api->VertexAttribI4uiv = loadProc("glVertexAttribI4uiv");
	api->CreateShaderProgramv = loadProc("glCreateShaderProgramv");
	api->DeleteSamplers = loadProc("glDeleteSamplers");
	api->VertexAttrib3s = loadProc("glVertexAttrib3s");
	api->DrawTransformFeedback = loadProc("glDrawTransformFeedback");
	api->VertexAttribL1d = loadProc("glVertexAttribL1d");
	api->DrawElementsInstancedBaseVertexBaseInstance = mg_glDrawElementsInstancedBaseVertexBaseInstance_noimpl;
	api->ClearBufferSubData = mg_glClearBufferSubData_noimpl;
	api->VertexAttribLFormat = mg_glVertexAttribLFormat_noimpl;
	api->Uniform2dv = loadProc("glUniform2dv");
	api->CopyTexSubImage3D = loadProc("glCopyTexSubImage3D");
	api->CopyTexImage1D = loadProc("glCopyTexImage1D");
	api->FramebufferTexture3D = loadProc("glFramebufferTexture3D");
	api->VertexAttribL4d = loadProc("glVertexAttribL4d");
	api->UnmapBuffer = loadProc("glUnmapBuffer");
	api->GetQueryIndexediv = loadProc("glGetQueryIndexediv");
	api->FenceSync = loadProc("glFenceSync");
	api->DispatchComputeIndirect = mg_glDispatchComputeIndirect_noimpl;
	api->SamplerParameterIuiv = loadProc("glSamplerParameterIuiv");
	api->GetFragDataLocation = loadProc("glGetFragDataLocation");
	api->GetUniformdv = loadProc("glGetUniformdv");
	api->TexImage3D = loadProc("glTexImage3D");
	api->ValidateProgramPipeline = loadProc("glValidateProgramPipeline");
	api->LinkProgram = loadProc("glLinkProgram");
	api->DeleteQueries = loadProc("glDeleteQueries");
	api->FramebufferTexture1D = loadProc("glFramebufferTexture1D");
	api->GetActiveSubroutineUniformName = loadProc("glGetActiveSubroutineUniformName");
	api->ProgramUniformMatrix3x2fv = loadProc("glProgramUniformMatrix3x2fv");
	api->GetTexParameteriv = loadProc("glGetTexParameteriv");
	api->ProvokingVertex = loadProc("glProvokingVertex");
	api->BindAttribLocation = loadProc("glBindAttribLocation");
	api->VertexAttrib3fv = loadProc("glVertexAttrib3fv");
	api->GetActiveUniformBlockName = loadProc("glGetActiveUniformBlockName");
	api->DrawArrays = loadProc("glDrawArrays");
	api->GetnUniformuiv = mg_glGetnUniformuiv_noimpl;
	api->ProgramUniform1uiv = loadProc("glProgramUniform1uiv");
	api->DrawElementsIndirect = loadProc("glDrawElementsIndirect");
	api->VertexAttribI4usv = loadProc("glVertexAttribI4usv");
	api->BlendEquationSeparatei = loadProc("glBlendEquationSeparatei");
	api->DrawElements = loadProc("glDrawElements");
	api->GetShaderSource = loadProc("glGetShaderSource");
	api->TransformFeedbackVaryings = loadProc("glTransformFeedbackVaryings");
	api->GetError = loadProc("glGetError");
	api->IsBuffer = loadProc("glIsBuffer");
	api->ClearBufferuiv = loadProc("glClearBufferuiv");
	api->GetVertexAttribiv = loadProc("glGetVertexAttribiv");
	api->GetProgramResourceName = mg_glGetProgramResourceName_noimpl;
	api->Uniform2ui = loadProc("glUniform2ui");
	api->StencilFunc = loadProc("glStencilFunc");
	api->Enablei = loadProc("glEnablei");
	api->SamplerParameteriv = loadProc("glSamplerParameteriv");
	api->GetInteger64i_v = loadProc("glGetInteger64i_v");
	api->ProgramUniform4i = loadProc("glProgramUniform4i");
	api->Uniform4ui = loadProc("glUniform4ui");
	api->UniformMatrix2x4fv = loadProc("glUniformMatrix2x4fv");
	api->ReadnPixels = mg_glReadnPixels_noimpl;
	api->DrawTransformFeedbackInstanced = mg_glDrawTransformFeedbackInstanced_noimpl;
	api->PointSize = loadProc("glPointSize");
	api->ProgramUniformMatrix4fv = loadProc("glProgramUniformMatrix4fv");
	api->ViewportArrayv = loadProc("glViewportArrayv");
	api->StencilOpSeparate = loadProc("glStencilOpSeparate");
	api->Uniform3ui = loadProc("glUniform3ui");
	api->Uniform4uiv = loadProc("glUniform4uiv");
	api->Uniform3iv = loadProc("glUniform3iv");
	api->Uniform4f = loadProc("glUniform4f");
	api->FramebufferTexture2D = loadProc("glFramebufferTexture2D");
	api->GetIntegeri_v = loadProc("glGetIntegeri_v");
	api->MultiDrawElements = loadProc("glMultiDrawElements");
	api->UniformMatrix4x2dv = loadProc("glUniformMatrix4x2dv");
	api->ProgramUniformMatrix2x3fv = loadProc("glProgramUniformMatrix2x3fv");
	api->CopyTexSubImage1D = loadProc("glCopyTexSubImage1D");
	api->TexSubImage3D = loadProc("glTexSubImage3D");
	api->GetActiveSubroutineUniformiv = loadProc("glGetActiveSubroutineUniformiv");
	api->GenProgramPipelines = loadProc("glGenProgramPipelines");
	api->ProgramUniform4iv = loadProc("glProgramUniform4iv");
	api->UniformMatrix3x4fv = loadProc("glUniformMatrix3x4fv");
	api->UniformBlockBinding = loadProc("glUniformBlockBinding");
	api->DepthRangeArrayv = loadProc("glDepthRangeArrayv");
	api->TexParameterfv = loadProc("glTexParameterfv");
	api->MapBuffer = loadProc("glMapBuffer");
	api->DeleteProgramPipelines = loadProc("glDeleteProgramPipelines");
	api->MinSampleShading = loadProc("glMinSampleShading");
	api->PauseTransformFeedback = loadProc("glPauseTransformFeedback");
	api->EndQueryIndexed = loadProc("glEndQueryIndexed");
	api->GetProgramBinary = loadProc("glGetProgramBinary");
	api->ProgramUniform2i = loadProc("glProgramUniform2i");
	api->DepthMask = loadProc("glDepthMask");
	api->ActiveTexture = loadProc("glActiveTexture");
	api->UseProgramStages = loadProc("glUseProgramStages");
	api->PatchParameterfv = loadProc("glPatchParameterfv");
	api->ShaderBinary = loadProc("glShaderBinary");
	api->GetFloatv = loadProc("glGetFloatv");
	api->ProgramUniform1f = loadProc("glProgramUniform1f");
	api->TexImage1D = loadProc("glTexImage1D");
	api->ProgramUniform2uiv = loadProc("glProgramUniform2uiv");
	api->ClearBufferData = mg_glClearBufferData_noimpl;
	api->UniformMatrix3dv = loadProc("glUniformMatrix3dv");
	api->CompressedTexImage2D = loadProc("glCompressedTexImage2D");
	api->VertexAttrib4fv = loadProc("glVertexAttrib4fv");
	api->GetProgramResourceiv = mg_glGetProgramResourceiv_noimpl;
	api->GetString = loadProc("glGetString");
	api->ProgramUniformMatrix2fv = loadProc("glProgramUniformMatrix2fv");
	api->GetVertexAttribLdv = loadProc("glGetVertexAttribLdv");
	api->VertexAttrib4Nubv = loadProc("glVertexAttrib4Nubv");
	api->TexBufferRange = mg_glTexBufferRange_noimpl;
	api->UniformMatrix3x4dv = loadProc("glUniformMatrix3x4dv");
	api->GetProgramInterfaceiv = mg_glGetProgramInterfaceiv_noimpl;
	api->TexParameterIuiv = loadProc("glTexParameterIuiv");
	api->DeleteShader = loadProc("glDeleteShader");
	api->GetFloati_v = loadProc("glGetFloati_v");
	api->DrawTransformFeedbackStreamInstanced = mg_glDrawTransformFeedbackStreamInstanced_noimpl;
	api->VertexAttrib4s = loadProc("glVertexAttrib4s");
}

void mg_gl_load_gl43(mg_gl_api* api, mg_gl_load_proc loadProc)
{
	api->name = "gl43";
	api->PointParameterfv = loadProc("glPointParameterfv");
	api->Uniform3fv = loadProc("glUniform3fv");
	api->Uniform1i = loadProc("glUniform1i");
	api->VertexAttribP3ui = loadProc("glVertexAttribP3ui");
	api->VertexAttrib4sv = loadProc("glVertexAttrib4sv");
	api->GetBufferParameteriv = loadProc("glGetBufferParameteriv");
	api->ProgramUniform2dv = loadProc("glProgramUniform2dv");
	api->ClampColor = loadProc("glClampColor");
	api->CompressedTexImage3D = loadProc("glCompressedTexImage3D");
	api->ProgramUniformMatrix2x4fv = loadProc("glProgramUniformMatrix2x4fv");
	api->ProgramUniform2d = loadProc("glProgramUniform2d");
	api->BindBuffer = loadProc("glBindBuffer");
	api->GetUniformBlockIndex = loadProc("glGetUniformBlockIndex");
	api->InvalidateFramebuffer = loadProc("glInvalidateFramebuffer");
	api->PixelStorei = loadProc("glPixelStorei");
	api->BindTexture = loadProc("glBindTexture");
	api->VertexAttrib4Nuiv = loadProc("glVertexAttrib4Nuiv");
	api->IsTexture = loadProc("glIsTexture");
	api->VertexAttrib4d = loadProc("glVertexAttrib4d");
	api->ProgramUniformMatrix2x4dv = loadProc("glProgramUniformMatrix2x4dv");
	api->GetObjectLabel = loadProc("glGetObjectLabel");
	api->BeginConditionalRender = loadProc("glBeginConditionalRender");
	api->IsFramebuffer = loadProc("glIsFramebuffer");
	api->CompileShader = loadProc("glCompileShader");
	api->VertexAttribBinding = loadProc("glVertexAttribBinding");
	api->VertexAttribL1dv = loadProc("glVertexAttribL1dv");
	api->Uniform1fv = loadProc("glUniform1fv");
	api->TexImage2D = loadProc("glTexImage2D");
	api->Flush = loadProc("glFlush");
	api->VertexAttribP2uiv = loadProc("glVertexAttribP2uiv");
	api->IsProgram = loadProc("glIsProgram");
	api->ProgramUniform4fv = loadProc("glProgramUniform4fv");
	api->VertexAttribLPointer = loadProc("glVertexAttribLPointer");
	api->ClientWaitSync = loadProc("glClientWaitSync");
	api->Uniform1d = loadProc("glUniform1d");
	api->ProgramUniform1ui = loadProc("glProgramUniform1ui");
	api->ColorMask = loadProc("glColorMask");
	api->ClearDepth = loadProc("glClearDepth");
	api->GetInteger64v = loadProc("glGetInteger64v");
	api->VertexAttribP2ui = loadProc("glVertexAttribP2ui");
	api->VertexAttrib2dv = loadProc("glVertexAttrib2dv");
	api->VertexAttribI4ui = loadProc("glVertexAttribI4ui");
	api->BlendEquationi = loadProc("glBlendEquationi");
	api->DrawRangeElements = loadProc("glDrawRangeElements");
	api->InvalidateTexImage = loadProc("glInvalidateTexImage");
	api->SampleMaski = loadProc("glSampleMaski");
	api->GetProgramResourceLocationIndex = loadProc("glGetProgramResourceLocationIndex");
	api->VertexAttrib4dv = loadProc("glVertexAttrib4dv");
	api->BindFragDataLocation = loadProc("glBindFragDataLocation");
	api->GetFragDataIndex = loadProc("glGetFragDataIndex");
	api->GetTexLevelParameterfv = loadProc("glGetTexLevelParameterfv");
	api->VertexAttribP4uiv = loadProc("glVertexAttribP4uiv");
	api->MultiDrawArrays = loadProc("glMultiDrawArrays");
	api->IsTransformFeedback = loadProc("glIsTransformFeedback");
	api->GetUniformiv = loadProc("glGetUniformiv");
	api->BufferData = loadProc("glBufferData");
	api->GetCompressedTexImage = loadProc("glGetCompressedTexImage");
	api->VertexAttrib3sv = loadProc("glVertexAttrib3sv");
	api->IsQuery = loadProc("glIsQuery");
	api->ClearColor = loadProc("glClearColor");
	api->BlendFunc = loadProc("glBlendFunc");
	api->GetDoublei_v = loadProc("glGetDoublei_v");
	api->FramebufferTexture = loadProc("glFramebufferTexture");
	api->StencilMaskSeparate = loadProc("glStencilMaskSeparate");
	api->PrimitiveRestartIndex = loadProc("glPrimitiveRestartIndex");
	api->VertexAttribP1ui = loadProc("glVertexAttribP1ui");
	api->VertexAttribIFormat = loadProc("glVertexAttribIFormat");
	api->MemoryBarrier = loadProc("glMemoryBarrier");
	api->GetSubroutineUniformLocation = loadProc("glGetSubroutineUniformLocation");
	api->BindRenderbuffer = loadProc("glBindRenderbuffer");
	api->PushDebugGroup = loadProc("glPushDebugGroup");
	api->GenTextures = loadProc("glGenTextures");
	api->GetIntegerv = loadProc("glGetIntegerv");
	api->GetQueryObjectuiv = loadProc("glGetQueryObjectuiv");
	api->Uniform4fv = loadProc("glUniform4fv");
	api->Hint = loadProc("glHint");
	api->TexParameterf = loadProc("glTexParameterf");
	api->ProgramUniform2fv = loadProc("glProgramUniform2fv");
	api->DrawRangeElementsBaseVertex = loadProc("glDrawRangeElementsBaseVertex");
	api->Clear = loadProc("glClear");
	api->BindBufferBase = loadProc("glBindBufferBase");
	api->GetQueryiv = loadProc("glGetQueryiv");
	api->ProgramBinary = loadProc("glProgramBinary");
	api->ScissorIndexedv = loadProc("glScissorIndexedv");
	api->VertexAttrib1fv = loadProc("glVertexAttrib1fv");
	api->TexStorage2D = loadProc("glTexStorage2D");
	api->VertexAttrib4f = loadProc("glVertexAttrib4f");
	api->ProgramParameteri = loadProc("glProgramParameteri");
	api->Enable = loadProc("glEnable");
	api->GetBufferPointerv = loadProc("glGetBufferPointerv");
	api->LogicOp = loadProc("glLogicOp");
	api->DepthFunc = loadProc("glDepthFunc");
	api->VertexAttrib1dv = loadProc("glVertexAttrib1dv");
	api->Uniform2d = loadProc("glUniform2d");
	api->DetachShader = loadProc("glDetachShader");
	api->VertexBindingDivisor = loadProc("glVertexBindingDivisor");
	api->IsProgramPipeline = loadProc("glIsProgramPipeline");
	api->ProgramUniform1fv = loadProc("glProgramUniform1fv");
	api->CopyTexSubImage2D = loadProc("glCopyTexSubImage2D");
	api->VertexAttrib2fv = loadProc("glVertexAttrib2fv");
	api->GetDoublev = loadProc("glGetDoublev");
	api->ResumeTransformFeedback = loadProc("glResumeTransformFeedback");
	api->ProgramUniform4d = loadProc("glProgramUniform4d");
	api->ProgramUniform4uiv = loadProc("glProgramUniform4uiv");
	api->DispatchCompute = loadProc("glDispatchCompute");
	api->VertexAttrib4bv = loadProc("glVertexAttrib4bv");
	api->GetSamplerParameterfv = loadProc("glGetSamplerParameterfv");
	api->ProgramUniform3iv = loadProc("glProgramUniform3iv");
	api->VertexAttrib1s = loadProc("glVertexAttrib1s");
	api->VertexAttribI2i = loadProc("glVertexAttribI2i");
	api->SampleCoverage = loadProc("glSampleCoverage");
	api->BufferSubData = loadProc("glBufferSubData");
	api->VertexAttribI1ui = loadProc("glVertexAttribI1ui");
	api->EndConditionalRender = loadProc("glEndConditionalRender");
	api->GetPointerv = loadProc("glGetPointerv");
	api->GetnUniformiv = mg_glGetnUniformiv_noimpl;
	api->BlendEquation = loadProc("glBlendEquation");
	api->VertexAttribI4iv = loadProc("glVertexAttribI4iv");
	api->GetnUniformfv = mg_glGetnUniformfv_noimpl;
	api->VertexAttrib4Nsv = loadProc("glVertexAttrib4Nsv");
	api->Uniform2fv = loadProc("glUniform2fv");
	api->Uniform3f = loadProc("glUniform3f");
	api->GenerateMipmap = loadProc("glGenerateMipmap");
	api->GenRenderbuffers = loadProc("glGenRenderbuffers");
	api->DrawElementsBaseVertex = loadProc("glDrawElementsBaseVertex");
	api->BindVertexBuffers = mg_glBindVertexBuffers_noimpl;
	api->Scissor = loadProc("glScissor");
	api->MapBufferRange = loadProc("glMapBufferRange");
	api->ProgramUniformMatrix4x2fv = loadProc("glProgramUniformMatrix4x2fv");
	api->GetTexParameterfv = loadProc("glGetTexParameterfv");
	api->Uniform2f = loadProc("glUniform2f");
	api->VertexAttribFormat = loadProc("glVertexAttribFormat");
	api->UniformMatrix2dv = loadProc("glUniformMatrix2dv");
	api->IsEnabled = loadProc("glIsEnabled");
	api->ClearBufferfi = loadProc("glClearBufferfi");
	api->GetRenderbufferParameteriv = loadProc("glGetRenderbufferParameteriv");
	api->FramebufferTextureLayer = loadProc("glFramebufferTextureLayer");
	api->PointParameterf = loadProc("glPointParameterf");
	api->GenVertexArrays = loadProc("glGenVertexArrays");
	api->GetAttachedShaders = loadProc("glGetAttachedShaders");
	api->FramebufferRenderbuffer = loadProc("glFramebufferRenderbuffer");
	api->DeleteTextures = loadProc("glDeleteTextures");
	api->BeginQuery = loadProc("glBeginQuery");
	api->Uniform4dv = loadProc("glUniform4dv");
	api->VertexAttribIPointer = loadProc("glVertexAttribIPointer");
	api->GetSamplerParameterIiv = loadProc("glGetSamplerParameterIiv");
	api->BeginQueryIndexed = loadProc("glBeginQueryIndexed");
	api->BeginTransformFeedback = loadProc("glBeginTransformFeedback");
	api->Uniform3i = loadProc("glUniform3i");
	api->GetActiveUniformName = loadProc("glGetActiveUniformName");
	api->GetProgramResourceLocation = loadProc("glGetProgramResourceLocation");
	api->ShaderSource = loadProc("glShaderSource");
	api->SamplerParameterIiv = loadProc("glSamplerParameterIiv");
	api->Finish = loadProc("glFinish");
	api->DrawArraysInstancedBaseInstance = loadProc("glDrawArraysInstancedBaseInstance");
	api->DeleteProgram = loadProc("glDeleteProgram");
	api->MultiDrawElementsBaseVertex = loadProc("glMultiDrawElementsBaseVertex");
	api->ReadBuffer = loadProc("glReadBuffer");
	api->GenBuffers = loadProc("glGenBuffers");
	api->ClearDepthf = loadProc("glClearDepthf");
	api->VertexAttribPointer = loadProc("glVertexAttribPointer");
	api->VertexAttribL4dv = loadProc("glVertexAttribL4dv");
	api->TexStorage2DMultisample = loadProc("glTexStorage2DMultisample");
	api->BindSamplers = mg_glBindSamplers_noimpl;
	api->EnableVertexAttribArray = loadProc("glEnableVertexAttribArray");
	api->VertexAttrib4ubv = loadProc("glVertexAttrib4ubv");
	api->GetDebugMessageLog = loadProc("glGetDebugMessageLog");
	api->DisableVertexAttribArray = loadProc("glDisableVertexAttribArray");
	api->DrawElementsInstancedBaseInstance = loadProc("glDrawElementsInstancedBaseInstance");
	api->PolygonMode = loadProc("glPolygonMode");
	api->VertexAttribP1uiv = loadProc("glVertexAttribP1uiv");
	api->ProgramUniform1iv = loadProc("glProgramUniform1iv");
	api->VertexAttribI1i = loadProc("glVertexAttribI1i");
	api->GetTexLevelParameteriv = loadProc("glGetTexLevelParameteriv");
	api->IsSync = loadProc("glIsSync");
	api->TexStorage1D = loadProc("glTexStorage1D");
	api->GetVertexAttribIiv = loadProc("glGetVertexAttribIiv");
	api->IsEnabledi = loadProc("glIsEnabledi");
	api->MultiDrawElementsIndirect = loadProc("glMultiDrawElementsIndirect");
	api->GetBooleani_v = loadProc("glGetBooleani_v");
	api->GetInternalformativ = loadProc("glGetInternalformativ");
	api->VertexAttribI4ubv = loadProc("glVertexAttribI4ubv");
	api->VertexAttrib2s = loadProc("glVertexAttrib2s");
	api->GetBooleanv = loadProc("glGetBooleanv");
	api->VertexAttrib4iv = loadProc("glVertexAttrib4iv");
	api->GetObjectPtrLabel = loadProc("glGetObjectPtrLabel");
	api->UniformMatrix2x4dv = loadProc("glUniformMatrix2x4dv");
	api->ProgramUniform4ui = loadProc("glProgramUniform4ui");
	api->GetVertexAttribdv = loadProc("glGetVertexAttribdv");
	api->ViewportIndexedf = loadProc("glViewportIndexedf");
	api->DeleteSync = loadProc("glDeleteSync");
	api->CopyImageSubData = loadProc("glCopyImageSubData");
	api->PrimitiveBoundingBox = mg_glPrimitiveBoundingBox_noimpl;
	api->ScissorIndexed = loadProc("glScissorIndexed");
	api->GenTransformFeedbacks = loadProc("glGenTransformFeedbacks");
	api->MemoryBarrierByRegion = mg_glMemoryBarrierByRegion_noimpl;
	api->DeleteTransformFeedbacks = loadProc("glDeleteTransformFeedbacks");
	api->ProgramUniform4f = loadProc("glProgramUniform4f");
	api->BindBuffersBase = mg_glBindBuffersBase_noimpl;
	api->GetTexParameterIuiv = loadProc("glGetTexParameterIuiv");
	api->IsShader = loadProc("glIsShader");
	api->ProgramUniform3i = loadProc("glProgramUniform3i");
	api->GetActiveAtomicCounterBufferiv = loadProc("glGetActiveAtomicCounterBufferiv");
	api->ProgramUniformMatrix3x4fv = loadProc("glProgramUniformMatrix3x4fv");
	api->BufferStorage = mg_glBufferStorage_noimpl;
	api->GetUniformSubroutineuiv = loadProc("glGetUniformSubroutineuiv");
	api->RenderbufferStorageMultisample = loadProc("glRenderbufferStorageMultisample");
	api->GetMultisamplefv = loadProc("glGetMultisamplefv");
	api->VertexAttribDivisor = loadProc("glVertexAttribDivisor");
	api->StencilMask = loadProc("glStencilMask");
	api->BindSampler = loadProc("glBindSampler");
	api->UniformMatrix4dv = loadProc("glUniformMatrix4dv");
	api->BindImageTexture = loadProc("glBindImageTexture");
	api->DrawBuffers = loadProc("glDrawBuffers");
	api->VertexAttrib4Nub = loadProc("glVertexAttrib4Nub");
	api->GetTexImage = loadProc("glGetTexImage");
	api->VertexAttrib3dv = loadProc("glVertexAttrib3dv");
	api->BlitFramebuffer = loadProc("glBlitFramebuffer");
	api->VertexAttrib2d = loadProc("glVertexAttrib2d");
	api->Uniform1ui = loadProc("glUniform1ui");
	api->InvalidateBufferSubData = loadProc("glInvalidateBufferSubData");
	api->EndQuery = loadProc("glEndQuery");
	api->GetUniformuiv = loadProc("glGetUniformuiv");
	api->GetFramebufferAttachmentParameteriv = loadProc("glGetFramebufferAttachmentParameteriv");
	api->ProgramUniform2f = loadProc("glProgramUniform2f");
	api->UniformMatrix3x2fv = loadProc("glUniformMatrix3x2fv");
	api->BindVertexBuffer = loadProc("glBindVertexBuffer");
	api->VertexAttrib2sv = loadProc("glVertexAttrib2sv");
	api->Uniform1f = loadProc("glUniform1f");
	api->DebugMessageCallback = loadProc("glDebugMessageCallback");
	api->ReadPixels = loadProc("glReadPixels");
	api->CompressedTexSubImage1D = loadProc("glCompressedTexSubImage1D");
	api->DrawArraysIndirect = loadProc("glDrawArraysIndirect");
	api->BlendFuncSeparate = loadProc("glBlendFuncSeparate");
	api->CreateShader = loadProc("glCreateShader");
	api->GetTransformFeedbackVarying = loadProc("glGetTransformFeedbackVarying");
	api->AttachShader = loadProc("glAttachShader");
	api->UniformMatrix2x3dv = loadProc("glUniformMatrix2x3dv");
	api->ProgramUniform3uiv = loadProc("glProgramUniform3uiv");
	api->MultiDrawArraysIndirect = loadProc("glMultiDrawArraysIndirect");
	api->Uniform2iv = loadProc("glUniform2iv");
	api->BindBufferRange = loadProc("glBindBufferRange");
	api->TexParameteriv = loadProc("glTexParameteriv");
	api->VertexAttribL3d = loadProc("glVertexAttribL3d");
	api->TexImage3DMultisample = loadProc("glTexImage3DMultisample");
	api->ClearTexSubImage = mg_glClearTexSubImage_noimpl;
	api->VertexAttrib4Nusv = loadProc("glVertexAttrib4Nusv");
	api->InvalidateSubFramebuffer = loadProc("glInvalidateSubFramebuffer");
	api->GetShaderInfoLog = loadProc("glGetShaderInfoLog");
	api->VertexAttribP4ui = loadProc("glVertexAttribP4ui");
	api->Viewport = loadProc("glViewport");
	api->BlendFunci = loadProc("glBlendFunci");
	api->PolygonOffset = loadProc("glPolygonOffset");
	api->ProgramUniform2ui = loadProc("glProgramUniform2ui");
	api->SamplerParameteri = loadProc("glSamplerParameteri");
	api->GetFramebufferParameteriv = loadProc("glGetFramebufferParameteriv");
	api->VertexAttribI2iv = loadProc("glVertexAttribI2iv");
	api->ObjectLabel = loadProc("glObjectLabel");
	api->CompressedTexImage1D = loadProc("glCompressedTexImage1D");
	api->InvalidateTexSubImage = loadProc("glInvalidateTexSubImage");
	api->BindBuffersRange = mg_glBindBuffersRange_noimpl;
	api->CopyBufferSubData = loadProc("glCopyBufferSubData");
	api->VertexAttrib4Nbv = loadProc("glVertexAttrib4Nbv");
	api->ObjectPtrLabel = loadProc("glObjectPtrLabel");
	api->ProgramUniform3d = loadProc("glProgramUniform3d");
	api->GetProgramPipelineiv = loadProc("glGetProgramPipelineiv");
	api->TexStorage3DMultisample = loadProc("glTexStorage3DMultisample");
	api->VertexAttribL3dv = loadProc("glVertexAttribL3dv");
	api->DeleteFramebuffers = loadProc("glDeleteFramebuffers");
	api->CheckFramebufferStatus = loadProc("glCheckFramebufferStatus");
	api->VertexAttribL2dv = loadProc("glVertexAttribL2dv");
	api->ProgramUniform1dv = loadProc("glProgramUniform1dv");
	api->VertexAttrib2f = loadProc("glVertexAttrib2f");
	api->GetVertexAttribIuiv = loadProc("glGetVertexAttribIuiv");
	api->StencilOp = loadProc("glStencilOp");
	api->VertexAttrib3d = loadProc("glVertexAttrib3d");
	api->PointParameteri = loadProc("glPointParameteri");
	api->VertexAttribI1uiv = loadProc("glVertexAttribI1uiv");
	api->ClearBufferfv = loadProc("glClearBufferfv");
	api->BindFragDataLocationIndexed = loadProc("glBindFragDataLocationIndexed");
	api->ProgramUniform1d = loadProc("glProgramUniform1d");
	api->PointParameteriv = loadProc("glPointParameteriv");
	api->FlushMappedBufferRange = loadProc("glFlushMappedBufferRange");
	api->TextureView = loadProc("glTextureView");
	api->GetProgramPipelineInfoLog = loadProc("glGetProgramPipelineInfoLog");
	api->CopyTexImage2D = loadProc("glCopyTexImage2D");
	api->ProgramUniform3dv = loadProc("glProgramUniform3dv");
	api->QueryCounter = loadProc("glQueryCounter");
	api->GetUniformfv = loadProc("glGetUniformfv");
	api->ClearStencil = loadProc("glClearStencil");
	api->GetProgramiv = loadProc("glGetProgramiv");
	api->UniformSubroutinesuiv = loadProc("glUniformSubroutinesuiv");
	api->GetProgramStageiv = loadProc("glGetProgramStageiv");
	api->Uniform1iv = loadProc("glUniform1iv");
	api->GetVertexAttribPointerv = loadProc("glGetVertexAttribPointerv");
	api->TexSubImage1D = loadProc("glTexSubImage1D");
	api->StencilFuncSeparate = loadProc("glStencilFuncSeparate");
	api->GetSubroutineIndex = loadProc("glGetSubroutineIndex");
	api->DrawElementsInstanced = loadProc("glDrawElementsInstanced");
	api->BlendFuncSeparatei = loadProc("glBlendFuncSeparatei");
	api->ProgramUniformMatrix3x2dv = loadProc("glProgramUniformMatrix3x2dv");
	api->GetActiveUniformsiv = loadProc("glGetActiveUniformsiv");
	api->UniformMatrix3fv = loadProc("glUniformMatrix3fv");
	api->ProgramUniformMatrix3x4dv = loadProc("glProgramUniformMatrix3x4dv");
	api->GetSamplerParameterIuiv = loadProc("glGetSamplerParameterIuiv");
	api->VertexAttribI4i = loadProc("glVertexAttribI4i");
	api->BlendEquationSeparate = loadProc("glBlendEquationSeparate");
	api->UniformMatrix4x2fv = loadProc("glUniformMatrix4x2fv");
	api->TexParameterIiv = loadProc("glTexParameterIiv");
	api->DrawTransformFeedbackStream = loadProc("glDrawTransformFeedbackStream");
	api->VertexAttribI1iv = loadProc("glVertexAttribI1iv");
	api->GetUniformIndices = loadProc("glGetUniformIndices");
	api->GetShaderiv = loadProc("glGetShaderiv");
	api->GetActiveUniform = loadProc("glGetActiveUniform");
	api->Uniform3uiv = loadProc("glUniform3uiv");
	api->PatchParameteri = loadProc("glPatchParameteri");
	api->ProgramUniformMatrix2dv = loadProc("glProgramUniformMatrix2dv");
	api->WaitSync = loadProc("glWaitSync");
	api->ClearTexImage = mg_glClearTexImage_noimpl;
	api->DepthRangeIndexed = loadProc("glDepthRangeIndexed");
	api->GetTexParameterIiv = loadProc("glGetTexParameterIiv");
	api->DepthRange = loadProc("glDepthRange");
	api->GetActiveAttrib = loadProc("glGetActiveAttrib");
	api->IsRenderbuffer = loadProc("glIsRenderbuffer");
	api->ClearBufferiv = loadProc("glClearBufferiv");
	api->ProgramUniform3fv = loadProc("glProgramUniform3fv");
	api->VertexAttribI3uiv = loadProc("glVertexAttribI3uiv");
	api->UseProgram = loadProc("glUseProgram");
	api->GetActiveSubroutineName = loadProc("glGetActiveSubroutineName");
	api->ProgramUniformMatrix3fv = loadProc("glProgramUniformMatrix3fv");
	api->ProgramUniformMatrix4x3dv = loadProc("glProgramUniformMatrix4x3dv");
	api->UniformMatrix4x3dv = loadProc("glUniformMatrix4x3dv");
	api->ProgramUniform4dv = loadProc("glProgramUniform4dv");
	api->GetBufferSubData = loadProc("glGetBufferSubData");
	api->VertexAttrib4uiv = loadProc("glVertexAttrib4uiv");
	api->VertexAttrib1f = loadProc("glVertexAttrib1f");
	api->VertexAttrib4usv = loadProc("glVertexAttrib4usv");
	api->DebugMessageInsert = loadProc("glDebugMessageInsert");
	api->EndTransformFeedback = loadProc("glEndTransformFeedback");
	api->TexImage2DMultisample = loadProc("glTexImage2DMultisample");
	api->BindTransformFeedback = loadProc("glBindTransformFeedback");
	api->Uniform3dv = loadProc("glUniform3dv");
	api->UniformMatrix3x2dv = loadProc("glUniformMatrix3x2dv");
	api->GetSamplerParameteriv = loadProc("glGetSamplerParameteriv");
	api->VertexAttribP3uiv = loadProc("glVertexAttribP3uiv");
	api->Uniform4d = loadProc("glUniform4d");
	api->ProgramUniformMatrix3dv = loadProc("glProgramUniformMatrix3dv");
	api->ProgramUniform3ui = loadProc("glProgramUniform3ui");
	api->DeleteVertexArrays = loadProc("glDeleteVertexArrays");
	api->TexParameteri = loadProc("glTexParameteri");
	api->DrawElementsInstancedBaseVertex = loadProc("glDrawElementsInstancedBaseVertex");
	api->GetQueryObjectui64v = loadProc("glGetQueryObjectui64v");
	api->VertexAttrib4Niv = loadProc("glVertexAttrib4Niv");
	api->SamplerParameterfv = loadProc("glSamplerParameterfv");
	api->VertexAttribI4bv = loadProc("glVertexAttribI4bv");
	api->ProgramUniform1i = loadProc("glProgramUniform1i");
	api->ProgramUniformMatrix4x2dv = loadProc("glProgramUniformMatrix4x2dv");
	api->GetSynciv = loadProc("glGetSynciv");
	api->VertexAttrib3f = loadProc("glVertexAttrib3f");
	api->GetQueryObjectiv = loadProc("glGetQueryObjectiv");
	api->GetProgramInfoLog = loadProc("glGetProgramInfoLog");
	api->GetActiveUniformBlockiv = loadProc("glGetActiveUniformBlockiv");
	api->GenQueries = loadProc("glGenQueries");
	api->ProgramUniformMatrix4x3fv = loadProc("glProgramUniformMatrix4x3fv");
	api->TexBuffer = loadProc("glTexBuffer");
	api->ShaderStorageBlockBinding = loadProc("glShaderStorageBlockBinding");
	api->Disable = loadProc("glDisable");
	api->VertexAttribI3ui = loadProc("glVertexAttribI3ui");
	api->IsSampler = loadProc("glIsSampler");
	api->ActiveShaderProgram = loadProc("glActiveShaderProgram");
	api->BindVertexArray = loadProc("glBindVertexArray");
	api->UniformMatrix2x3fv = loadProc("glUniformMatrix2x3fv");
	api->DrawArraysInstanced = loadProc("glDrawArraysInstanced");
	api->VertexAttribI2uiv = loadProc("glVertexAttribI2uiv");
	api->GetQueryObjecti64v = loadProc("glGetQueryObjecti64v");
	api->GetStringi = loadProc("glGetStringi");
	api->BindProgramPipeline = loadProc("glBindProgramPipeline");
	api->BindFramebuffer = loadProc("glBindFramebuffer");
	api->VertexAttrib1d = loadProc("glVertexAttrib1d");
	api->RenderbufferStorage = loadProc("glRenderbufferStorage");
	api->ReleaseShaderCompiler = loadProc("glReleaseShaderCompiler");
	api->Uniform2i = loadProc("glUniform2i");
	api->DrawBuffer = loadProc("glDrawBuffer");
	api->DeleteRenderbuffers = loadProc("glDeleteRenderbuffers");
	api->DeleteBuffers = loadProc("glDeleteBuffers");
	api->GenFramebuffers = loadProc("glGenFramebuffers");
	api->ProgramUniformMatrix4dv = loadProc("glProgramUniformMatrix4dv");
	api->ProgramUniform3f = loadProc("glProgramUniform3f");
	api->ProgramUniform2iv = loadProc("glProgramUniform2iv");
	api->BlendBarrier = mg_glBlendBarrier_noimpl;
	api->VertexAttribL2d = loadProc("glVertexAttribL2d");
	api->CompressedTexSubImage2D = loadProc("glCompressedTexSubImage2D");
	api->UniformMatrix2fv = loadProc("glUniformMatrix2fv");
	api->SamplerParameterf = loadProc("glSamplerParameterf");
	api->UniformMatrix4fv = loadProc("glUniformMatrix4fv");
	api->VertexAttribI2ui = loadProc("glVertexAttribI2ui");
	api->BindTextures = mg_glBindTextures_noimpl;
	api->Uniform3d = loadProc("glUniform3d");
	api->ViewportIndexedfv = loadProc("glViewportIndexedfv");
	api->VertexAttribI4sv = loadProc("glVertexAttribI4sv");
	api->LineWidth = loadProc("glLineWidth");
	api->GetVertexAttribfv = loadProc("glGetVertexAttribfv");
	api->VertexAttribI3iv = loadProc("glVertexAttribI3iv");
	api->Uniform1dv = loadProc("glUniform1dv");
	api->CullFace = loadProc("glCullFace");
	api->CreateProgram = loadProc("glCreateProgram");
	api->Uniform4i = loadProc("glUniform4i");
	api->UniformMatrix4x3fv = loadProc("glUniformMatrix4x3fv");
	api->GetAttribLocation = loadProc("glGetAttribLocation");
	api->GetShaderPrecisionFormat = loadProc("glGetShaderPrecisionFormat");
	api->Uniform4iv = loadProc("glUniform4iv");
	api->CompressedTexSubImage3D = loadProc("glCompressedTexSubImage3D");
	api->BindImageTextures = mg_glBindImageTextures_noimpl;
	api->GetBufferParameteri64v = loadProc("glGetBufferParameteri64v");
	api->FrontFace = loadProc("glFrontFace");
	api->PopDebugGroup = loadProc("glPopDebugGroup");
	api->VertexAttrib1sv = loadProc("glVertexAttrib1sv");
	api->InvalidateBufferData = loadProc("glInvalidateBufferData");
	api->IsVertexArray = loadProc("glIsVertexArray");
	api->ScissorArrayv = loadProc("glScissorArrayv");
	api->ValidateProgram = loadProc("glValidateProgram");
	api->Uniform2uiv = loadProc("glUniform2uiv");
	api->TexSubImage2D = loadProc("glTexSubImage2D");
	api->DebugMessageControl = loadProc("glDebugMessageControl");
	api->FramebufferParameteri = loadProc("glFramebufferParameteri");
	api->GetUniformLocation = loadProc("glGetUniformLocation");
	api->TexStorage3D = loadProc("glTexStorage3D");
	api->PixelStoref = loadProc("glPixelStoref");
	api->DepthRangef = loadProc("glDepthRangef");
	api->VertexAttribI3i = loadProc("glVertexAttribI3i");
	api->Uniform1uiv = loadProc("glUniform1uiv");
	api->Disablei = loadProc("glDisablei");
	api->GetInternalformati64v = loadProc("glGetInternalformati64v");
	api->ProgramUniformMatrix2x3dv = loadProc("glProgramUniformMatrix2x3dv");
	api->GetProgramResourceIndex = loadProc("glGetProgramResourceIndex");
	api->BlendColor = loadProc("glBlendColor");
	api->GenSamplers = loadProc("glGenSamplers");
	api->ColorMaski = loadProc("glColorMaski");
	api->GetGraphicsResetStatus = mg_glGetGraphicsResetStatus_noimpl;
	api->VertexAttribI4uiv = loadProc("glVertexAttribI4uiv");
	api->CreateShaderProgramv = loadProc("glCreateShaderProgramv");
	api->DeleteSamplers = loadProc("glDeleteSamplers");
	api->VertexAttrib3s = loadProc("glVertexAttrib3s");
	api->DrawTransformFeedback = loadProc("glDrawTransformFeedback");
	api->VertexAttribL1d = loadProc("glVertexAttribL1d");
	api->DrawElementsInstancedBaseVertexBaseInstance = loadProc("glDrawElementsInstancedBaseVertexBaseInstance");
	api->ClearBufferSubData = loadProc("glClearBufferSubData");
	api->VertexAttribLFormat = loadProc("glVertexAttribLFormat");
	api->Uniform2dv = loadProc("glUniform2dv");
	api->CopyTexSubImage3D = loadProc("glCopyTexSubImage3D");
	api->CopyTexImage1D = loadProc("glCopyTexImage1D");
	api->FramebufferTexture3D = loadProc("glFramebufferTexture3D");
	api->VertexAttribL4d = loadProc("glVertexAttribL4d");
	api->UnmapBuffer = loadProc("glUnmapBuffer");
	api->GetQueryIndexediv = loadProc("glGetQueryIndexediv");
	api->FenceSync = loadProc("glFenceSync");
	api->DispatchComputeIndirect = loadProc("glDispatchComputeIndirect");
	api->SamplerParameterIuiv = loadProc("glSamplerParameterIuiv");
	api->GetFragDataLocation = loadProc("glGetFragDataLocation");
	api->GetUniformdv = loadProc("glGetUniformdv");
	api->TexImage3D = loadProc("glTexImage3D");
	api->ValidateProgramPipeline = loadProc("glValidateProgramPipeline");
	api->LinkProgram = loadProc("glLinkProgram");
	api->DeleteQueries = loadProc("glDeleteQueries");
	api->FramebufferTexture1D = loadProc("glFramebufferTexture1D");
	api->GetActiveSubroutineUniformName = loadProc("glGetActiveSubroutineUniformName");
	api->ProgramUniformMatrix3x2fv = loadProc("glProgramUniformMatrix3x2fv");
	api->GetTexParameteriv = loadProc("glGetTexParameteriv");
	api->ProvokingVertex = loadProc("glProvokingVertex");
	api->BindAttribLocation = loadProc("glBindAttribLocation");
	api->VertexAttrib3fv = loadProc("glVertexAttrib3fv");
	api->GetActiveUniformBlockName = loadProc("glGetActiveUniformBlockName");
	api->DrawArrays = loadProc("glDrawArrays");
	api->GetnUniformuiv = mg_glGetnUniformuiv_noimpl;
	api->ProgramUniform1uiv = loadProc("glProgramUniform1uiv");
	api->DrawElementsIndirect = loadProc("glDrawElementsIndirect");
	api->VertexAttribI4usv = loadProc("glVertexAttribI4usv");
	api->BlendEquationSeparatei = loadProc("glBlendEquationSeparatei");
	api->DrawElements = loadProc("glDrawElements");
	api->GetShaderSource = loadProc("glGetShaderSource");
	api->TransformFeedbackVaryings = loadProc("glTransformFeedbackVaryings");
	api->GetError = loadProc("glGetError");
	api->IsBuffer = loadProc("glIsBuffer");
	api->ClearBufferuiv = loadProc("glClearBufferuiv");
	api->GetVertexAttribiv = loadProc("glGetVertexAttribiv");
	api->GetProgramResourceName = loadProc("glGetProgramResourceName");
	api->Uniform2ui = loadProc("glUniform2ui");
	api->StencilFunc = loadProc("glStencilFunc");
	api->Enablei = loadProc("glEnablei");
	api->SamplerParameteriv = loadProc("glSamplerParameteriv");
	api->GetInteger64i_v = loadProc("glGetInteger64i_v");
	api->ProgramUniform4i = loadProc("glProgramUniform4i");
	api->Uniform4ui = loadProc("glUniform4ui");
	api->UniformMatrix2x4fv = loadProc("glUniformMatrix2x4fv");
	api->ReadnPixels = mg_glReadnPixels_noimpl;
	api->DrawTransformFeedbackInstanced = loadProc("glDrawTransformFeedbackInstanced");
	api->PointSize = loadProc("glPointSize");
	api->ProgramUniformMatrix4fv = loadProc("glProgramUniformMatrix4fv");
	api->ViewportArrayv = loadProc("glViewportArrayv");
	api->StencilOpSeparate = loadProc("glStencilOpSeparate");
	api->Uniform3ui = loadProc("glUniform3ui");
	api->Uniform4uiv = loadProc("glUniform4uiv");
	api->Uniform3iv = loadProc("glUniform3iv");
	api->Uniform4f = loadProc("glUniform4f");
	api->FramebufferTexture2D = loadProc("glFramebufferTexture2D");
	api->GetIntegeri_v = loadProc("glGetIntegeri_v");
	api->MultiDrawElements = loadProc("glMultiDrawElements");
	api->UniformMatrix4x2dv = loadProc("glUniformMatrix4x2dv");
	api->ProgramUniformMatrix2x3fv = loadProc("glProgramUniformMatrix2x3fv");
	api->CopyTexSubImage1D = loadProc("glCopyTexSubImage1D");
	api->TexSubImage3D = loadProc("glTexSubImage3D");
	api->GetActiveSubroutineUniformiv = loadProc("glGetActiveSubroutineUniformiv");
	api->GenProgramPipelines = loadProc("glGenProgramPipelines");
	api->ProgramUniform4iv = loadProc("glProgramUniform4iv");
	api->UniformMatrix3x4fv = loadProc("glUniformMatrix3x4fv");
	api->UniformBlockBinding = loadProc("glUniformBlockBinding");
	api->DepthRangeArrayv = loadProc("glDepthRangeArrayv");
	api->TexParameterfv = loadProc("glTexParameterfv");
	api->MapBuffer = loadProc("glMapBuffer");
	api->DeleteProgramPipelines = loadProc("glDeleteProgramPipelines");
	api->MinSampleShading = loadProc("glMinSampleShading");
	api->PauseTransformFeedback = loadProc("glPauseTransformFeedback");
	api->EndQueryIndexed = loadProc("glEndQueryIndexed");
	api->GetProgramBinary = loadProc("glGetProgramBinary");
	api->ProgramUniform2i = loadProc("glProgramUniform2i");
	api->DepthMask = loadProc("glDepthMask");
	api->ActiveTexture = loadProc("glActiveTexture");
	api->UseProgramStages = loadProc("glUseProgramStages");
	api->PatchParameterfv = loadProc("glPatchParameterfv");
	api->ShaderBinary = loadProc("glShaderBinary");
	api->GetFloatv = loadProc("glGetFloatv");
	api->ProgramUniform1f = loadProc("glProgramUniform1f");
	api->TexImage1D = loadProc("glTexImage1D");
	api->ProgramUniform2uiv = loadProc("glProgramUniform2uiv");
	api->ClearBufferData = loadProc("glClearBufferData");
	api->UniformMatrix3dv = loadProc("glUniformMatrix3dv");
	api->CompressedTexImage2D = loadProc("glCompressedTexImage2D");
	api->VertexAttrib4fv = loadProc("glVertexAttrib4fv");
	api->GetProgramResourceiv = loadProc("glGetProgramResourceiv");
	api->GetString = loadProc("glGetString");
	api->ProgramUniformMatrix2fv = loadProc("glProgramUniformMatrix2fv");
	api->GetVertexAttribLdv = loadProc("glGetVertexAttribLdv");
	api->VertexAttrib4Nubv = loadProc("glVertexAttrib4Nubv");
	api->TexBufferRange = loadProc("glTexBufferRange");
	api->UniformMatrix3x4dv = loadProc("glUniformMatrix3x4dv");
	api->GetProgramInterfaceiv = loadProc("glGetProgramInterfaceiv");
	api->TexParameterIuiv = loadProc("glTexParameterIuiv");
	api->DeleteShader = loadProc("glDeleteShader");
	api->GetFloati_v = loadProc("glGetFloati_v");
	api->DrawTransformFeedbackStreamInstanced = loadProc("glDrawTransformFeedbackStreamInstanced");
	api->VertexAttrib4s = loadProc("glVertexAttrib4s");
}

void mg_gl_load_gl44(mg_gl_api* api, mg_gl_load_proc loadProc)
{
	api->name = "gl44";
	api->PointParameterfv = loadProc("glPointParameterfv");
	api->Uniform3fv = loadProc("glUniform3fv");
	api->Uniform1i = loadProc("glUniform1i");
	api->VertexAttribP3ui = loadProc("glVertexAttribP3ui");
	api->VertexAttrib4sv = loadProc("glVertexAttrib4sv");
	api->GetBufferParameteriv = loadProc("glGetBufferParameteriv");
	api->ProgramUniform2dv = loadProc("glProgramUniform2dv");
	api->ClampColor = loadProc("glClampColor");
	api->CompressedTexImage3D = loadProc("glCompressedTexImage3D");
	api->ProgramUniformMatrix2x4fv = loadProc("glProgramUniformMatrix2x4fv");
	api->ProgramUniform2d = loadProc("glProgramUniform2d");
	api->BindBuffer = loadProc("glBindBuffer");
	api->GetUniformBlockIndex = loadProc("glGetUniformBlockIndex");
	api->InvalidateFramebuffer = loadProc("glInvalidateFramebuffer");
	api->PixelStorei = loadProc("glPixelStorei");
	api->BindTexture = loadProc("glBindTexture");
	api->VertexAttrib4Nuiv = loadProc("glVertexAttrib4Nuiv");
	api->IsTexture = loadProc("glIsTexture");
	api->VertexAttrib4d = loadProc("glVertexAttrib4d");
	api->ProgramUniformMatrix2x4dv = loadProc("glProgramUniformMatrix2x4dv");
	api->GetObjectLabel = loadProc("glGetObjectLabel");
	api->BeginConditionalRender = loadProc("glBeginConditionalRender");
	api->IsFramebuffer = loadProc("glIsFramebuffer");
	api->CompileShader = loadProc("glCompileShader");
	api->VertexAttribBinding = loadProc("glVertexAttribBinding");
	api->VertexAttribL1dv = loadProc("glVertexAttribL1dv");
	api->Uniform1fv = loadProc("glUniform1fv");
	api->TexImage2D = loadProc("glTexImage2D");
	api->Flush = loadProc("glFlush");
	api->VertexAttribP2uiv = loadProc("glVertexAttribP2uiv");
	api->IsProgram = loadProc("glIsProgram");
	api->ProgramUniform4fv = loadProc("glProgramUniform4fv");
	api->VertexAttribLPointer = loadProc("glVertexAttribLPointer");
	api->ClientWaitSync = loadProc("glClientWaitSync");
	api->Uniform1d = loadProc("glUniform1d");
	api->ProgramUniform1ui = loadProc("glProgramUniform1ui");
	api->ColorMask = loadProc("glColorMask");
	api->ClearDepth = loadProc("glClearDepth");
	api->GetInteger64v = loadProc("glGetInteger64v");
	api->VertexAttribP2ui = loadProc("glVertexAttribP2ui");
	api->VertexAttrib2dv = loadProc("glVertexAttrib2dv");
	api->VertexAttribI4ui = loadProc("glVertexAttribI4ui");
	api->BlendEquationi = loadProc("glBlendEquationi");
	api->DrawRangeElements = loadProc("glDrawRangeElements");
	api->InvalidateTexImage = loadProc("glInvalidateTexImage");
	api->SampleMaski = loadProc("glSampleMaski");
	api->GetProgramResourceLocationIndex = loadProc("glGetProgramResourceLocationIndex");
	api->VertexAttrib4dv = loadProc("glVertexAttrib4dv");
	api->BindFragDataLocation = loadProc("glBindFragDataLocation");
	api->GetFragDataIndex = loadProc("glGetFragDataIndex");
	api->GetTexLevelParameterfv = loadProc("glGetTexLevelParameterfv");
	api->VertexAttribP4uiv = loadProc("glVertexAttribP4uiv");
	api->MultiDrawArrays = loadProc("glMultiDrawArrays");
	api->IsTransformFeedback = loadProc("glIsTransformFeedback");
	api->GetUniformiv = loadProc("glGetUniformiv");
	api->BufferData = loadProc("glBufferData");
	api->GetCompressedTexImage = loadProc("glGetCompressedTexImage");
	api->VertexAttrib3sv = loadProc("glVertexAttrib3sv");
	api->IsQuery = loadProc("glIsQuery");
	api->ClearColor = loadProc("glClearColor");
	api->BlendFunc = loadProc("glBlendFunc");
	api->GetDoublei_v = loadProc("glGetDoublei_v");
	api->FramebufferTexture = loadProc("glFramebufferTexture");
	api->StencilMaskSeparate = loadProc("glStencilMaskSeparate");
	api->PrimitiveRestartIndex = loadProc("glPrimitiveRestartIndex");
	api->VertexAttribP1ui = loadProc("glVertexAttribP1ui");
	api->VertexAttribIFormat = loadProc("glVertexAttribIFormat");
	api->MemoryBarrier = loadProc("glMemoryBarrier");
	api->GetSubroutineUniformLocation = loadProc("glGetSubroutineUniformLocation");
	api->BindRenderbuffer = loadProc("glBindRenderbuffer");
	api->PushDebugGroup = loadProc("glPushDebugGroup");
	api->GenTextures = loadProc("glGenTextures");
	api->GetIntegerv = loadProc("glGetIntegerv");
	api->GetQueryObjectuiv = loadProc("glGetQueryObjectuiv");
	api->Uniform4fv = loadProc("glUniform4fv");
	api->Hint = loadProc("glHint");
	api->TexParameterf = loadProc("glTexParameterf");
	api->ProgramUniform2fv = loadProc("glProgramUniform2fv");
	api->DrawRangeElementsBaseVertex = loadProc("glDrawRangeElementsBaseVertex");
	api->Clear = loadProc("glClear");
	api->BindBufferBase = loadProc("glBindBufferBase");
	api->GetQueryiv = loadProc("glGetQueryiv");
	api->ProgramBinary = loadProc("glProgramBinary");
	api->ScissorIndexedv = loadProc("glScissorIndexedv");
	api->VertexAttrib1fv = loadProc("glVertexAttrib1fv");
	api->TexStorage2D = loadProc("glTexStorage2D");
	api->VertexAttrib4f = loadProc("glVertexAttrib4f");
	api->ProgramParameteri = loadProc("glProgramParameteri");
	api->Enable = loadProc("glEnable");
	api->GetBufferPointerv = loadProc("glGetBufferPointerv");
	api->LogicOp = loadProc("glLogicOp");
	api->DepthFunc = loadProc("glDepthFunc");
	api->VertexAttrib1dv = loadProc("glVertexAttrib1dv");
	api->Uniform2d = loadProc("glUniform2d");
	api->DetachShader = loadProc("glDetachShader");
	api->VertexBindingDivisor = loadProc("glVertexBindingDivisor");
	api->IsProgramPipeline = loadProc("glIsProgramPipeline");
	api->ProgramUniform1fv = loadProc("glProgramUniform1fv");
	api->CopyTexSubImage2D = loadProc("glCopyTexSubImage2D");
	api->VertexAttrib2fv = loadProc("glVertexAttrib2fv");
	api->GetDoublev = loadProc("glGetDoublev");
	api->ResumeTransformFeedback = loadProc("glResumeTransformFeedback");
	api->ProgramUniform4d = loadProc("glProgramUniform4d");
	api->ProgramUniform4uiv = loadProc("glProgramUniform4uiv");
	api->DispatchCompute = loadProc("glDispatchCompute");
	api->VertexAttrib4bv = loadProc("glVertexAttrib4bv");
	api->GetSamplerParameterfv = loadProc("glGetSamplerParameterfv");
	api->ProgramUniform3iv = loadProc("glProgramUniform3iv");
	api->VertexAttrib1s = loadProc("glVertexAttrib1s");
	api->VertexAttribI2i = loadProc("glVertexAttribI2i");
	api->SampleCoverage = loadProc("glSampleCoverage");
	api->BufferSubData = loadProc("glBufferSubData");
	api->VertexAttribI1ui = loadProc("glVertexAttribI1ui");
	api->EndConditionalRender = loadProc("glEndConditionalRender");
	api->GetPointerv = loadProc("glGetPointerv");
	api->GetnUniformiv = mg_glGetnUniformiv_noimpl;
	api->BlendEquation = loadProc("glBlendEquation");
	api->VertexAttribI4iv = loadProc("glVertexAttribI4iv");
	api->GetnUniformfv = mg_glGetnUniformfv_noimpl;
	api->VertexAttrib4Nsv = loadProc("glVertexAttrib4Nsv");
	api->Uniform2fv = loadProc("glUniform2fv");
	api->Uniform3f = loadProc("glUniform3f");
	api->GenerateMipmap = loadProc("glGenerateMipmap");
	api->GenRenderbuffers = loadProc("glGenRenderbuffers");
	api->DrawElementsBaseVertex = loadProc("glDrawElementsBaseVertex");
	api->BindVertexBuffers = loadProc("glBindVertexBuffers");
	api->Scissor = loadProc("glScissor");
	api->MapBufferRange = loadProc("glMapBufferRange");
	api->ProgramUniformMatrix4x2fv = loadProc("glProgramUniformMatrix4x2fv");
	api->GetTexParameterfv = loadProc("glGetTexParameterfv");
	api->Uniform2f = loadProc("glUniform2f");
	api->VertexAttribFormat = loadProc("glVertexAttribFormat");
	api->UniformMatrix2dv = loadProc("glUniformMatrix2dv");
	api->IsEnabled = loadProc("glIsEnabled");
	api->ClearBufferfi = loadProc("glClearBufferfi");
	api->GetRenderbufferParameteriv = loadProc("glGetRenderbufferParameteriv");
	api->FramebufferTextureLayer = loadProc("glFramebufferTextureLayer");
	api->PointParameterf = loadProc("glPointParameterf");
	api->GenVertexArrays = loadProc("glGenVertexArrays");
	api->GetAttachedShaders = loadProc("glGetAttachedShaders");
	api->FramebufferRenderbuffer = loadProc("glFramebufferRenderbuffer");
	api->DeleteTextures = loadProc("glDeleteTextures");
	api->BeginQuery = loadProc("glBeginQuery");
	api->Uniform4dv = loadProc("glUniform4dv");
	api->VertexAttribIPointer = loadProc("glVertexAttribIPointer");
	api->GetSamplerParameterIiv = loadProc("glGetSamplerParameterIiv");
	api->BeginQueryIndexed = loadProc("glBeginQueryIndexed");
	api->BeginTransformFeedback = loadProc("glBeginTransformFeedback");
	api->Uniform3i = loadProc("glUniform3i");
	api->GetActiveUniformName = loadProc("glGetActiveUniformName");
	api->GetProgramResourceLocation = loadProc("glGetProgramResourceLocation");
	api->ShaderSource = loadProc("glShaderSource");
	api->SamplerParameterIiv = loadProc("glSamplerParameterIiv");
	api->Finish = loadProc("glFinish");
	api->DrawArraysInstancedBaseInstance = loadProc("glDrawArraysInstancedBaseInstance");
	api->DeleteProgram = loadProc("glDeleteProgram");
	api->MultiDrawElementsBaseVertex = loadProc("glMultiDrawElementsBaseVertex");
	api->ReadBuffer = loadProc("glReadBuffer");
	api->GenBuffers = loadProc("glGenBuffers");
	api->ClearDepthf = loadProc("glClearDepthf");
	api->VertexAttribPointer = loadProc("glVertexAttribPointer");
	api->VertexAttribL4dv = loadProc("glVertexAttribL4dv");
	api->TexStorage2DMultisample = loadProc("glTexStorage2DMultisample");
	api->BindSamplers = loadProc("glBindSamplers");
	api->EnableVertexAttribArray = loadProc("glEnableVertexAttribArray");
	api->VertexAttrib4ubv = loadProc("glVertexAttrib4ubv");
	api->GetDebugMessageLog = loadProc("glGetDebugMessageLog");
	api->DisableVertexAttribArray = loadProc("glDisableVertexAttribArray");
	api->DrawElementsInstancedBaseInstance = loadProc("glDrawElementsInstancedBaseInstance");
	api->PolygonMode = loadProc("glPolygonMode");
	api->VertexAttribP1uiv = loadProc("glVertexAttribP1uiv");
	api->ProgramUniform1iv = loadProc("glProgramUniform1iv");
	api->VertexAttribI1i = loadProc("glVertexAttribI1i");
	api->GetTexLevelParameteriv = loadProc("glGetTexLevelParameteriv");
	api->IsSync = loadProc("glIsSync");
	api->TexStorage1D = loadProc("glTexStorage1D");
	api->GetVertexAttribIiv = loadProc("glGetVertexAttribIiv");
	api->IsEnabledi = loadProc("glIsEnabledi");
	api->MultiDrawElementsIndirect = loadProc("glMultiDrawElementsIndirect");
	api->GetBooleani_v = loadProc("glGetBooleani_v");
	api->GetInternalformativ = loadProc("glGetInternalformativ");
	api->VertexAttribI4ubv = loadProc("glVertexAttribI4ubv");
	api->VertexAttrib2s = loadProc("glVertexAttrib2s");
	api->GetBooleanv = loadProc("glGetBooleanv");
	api->VertexAttrib4iv = loadProc("glVertexAttrib4iv");
	api->GetObjectPtrLabel = loadProc("glGetObjectPtrLabel");
	api->UniformMatrix2x4dv = loadProc("glUniformMatrix2x4dv");
	api->ProgramUniform4ui = loadProc("glProgramUniform4ui");
	api->GetVertexAttribdv = loadProc("glGetVertexAttribdv");
	api->ViewportIndexedf = loadProc("glViewportIndexedf");
	api->DeleteSync = loadProc("glDeleteSync");
	api->CopyImageSubData = loadProc("glCopyImageSubData");
	api->PrimitiveBoundingBox = mg_glPrimitiveBoundingBox_noimpl;
	api->ScissorIndexed = loadProc("glScissorIndexed");
	api->GenTransformFeedbacks = loadProc("glGenTransformFeedbacks");
	api->MemoryBarrierByRegion = mg_glMemoryBarrierByRegion_noimpl;
	api->DeleteTransformFeedbacks = loadProc("glDeleteTransformFeedbacks");
	api->ProgramUniform4f = loadProc("glProgramUniform4f");
	api->BindBuffersBase = loadProc("glBindBuffersBase");
	api->GetTexParameterIuiv = loadProc("glGetTexParameterIuiv");
	api->IsShader = loadProc("glIsShader");
	api->ProgramUniform3i = loadProc("glProgramUniform3i");
	api->GetActiveAtomicCounterBufferiv = loadProc("glGetActiveAtomicCounterBufferiv");
	api->ProgramUniformMatrix3x4fv = loadProc("glProgramUniformMatrix3x4fv");
	api->BufferStorage = loadProc("glBufferStorage");
	api->GetUniformSubroutineuiv = loadProc("glGetUniformSubroutineuiv");
	api->RenderbufferStorageMultisample = loadProc("glRenderbufferStorageMultisample");
	api->GetMultisamplefv = loadProc("glGetMultisamplefv");
	api->VertexAttribDivisor = loadProc("glVertexAttribDivisor");
	api->StencilMask = loadProc("glStencilMask");
	api->BindSampler = loadProc("glBindSampler");
	api->UniformMatrix4dv = loadProc("glUniformMatrix4dv");
	api->BindImageTexture = loadProc("glBindImageTexture");
	api->DrawBuffers = loadProc("glDrawBuffers");
	api->VertexAttrib4Nub = loadProc("glVertexAttrib4Nub");
	api->GetTexImage = loadProc("glGetTexImage");
	api->VertexAttrib3dv = loadProc("glVertexAttrib3dv");
	api->BlitFramebuffer = loadProc("glBlitFramebuffer");
	api->VertexAttrib2d = loadProc("glVertexAttrib2d");
	api->Uniform1ui = loadProc("glUniform1ui");
	api->InvalidateBufferSubData = loadProc("glInvalidateBufferSubData");
	api->EndQuery = loadProc("glEndQuery");
	api->GetUniformuiv = loadProc("glGetUniformuiv");
	api->GetFramebufferAttachmentParameteriv = loadProc("glGetFramebufferAttachmentParameteriv");
	api->ProgramUniform2f = loadProc("glProgramUniform2f");
	api->UniformMatrix3x2fv = loadProc("glUniformMatrix3x2fv");
	api->BindVertexBuffer = loadProc("glBindVertexBuffer");
	api->VertexAttrib2sv = loadProc("glVertexAttrib2sv");
	api->Uniform1f = loadProc("glUniform1f");
	api->DebugMessageCallback = loadProc("glDebugMessageCallback");
	api->ReadPixels = loadProc("glReadPixels");
	api->CompressedTexSubImage1D = loadProc("glCompressedTexSubImage1D");
	api->DrawArraysIndirect = loadProc("glDrawArraysIndirect");
	api->BlendFuncSeparate = loadProc("glBlendFuncSeparate");
	api->CreateShader = loadProc("glCreateShader");
	api->GetTransformFeedbackVarying = loadProc("glGetTransformFeedbackVarying");
	api->AttachShader = loadProc("glAttachShader");
	api->UniformMatrix2x3dv = loadProc("glUniformMatrix2x3dv");
	api->ProgramUniform3uiv = loadProc("glProgramUniform3uiv");
	api->MultiDrawArraysIndirect = loadProc("glMultiDrawArraysIndirect");
	api->Uniform2iv = loadProc("glUniform2iv");
	api->BindBufferRange = loadProc("glBindBufferRange");
	api->TexParameteriv = loadProc("glTexParameteriv");
	api->VertexAttribL3d = loadProc("glVertexAttribL3d");
	api->TexImage3DMultisample = loadProc("glTexImage3DMultisample");
	api->ClearTexSubImage = loadProc("glClearTexSubImage");
	api->VertexAttrib4Nusv = loadProc("glVertexAttrib4Nusv");
	api->InvalidateSubFramebuffer = loadProc("glInvalidateSubFramebuffer");
	api->GetShaderInfoLog = loadProc("glGetShaderInfoLog");
	api->VertexAttribP4ui = loadProc("glVertexAttribP4ui");
	api->Viewport = loadProc("glViewport");
	api->BlendFunci = loadProc("glBlendFunci");
	api->PolygonOffset = loadProc("glPolygonOffset");
	api->ProgramUniform2ui = loadProc("glProgramUniform2ui");
	api->SamplerParameteri = loadProc("glSamplerParameteri");
	api->GetFramebufferParameteriv = loadProc("glGetFramebufferParameteriv");
	api->VertexAttribI2iv = loadProc("glVertexAttribI2iv");
	api->ObjectLabel = loadProc("glObjectLabel");
	api->CompressedTexImage1D = loadProc("glCompressedTexImage1D");
	api->InvalidateTexSubImage = loadProc("glInvalidateTexSubImage");
	api->BindBuffersRange = loadProc("glBindBuffersRange");
	api->CopyBufferSubData = loadProc("glCopyBufferSubData");
	api->VertexAttrib4Nbv = loadProc("glVertexAttrib4Nbv");
	api->ObjectPtrLabel = loadProc("glObjectPtrLabel");
	api->ProgramUniform3d = loadProc("glProgramUniform3d");
	api->GetProgramPipelineiv = loadProc("glGetProgramPipelineiv");
	api->TexStorage3DMultisample = loadProc("glTexStorage3DMultisample");
	api->VertexAttribL3dv = loadProc("glVertexAttribL3dv");
	api->DeleteFramebuffers = loadProc("glDeleteFramebuffers");
	api->CheckFramebufferStatus = loadProc("glCheckFramebufferStatus");
	api->VertexAttribL2dv = loadProc("glVertexAttribL2dv");
	api->ProgramUniform1dv = loadProc("glProgramUniform1dv");
	api->VertexAttrib2f = loadProc("glVertexAttrib2f");
	api->GetVertexAttribIuiv = loadProc("glGetVertexAttribIuiv");
	api->StencilOp = loadProc("glStencilOp");
	api->VertexAttrib3d = loadProc("glVertexAttrib3d");
	api->PointParameteri = loadProc("glPointParameteri");
	api->VertexAttribI1uiv = loadProc("glVertexAttribI1uiv");
	api->ClearBufferfv = loadProc("glClearBufferfv");
	api->BindFragDataLocationIndexed = loadProc("glBindFragDataLocationIndexed");
	api->ProgramUniform1d = loadProc("glProgramUniform1d");
	api->PointParameteriv = loadProc("glPointParameteriv");
	api->FlushMappedBufferRange = loadProc("glFlushMappedBufferRange");
	api->TextureView = loadProc("glTextureView");
	api->GetProgramPipelineInfoLog = loadProc("glGetProgramPipelineInfoLog");
	api->CopyTexImage2D = loadProc("glCopyTexImage2D");
	api->ProgramUniform3dv = loadProc("glProgramUniform3dv");
	api->QueryCounter = loadProc("glQueryCounter");
	api->GetUniformfv = loadProc("glGetUniformfv");
	api->ClearStencil = loadProc("glClearStencil");
	api->GetProgramiv = loadProc("glGetProgramiv");
	api->UniformSubroutinesuiv = loadProc("glUniformSubroutinesuiv");
	api->GetProgramStageiv = loadProc("glGetProgramStageiv");
	api->Uniform1iv = loadProc("glUniform1iv");
	api->GetVertexAttribPointerv = loadProc("glGetVertexAttribPointerv");
	api->TexSubImage1D = loadProc("glTexSubImage1D");
	api->StencilFuncSeparate = loadProc("glStencilFuncSeparate");
	api->GetSubroutineIndex = loadProc("glGetSubroutineIndex");
	api->DrawElementsInstanced = loadProc("glDrawElementsInstanced");
	api->BlendFuncSeparatei = loadProc("glBlendFuncSeparatei");
	api->ProgramUniformMatrix3x2dv = loadProc("glProgramUniformMatrix3x2dv");
	api->GetActiveUniformsiv = loadProc("glGetActiveUniformsiv");
	api->UniformMatrix3fv = loadProc("glUniformMatrix3fv");
	api->ProgramUniformMatrix3x4dv = loadProc("glProgramUniformMatrix3x4dv");
	api->GetSamplerParameterIuiv = loadProc("glGetSamplerParameterIuiv");
	api->VertexAttribI4i = loadProc("glVertexAttribI4i");
	api->BlendEquationSeparate = loadProc("glBlendEquationSeparate");
	api->UniformMatrix4x2fv = loadProc("glUniformMatrix4x2fv");
	api->TexParameterIiv = loadProc("glTexParameterIiv");
	api->DrawTransformFeedbackStream = loadProc("glDrawTransformFeedbackStream");
	api->VertexAttribI1iv = loadProc("glVertexAttribI1iv");
	api->GetUniformIndices = loadProc("glGetUniformIndices");
	api->GetShaderiv = loadProc("glGetShaderiv");
	api->GetActiveUniform = loadProc("glGetActiveUniform");
	api->Uniform3uiv = loadProc("glUniform3uiv");
	api->PatchParameteri = loadProc("glPatchParameteri");
	api->ProgramUniformMatrix2dv = loadProc("glProgramUniformMatrix2dv");
	api->WaitSync = loadProc("glWaitSync");
	api->ClearTexImage = loadProc("glClearTexImage");
	api->DepthRangeIndexed = loadProc("glDepthRangeIndexed");
	api->GetTexParameterIiv = loadProc("glGetTexParameterIiv");
	api->DepthRange = loadProc("glDepthRange");
	api->GetActiveAttrib = loadProc("glGetActiveAttrib");
	api->IsRenderbuffer = loadProc("glIsRenderbuffer");
	api->ClearBufferiv = loadProc("glClearBufferiv");
	api->ProgramUniform3fv = loadProc("glProgramUniform3fv");
	api->VertexAttribI3uiv = loadProc("glVertexAttribI3uiv");
	api->UseProgram = loadProc("glUseProgram");
	api->GetActiveSubroutineName = loadProc("glGetActiveSubroutineName");
	api->ProgramUniformMatrix3fv = loadProc("glProgramUniformMatrix3fv");
	api->ProgramUniformMatrix4x3dv = loadProc("glProgramUniformMatrix4x3dv");
	api->UniformMatrix4x3dv = loadProc("glUniformMatrix4x3dv");
	api->ProgramUniform4dv = loadProc("glProgramUniform4dv");
	api->GetBufferSubData = loadProc("glGetBufferSubData");
	api->VertexAttrib4uiv = loadProc("glVertexAttrib4uiv");
	api->VertexAttrib1f = loadProc("glVertexAttrib1f");
	api->VertexAttrib4usv = loadProc("glVertexAttrib4usv");
	api->DebugMessageInsert = loadProc("glDebugMessageInsert");
	api->EndTransformFeedback = loadProc("glEndTransformFeedback");
	api->TexImage2DMultisample = loadProc("glTexImage2DMultisample");
	api->BindTransformFeedback = loadProc("glBindTransformFeedback");
	api->Uniform3dv = loadProc("glUniform3dv");
	api->UniformMatrix3x2dv = loadProc("glUniformMatrix3x2dv");
	api->GetSamplerParameteriv = loadProc("glGetSamplerParameteriv");
	api->VertexAttribP3uiv = loadProc("glVertexAttribP3uiv");
	api->Uniform4d = loadProc("glUniform4d");
	api->ProgramUniformMatrix3dv = loadProc("glProgramUniformMatrix3dv");
	api->ProgramUniform3ui = loadProc("glProgramUniform3ui");
	api->DeleteVertexArrays = loadProc("glDeleteVertexArrays");
	api->TexParameteri = loadProc("glTexParameteri");
	api->DrawElementsInstancedBaseVertex = loadProc("glDrawElementsInstancedBaseVertex");
	api->GetQueryObjectui64v = loadProc("glGetQueryObjectui64v");
	api->VertexAttrib4Niv = loadProc("glVertexAttrib4Niv");
	api->SamplerParameterfv = loadProc("glSamplerParameterfv");
	api->VertexAttribI4bv = loadProc("glVertexAttribI4bv");
	api->ProgramUniform1i = loadProc("glProgramUniform1i");
	api->ProgramUniformMatrix4x2dv = loadProc("glProgramUniformMatrix4x2dv");
	api->GetSynciv = loadProc("glGetSynciv");
	api->VertexAttrib3f = loadProc("glVertexAttrib3f");
	api->GetQueryObjectiv = loadProc("glGetQueryObjectiv");
	api->GetProgramInfoLog = loadProc("glGetProgramInfoLog");
	api->GetActiveUniformBlockiv = loadProc("glGetActiveUniformBlockiv");
	api->GenQueries = loadProc("glGenQueries");
	api->ProgramUniformMatrix4x3fv = loadProc("glProgramUniformMatrix4x3fv");
	api->TexBuffer = loadProc("glTexBuffer");
	api->ShaderStorageBlockBinding = loadProc("glShaderStorageBlockBinding");
	api->Disable = loadProc("glDisable");
	api->VertexAttribI3ui = loadProc("glVertexAttribI3ui");
	api->IsSampler = loadProc("glIsSampler");
	api->ActiveShaderProgram = loadProc("glActiveShaderProgram");
	api->BindVertexArray = loadProc("glBindVertexArray");
	api->UniformMatrix2x3fv = loadProc("glUniformMatrix2x3fv");
	api->DrawArraysInstanced = loadProc("glDrawArraysInstanced");
	api->VertexAttribI2uiv = loadProc("glVertexAttribI2uiv");
	api->GetQueryObjecti64v = loadProc("glGetQueryObjecti64v");
	api->GetStringi = loadProc("glGetStringi");
	api->BindProgramPipeline = loadProc("glBindProgramPipeline");
	api->BindFramebuffer = loadProc("glBindFramebuffer");
	api->VertexAttrib1d = loadProc("glVertexAttrib1d");
	api->RenderbufferStorage = loadProc("glRenderbufferStorage");
	api->ReleaseShaderCompiler = loadProc("glReleaseShaderCompiler");
	api->Uniform2i = loadProc("glUniform2i");
	api->DrawBuffer = loadProc("glDrawBuffer");
	api->DeleteRenderbuffers = loadProc("glDeleteRenderbuffers");
	api->DeleteBuffers = loadProc("glDeleteBuffers");
	api->GenFramebuffers = loadProc("glGenFramebuffers");
	api->ProgramUniformMatrix4dv = loadProc("glProgramUniformMatrix4dv");
	api->ProgramUniform3f = loadProc("glProgramUniform3f");
	api->ProgramUniform2iv = loadProc("glProgramUniform2iv");
	api->BlendBarrier = mg_glBlendBarrier_noimpl;
	api->VertexAttribL2d = loadProc("glVertexAttribL2d");
	api->CompressedTexSubImage2D = loadProc("glCompressedTexSubImage2D");
	api->UniformMatrix2fv = loadProc("glUniformMatrix2fv");
	api->SamplerParameterf = loadProc("glSamplerParameterf");
	api->UniformMatrix4fv = loadProc("glUniformMatrix4fv");
	api->VertexAttribI2ui = loadProc("glVertexAttribI2ui");
	api->BindTextures = loadProc("glBindTextures");
	api->Uniform3d = loadProc("glUniform3d");
	api->ViewportIndexedfv = loadProc("glViewportIndexedfv");
	api->VertexAttribI4sv = loadProc("glVertexAttribI4sv");
	api->LineWidth = loadProc("glLineWidth");
	api->GetVertexAttribfv = loadProc("glGetVertexAttribfv");
	api->VertexAttribI3iv = loadProc("glVertexAttribI3iv");
	api->Uniform1dv = loadProc("glUniform1dv");
	api->CullFace = loadProc("glCullFace");
	api->CreateProgram = loadProc("glCreateProgram");
	api->Uniform4i = loadProc("glUniform4i");
	api->UniformMatrix4x3fv = loadProc("glUniformMatrix4x3fv");
	api->GetAttribLocation = loadProc("glGetAttribLocation");
	api->GetShaderPrecisionFormat = loadProc("glGetShaderPrecisionFormat");
	api->Uniform4iv = loadProc("glUniform4iv");
	api->CompressedTexSubImage3D = loadProc("glCompressedTexSubImage3D");
	api->BindImageTextures = loadProc("glBindImageTextures");
	api->GetBufferParameteri64v = loadProc("glGetBufferParameteri64v");
	api->FrontFace = loadProc("glFrontFace");
	api->PopDebugGroup = loadProc("glPopDebugGroup");
	api->VertexAttrib1sv = loadProc("glVertexAttrib1sv");
	api->InvalidateBufferData = loadProc("glInvalidateBufferData");
	api->IsVertexArray = loadProc("glIsVertexArray");
	api->ScissorArrayv = loadProc("glScissorArrayv");
	api->ValidateProgram = loadProc("glValidateProgram");
	api->Uniform2uiv = loadProc("glUniform2uiv");
	api->TexSubImage2D = loadProc("glTexSubImage2D");
	api->DebugMessageControl = loadProc("glDebugMessageControl");
	api->FramebufferParameteri = loadProc("glFramebufferParameteri");
	api->GetUniformLocation = loadProc("glGetUniformLocation");
	api->TexStorage3D = loadProc("glTexStorage3D");
	api->PixelStoref = loadProc("glPixelStoref");
	api->DepthRangef = loadProc("glDepthRangef");
	api->VertexAttribI3i = loadProc("glVertexAttribI3i");
	api->Uniform1uiv = loadProc("glUniform1uiv");
	api->Disablei = loadProc("glDisablei");
	api->GetInternalformati64v = loadProc("glGetInternalformati64v");
	api->ProgramUniformMatrix2x3dv = loadProc("glProgramUniformMatrix2x3dv");
	api->GetProgramResourceIndex = loadProc("glGetProgramResourceIndex");
	api->BlendColor = loadProc("glBlendColor");
	api->GenSamplers = loadProc("glGenSamplers");
	api->ColorMaski = loadProc("glColorMaski");
	api->GetGraphicsResetStatus = mg_glGetGraphicsResetStatus_noimpl;
	api->VertexAttribI4uiv = loadProc("glVertexAttribI4uiv");
	api->CreateShaderProgramv = loadProc("glCreateShaderProgramv");
	api->DeleteSamplers = loadProc("glDeleteSamplers");
	api->VertexAttrib3s = loadProc("glVertexAttrib3s");
	api->DrawTransformFeedback = loadProc("glDrawTransformFeedback");
	api->VertexAttribL1d = loadProc("glVertexAttribL1d");
	api->DrawElementsInstancedBaseVertexBaseInstance = loadProc("glDrawElementsInstancedBaseVertexBaseInstance");
	api->ClearBufferSubData = loadProc("glClearBufferSubData");
	api->VertexAttribLFormat = loadProc("glVertexAttribLFormat");
	api->Uniform2dv = loadProc("glUniform2dv");
	api->CopyTexSubImage3D = loadProc("glCopyTexSubImage3D");
	api->CopyTexImage1D = loadProc("glCopyTexImage1D");
	api->FramebufferTexture3D = loadProc("glFramebufferTexture3D");
	api->VertexAttribL4d = loadProc("glVertexAttribL4d");
	api->UnmapBuffer = loadProc("glUnmapBuffer");
	api->GetQueryIndexediv = loadProc("glGetQueryIndexediv");
	api->FenceSync = loadProc("glFenceSync");
	api->DispatchComputeIndirect = loadProc("glDispatchComputeIndirect");
	api->SamplerParameterIuiv = loadProc("glSamplerParameterIuiv");
	api->GetFragDataLocation = loadProc("glGetFragDataLocation");
	api->GetUniformdv = loadProc("glGetUniformdv");
	api->TexImage3D = loadProc("glTexImage3D");
	api->ValidateProgramPipeline = loadProc("glValidateProgramPipeline");
	api->LinkProgram = loadProc("glLinkProgram");
	api->DeleteQueries = loadProc("glDeleteQueries");
	api->FramebufferTexture1D = loadProc("glFramebufferTexture1D");
	api->GetActiveSubroutineUniformName = loadProc("glGetActiveSubroutineUniformName");
	api->ProgramUniformMatrix3x2fv = loadProc("glProgramUniformMatrix3x2fv");
	api->GetTexParameteriv = loadProc("glGetTexParameteriv");
	api->ProvokingVertex = loadProc("glProvokingVertex");
	api->BindAttribLocation = loadProc("glBindAttribLocation");
	api->VertexAttrib3fv = loadProc("glVertexAttrib3fv");
	api->GetActiveUniformBlockName = loadProc("glGetActiveUniformBlockName");
	api->DrawArrays = loadProc("glDrawArrays");
	api->GetnUniformuiv = mg_glGetnUniformuiv_noimpl;
	api->ProgramUniform1uiv = loadProc("glProgramUniform1uiv");
	api->DrawElementsIndirect = loadProc("glDrawElementsIndirect");
	api->VertexAttribI4usv = loadProc("glVertexAttribI4usv");
	api->BlendEquationSeparatei = loadProc("glBlendEquationSeparatei");
	api->DrawElements = loadProc("glDrawElements");
	api->GetShaderSource = loadProc("glGetShaderSource");
	api->TransformFeedbackVaryings = loadProc("glTransformFeedbackVaryings");
	api->GetError = loadProc("glGetError");
	api->IsBuffer = loadProc("glIsBuffer");
	api->ClearBufferuiv = loadProc("glClearBufferuiv");
	api->GetVertexAttribiv = loadProc("glGetVertexAttribiv");
	api->GetProgramResourceName = loadProc("glGetProgramResourceName");
	api->Uniform2ui = loadProc("glUniform2ui");
	api->StencilFunc = loadProc("glStencilFunc");
	api->Enablei = loadProc("glEnablei");
	api->SamplerParameteriv = loadProc("glSamplerParameteriv");
	api->GetInteger64i_v = loadProc("glGetInteger64i_v");
	api->ProgramUniform4i = loadProc("glProgramUniform4i");
	api->Uniform4ui = loadProc("glUniform4ui");
	api->UniformMatrix2x4fv = loadProc("glUniformMatrix2x4fv");
	api->ReadnPixels = mg_glReadnPixels_noimpl;
	api->DrawTransformFeedbackInstanced = loadProc("glDrawTransformFeedbackInstanced");
	api->PointSize = loadProc("glPointSize");
	api->ProgramUniformMatrix4fv = loadProc("glProgramUniformMatrix4fv");
	api->ViewportArrayv = loadProc("glViewportArrayv");
	api->StencilOpSeparate = loadProc("glStencilOpSeparate");
	api->Uniform3ui = loadProc("glUniform3ui");
	api->Uniform4uiv = loadProc("glUniform4uiv");
	api->Uniform3iv = loadProc("glUniform3iv");
	api->Uniform4f = loadProc("glUniform4f");
	api->FramebufferTexture2D = loadProc("glFramebufferTexture2D");
	api->GetIntegeri_v = loadProc("glGetIntegeri_v");
	api->MultiDrawElements = loadProc("glMultiDrawElements");
	api->UniformMatrix4x2dv = loadProc("glUniformMatrix4x2dv");
	api->ProgramUniformMatrix2x3fv = loadProc("glProgramUniformMatrix2x3fv");
	api->CopyTexSubImage1D = loadProc("glCopyTexSubImage1D");
	api->TexSubImage3D = loadProc("glTexSubImage3D");
	api->GetActiveSubroutineUniformiv = loadProc("glGetActiveSubroutineUniformiv");
	api->GenProgramPipelines = loadProc("glGenProgramPipelines");
	api->ProgramUniform4iv = loadProc("glProgramUniform4iv");
	api->UniformMatrix3x4fv = loadProc("glUniformMatrix3x4fv");
	api->UniformBlockBinding = loadProc("glUniformBlockBinding");
	api->DepthRangeArrayv = loadProc("glDepthRangeArrayv");
	api->TexParameterfv = loadProc("glTexParameterfv");
	api->MapBuffer = loadProc("glMapBuffer");
	api->DeleteProgramPipelines = loadProc("glDeleteProgramPipelines");
	api->MinSampleShading = loadProc("glMinSampleShading");
	api->PauseTransformFeedback = loadProc("glPauseTransformFeedback");
	api->EndQueryIndexed = loadProc("glEndQueryIndexed");
	api->GetProgramBinary = loadProc("glGetProgramBinary");
	api->ProgramUniform2i = loadProc("glProgramUniform2i");
	api->DepthMask = loadProc("glDepthMask");
	api->ActiveTexture = loadProc("glActiveTexture");
	api->UseProgramStages = loadProc("glUseProgramStages");
	api->PatchParameterfv = loadProc("glPatchParameterfv");
	api->ShaderBinary = loadProc("glShaderBinary");
	api->GetFloatv = loadProc("glGetFloatv");
	api->ProgramUniform1f = loadProc("glProgramUniform1f");
	api->TexImage1D = loadProc("glTexImage1D");
	api->ProgramUniform2uiv = loadProc("glProgramUniform2uiv");
	api->ClearBufferData = loadProc("glClearBufferData");
	api->UniformMatrix3dv = loadProc("glUniformMatrix3dv");
	api->CompressedTexImage2D = loadProc("glCompressedTexImage2D");
	api->VertexAttrib4fv = loadProc("glVertexAttrib4fv");
	api->GetProgramResourceiv = loadProc("glGetProgramResourceiv");
	api->GetString = loadProc("glGetString");
	api->ProgramUniformMatrix2fv = loadProc("glProgramUniformMatrix2fv");
	api->GetVertexAttribLdv = loadProc("glGetVertexAttribLdv");
	api->VertexAttrib4Nubv = loadProc("glVertexAttrib4Nubv");
	api->TexBufferRange = loadProc("glTexBufferRange");
	api->UniformMatrix3x4dv = loadProc("glUniformMatrix3x4dv");
	api->GetProgramInterfaceiv = loadProc("glGetProgramInterfaceiv");
	api->TexParameterIuiv = loadProc("glTexParameterIuiv");
	api->DeleteShader = loadProc("glDeleteShader");
	api->GetFloati_v = loadProc("glGetFloati_v");
	api->DrawTransformFeedbackStreamInstanced = loadProc("glDrawTransformFeedbackStreamInstanced");
	api->VertexAttrib4s = loadProc("glVertexAttrib4s");
}

void mg_gl_load_gles31(mg_gl_api* api, mg_gl_load_proc loadProc)
{
	api->name = "gles31";
	api->PointParameterfv = mg_glPointParameterfv_noimpl;
	api->Uniform3fv = loadProc("glUniform3fv");
	api->Uniform1i = loadProc("glUniform1i");
	api->VertexAttribP3ui = mg_glVertexAttribP3ui_noimpl;
	api->VertexAttrib4sv = mg_glVertexAttrib4sv_noimpl;
	api->GetBufferParameteriv = loadProc("glGetBufferParameteriv");
	api->ProgramUniform2dv = mg_glProgramUniform2dv_noimpl;
	api->ClampColor = mg_glClampColor_noimpl;
	api->CompressedTexImage3D = loadProc("glCompressedTexImage3D");
	api->ProgramUniformMatrix2x4fv = loadProc("glProgramUniformMatrix2x4fv");
	api->ProgramUniform2d = mg_glProgramUniform2d_noimpl;
	api->BindBuffer = loadProc("glBindBuffer");
	api->GetUniformBlockIndex = loadProc("glGetUniformBlockIndex");
	api->InvalidateFramebuffer = loadProc("glInvalidateFramebuffer");
	api->PixelStorei = loadProc("glPixelStorei");
	api->BindTexture = loadProc("glBindTexture");
	api->VertexAttrib4Nuiv = mg_glVertexAttrib4Nuiv_noimpl;
	api->IsTexture = loadProc("glIsTexture");
	api->VertexAttrib4d = mg_glVertexAttrib4d_noimpl;
	api->ProgramUniformMatrix2x4dv = mg_glProgramUniformMatrix2x4dv_noimpl;
	api->GetObjectLabel = mg_glGetObjectLabel_noimpl;
	api->BeginConditionalRender = mg_glBeginConditionalRender_noimpl;
	api->IsFramebuffer = loadProc("glIsFramebuffer");
	api->CompileShader = loadProc("glCompileShader");
	api->VertexAttribBinding = loadProc("glVertexAttribBinding");
	api->VertexAttribL1dv = mg_glVertexAttribL1dv_noimpl;
	api->Uniform1fv = loadProc("glUniform1fv");
	api->TexImage2D = loadProc("glTexImage2D");
	api->Flush = loadProc("glFlush");
	api->VertexAttribP2uiv = mg_glVertexAttribP2uiv_noimpl;
	api->IsProgram = loadProc("glIsProgram");
	api->ProgramUniform4fv = loadProc("glProgramUniform4fv");
	api->VertexAttribLPointer = mg_glVertexAttribLPointer_noimpl;
	api->ClientWaitSync = loadProc("glClientWaitSync");
	api->Uniform1d = mg_glUniform1d_noimpl;
	api->ProgramUniform1ui = loadProc("glProgramUniform1ui");
	api->ColorMask = loadProc("glColorMask");
	api->ClearDepth = mg_glClearDepth_noimpl;
	api->GetInteger64v = loadProc("glGetInteger64v");
	api->VertexAttribP2ui = mg_glVertexAttribP2ui_noimpl;
	api->VertexAttrib2dv = mg_glVertexAttrib2dv_noimpl;
	api->VertexAttribI4ui = loadProc("glVertexAttribI4ui");
	api->BlendEquationi = mg_glBlendEquationi_noimpl;
	api->DrawRangeElements = loadProc("glDrawRangeElements");
	api->InvalidateTexImage = mg_glInvalidateTexImage_noimpl;
	api->SampleMaski = loadProc("glSampleMaski");
	api->GetProgramResourceLocationIndex = mg_glGetProgramResourceLocationIndex_noimpl;
	api->VertexAttrib4dv = mg_glVertexAttrib4dv_noimpl;
	api->BindFragDataLocation = mg_glBindFragDataLocation_noimpl;
	api->GetFragDataIndex = mg_glGetFragDataIndex_noimpl;
	api->GetTexLevelParameterfv = loadProc("glGetTexLevelParameterfv");
	api->VertexAttribP4uiv = mg_glVertexAttribP4uiv_noimpl;
	api->MultiDrawArrays = mg_glMultiDrawArrays_noimpl;
	api->IsTransformFeedback = loadProc("glIsTransformFeedback");
	api->GetUniformiv = loadProc("glGetUniformiv");
	api->BufferData = loadProc("glBufferData");
	api->GetCompressedTexImage = mg_glGetCompressedTexImage_noimpl;
	api->VertexAttrib3sv = mg_glVertexAttrib3sv_noimpl;
	api->IsQuery = loadProc("glIsQuery");
	api->ClearColor = loadProc("glClearColor");
	api->BlendFunc = loadProc("glBlendFunc");
	api->GetDoublei_v = mg_glGetDoublei_v_noimpl;
	api->FramebufferTexture = mg_glFramebufferTexture_noimpl;
	api->StencilMaskSeparate = loadProc("glStencilMaskSeparate");
	api->PrimitiveRestartIndex = mg_glPrimitiveRestartIndex_noimpl;
	api->VertexAttribP1ui = mg_glVertexAttribP1ui_noimpl;
	api->VertexAttribIFormat = loadProc("glVertexAttribIFormat");
	api->MemoryBarrier = loadProc("glMemoryBarrier");
	api->GetSubroutineUniformLocation = mg_glGetSubroutineUniformLocation_noimpl;
	api->BindRenderbuffer = loadProc("glBindRenderbuffer");
	api->PushDebugGroup = mg_glPushDebugGroup_noimpl;
	api->GenTextures = loadProc("glGenTextures");
	api->GetIntegerv = loadProc("glGetIntegerv");
	api->GetQueryObjectuiv = loadProc("glGetQueryObjectuiv");
	api->Uniform4fv = loadProc("glUniform4fv");
	api->Hint = loadProc("glHint");
	api->TexParameterf = loadProc("glTexParameterf");
	api->ProgramUniform2fv = loadProc("glProgramUniform2fv");
	api->DrawRangeElementsBaseVertex = mg_glDrawRangeElementsBaseVertex_noimpl;
	api->Clear = loadProc("glClear");
	api->BindBufferBase = loadProc("glBindBufferBase");
	api->GetQueryiv = loadProc("glGetQueryiv");
	api->ProgramBinary = loadProc("glProgramBinary");
	api->ScissorIndexedv = mg_glScissorIndexedv_noimpl;
	api->VertexAttrib1fv = loadProc("glVertexAttrib1fv");
	api->TexStorage2D = loadProc("glTexStorage2D");
	api->VertexAttrib4f = loadProc("glVertexAttrib4f");
	api->ProgramParameteri = loadProc("glProgramParameteri");
	api->Enable = loadProc("glEnable");
	api->GetBufferPointerv = loadProc("glGetBufferPointerv");
	api->LogicOp = mg_glLogicOp_noimpl;
	api->DepthFunc = loadProc("glDepthFunc");
	api->VertexAttrib1dv = mg_glVertexAttrib1dv_noimpl;
	api->Uniform2d = mg_glUniform2d_noimpl;
	api->DetachShader = loadProc("glDetachShader");
	api->VertexBindingDivisor = loadProc("glVertexBindingDivisor");
	api->IsProgramPipeline = loadProc("glIsProgramPipeline");
	api->ProgramUniform1fv = loadProc("glProgramUniform1fv");
	api->CopyTexSubImage2D = loadProc("glCopyTexSubImage2D");
	api->VertexAttrib2fv = loadProc("glVertexAttrib2fv");
	api->GetDoublev = mg_glGetDoublev_noimpl;
	api->ResumeTransformFeedback = loadProc("glResumeTransformFeedback");
	api->ProgramUniform4d = mg_glProgramUniform4d_noimpl;
	api->ProgramUniform4uiv = loadProc("glProgramUniform4uiv");
	api->DispatchCompute = loadProc("glDispatchCompute");
	api->VertexAttrib4bv = mg_glVertexAttrib4bv_noimpl;
	api->GetSamplerParameterfv = loadProc("glGetSamplerParameterfv");
	api->ProgramUniform3iv = loadProc("glProgramUniform3iv");
	api->VertexAttrib1s = mg_glVertexAttrib1s_noimpl;
	api->VertexAttribI2i = mg_glVertexAttribI2i_noimpl;
	api->SampleCoverage = loadProc("glSampleCoverage");
	api->BufferSubData = loadProc("glBufferSubData");
	api->VertexAttribI1ui = mg_glVertexAttribI1ui_noimpl;
	api->EndConditionalRender = mg_glEndConditionalRender_noimpl;
	api->GetPointerv = mg_glGetPointerv_noimpl;
	api->GetnUniformiv = mg_glGetnUniformiv_noimpl;
	api->BlendEquation = loadProc("glBlendEquation");
	api->VertexAttribI4iv = loadProc("glVertexAttribI4iv");
	api->GetnUniformfv = mg_glGetnUniformfv_noimpl;
	api->VertexAttrib4Nsv = mg_glVertexAttrib4Nsv_noimpl;
	api->Uniform2fv = loadProc("glUniform2fv");
	api->Uniform3f = loadProc("glUniform3f");
	api->GenerateMipmap = loadProc("glGenerateMipmap");
	api->GenRenderbuffers = loadProc("glGenRenderbuffers");
	api->DrawElementsBaseVertex = mg_glDrawElementsBaseVertex_noimpl;
	api->BindVertexBuffers = mg_glBindVertexBuffers_noimpl;
	api->Scissor = loadProc("glScissor");
	api->MapBufferRange = loadProc("glMapBufferRange");
	api->ProgramUniformMatrix4x2fv = loadProc("glProgramUniformMatrix4x2fv");
	api->GetTexParameterfv = loadProc("glGetTexParameterfv");
	api->Uniform2f = loadProc("glUniform2f");
	api->VertexAttribFormat = loadProc("glVertexAttribFormat");
	api->UniformMatrix2dv = mg_glUniformMatrix2dv_noimpl;
	api->IsEnabled = loadProc("glIsEnabled");
	api->ClearBufferfi = loadProc("glClearBufferfi");
	api->GetRenderbufferParameteriv = loadProc("glGetRenderbufferParameteriv");
	api->FramebufferTextureLayer = loadProc("glFramebufferTextureLayer");
	api->PointParameterf = mg_glPointParameterf_noimpl;
	api->GenVertexArrays = loadProc("glGenVertexArrays");
	api->GetAttachedShaders = loadProc("glGetAttachedShaders");
	api->FramebufferRenderbuffer = loadProc("glFramebufferRenderbuffer");
	api->DeleteTextures = loadProc("glDeleteTextures");
	api->BeginQuery = loadProc("glBeginQuery");
	api->Uniform4dv = mg_glUniform4dv_noimpl;
	api->VertexAttribIPointer = loadProc("glVertexAttribIPointer");
	api->GetSamplerParameterIiv = mg_glGetSamplerParameterIiv_noimpl;
	api->BeginQueryIndexed = mg_glBeginQueryIndexed_noimpl;
	api->BeginTransformFeedback = loadProc("glBeginTransformFeedback");
	api->Uniform3i = loadProc("glUniform3i");
	api->GetActiveUniformName = mg_glGetActiveUniformName_noimpl;
	api->GetProgramResourceLocation = loadProc("glGetProgramResourceLocation");
	api->ShaderSource = loadProc("glShaderSource");
	api->SamplerParameterIiv = mg_glSamplerParameterIiv_noimpl;
	api->Finish = loadProc("glFinish");
	api->DrawArraysInstancedBaseInstance = mg_glDrawArraysInstancedBaseInstance_noimpl;
	api->DeleteProgram = loadProc("glDeleteProgram");
	api->MultiDrawElementsBaseVertex = mg_glMultiDrawElementsBaseVertex_noimpl;
	api->ReadBuffer = loadProc("glReadBuffer");
	api->GenBuffers = loadProc("glGenBuffers");
	api->ClearDepthf = loadProc("glClearDepthf");
	api->VertexAttribPointer = loadProc("glVertexAttribPointer");
	api->VertexAttribL4dv = mg_glVertexAttribL4dv_noimpl;
	api->TexStorage2DMultisample = loadProc("glTexStorage2DMultisample");
	api->BindSamplers = mg_glBindSamplers_noimpl;
	api->EnableVertexAttribArray = loadProc("glEnableVertexAttribArray");
	api->VertexAttrib4ubv = mg_glVertexAttrib4ubv_noimpl;
	api->GetDebugMessageLog = mg_glGetDebugMessageLog_noimpl;
	api->DisableVertexAttribArray = loadProc("glDisableVertexAttribArray");
	api->DrawElementsInstancedBaseInstance = mg_glDrawElementsInstancedBaseInstance_noimpl;
	api->PolygonMode = mg_glPolygonMode_noimpl;
	api->VertexAttribP1uiv = mg_glVertexAttribP1uiv_noimpl;
	api->ProgramUniform1iv = loadProc("glProgramUniform1iv");
	api->VertexAttribI1i = mg_glVertexAttribI1i_noimpl;
	api->GetTexLevelParameteriv = loadProc("glGetTexLevelParameteriv");
	api->IsSync = loadProc("glIsSync");
	api->TexStorage1D = mg_glTexStorage1D_noimpl;
	api->GetVertexAttribIiv = loadProc("glGetVertexAttribIiv");
	api->IsEnabledi = mg_glIsEnabledi_noimpl;
	api->MultiDrawElementsIndirect = mg_glMultiDrawElementsIndirect_noimpl;
	api->GetBooleani_v = loadProc("glGetBooleani_v");
	api->GetInternalformativ = loadProc("glGetInternalformativ");
	api->VertexAttribI4ubv = mg_glVertexAttribI4ubv_noimpl;
	api->VertexAttrib2s = mg_glVertexAttrib2s_noimpl;
	api->GetBooleanv = loadProc("glGetBooleanv");
	api->VertexAttrib4iv = mg_glVertexAttrib4iv_noimpl;
	api->GetObjectPtrLabel = mg_glGetObjectPtrLabel_noimpl;
	api->UniformMatrix2x4dv = mg_glUniformMatrix2x4dv_noimpl;
	api->ProgramUniform4ui = loadProc("glProgramUniform4ui");
	api->GetVertexAttribdv = mg_glGetVertexAttribdv_noimpl;
	api->ViewportIndexedf = mg_glViewportIndexedf_noimpl;
	api->DeleteSync = loadProc("glDeleteSync");
	api->CopyImageSubData = mg_glCopyImageSubData_noimpl;
	api->PrimitiveBoundingBox = mg_glPrimitiveBoundingBox_noimpl;
	api->ScissorIndexed = mg_glScissorIndexed_noimpl;
	api->GenTransformFeedbacks = loadProc("glGenTransformFeedbacks");
	api->MemoryBarrierByRegion = loadProc("glMemoryBarrierByRegion");
	api->DeleteTransformFeedbacks = loadProc("glDeleteTransformFeedbacks");
	api->ProgramUniform4f = loadProc("glProgramUniform4f");
	api->BindBuffersBase = mg_glBindBuffersBase_noimpl;
	api->GetTexParameterIuiv = mg_glGetTexParameterIuiv_noimpl;
	api->IsShader = loadProc("glIsShader");
	api->ProgramUniform3i = loadProc("glProgramUniform3i");
	api->GetActiveAtomicCounterBufferiv = mg_glGetActiveAtomicCounterBufferiv_noimpl;
	api->ProgramUniformMatrix3x4fv = loadProc("glProgramUniformMatrix3x4fv");
	api->BufferStorage = mg_glBufferStorage_noimpl;
	api->GetUniformSubroutineuiv = mg_glGetUniformSubroutineuiv_noimpl;
	api->RenderbufferStorageMultisample = loadProc("glRenderbufferStorageMultisample");
	api->GetMultisamplefv = loadProc("glGetMultisamplefv");
	api->VertexAttribDivisor = loadProc("glVertexAttribDivisor");
	api->StencilMask = loadProc("glStencilMask");
	api->BindSampler = loadProc("glBindSampler");
	api->UniformMatrix4dv = mg_glUniformMatrix4dv_noimpl;
	api->BindImageTexture = loadProc("glBindImageTexture");
	api->DrawBuffers = loadProc("glDrawBuffers");
	api->VertexAttrib4Nub = mg_glVertexAttrib4Nub_noimpl;
	api->GetTexImage = mg_glGetTexImage_noimpl;
	api->VertexAttrib3dv = mg_glVertexAttrib3dv_noimpl;
	api->BlitFramebuffer = loadProc("glBlitFramebuffer");
	api->VertexAttrib2d = mg_glVertexAttrib2d_noimpl;
	api->Uniform1ui = loadProc("glUniform1ui");
	api->InvalidateBufferSubData = mg_glInvalidateBufferSubData_noimpl;
	api->EndQuery = loadProc("glEndQuery");
	api->GetUniformuiv = loadProc("glGetUniformuiv");
	api->GetFramebufferAttachmentParameteriv = loadProc("glGetFramebufferAttachmentParameteriv");
	api->ProgramUniform2f = loadProc("glProgramUniform2f");
	api->UniformMatrix3x2fv = loadProc("glUniformMatrix3x2fv");
	api->BindVertexBuffer = loadProc("glBindVertexBuffer");
	api->VertexAttrib2sv = mg_glVertexAttrib2sv_noimpl;
	api->Uniform1f = loadProc("glUniform1f");
	api->DebugMessageCallback = mg_glDebugMessageCallback_noimpl;
	api->ReadPixels = loadProc("glReadPixels");
	api->CompressedTexSubImage1D = mg_glCompressedTexSubImage1D_noimpl;
	api->DrawArraysIndirect = loadProc("glDrawArraysIndirect");
	api->BlendFuncSeparate = loadProc("glBlendFuncSeparate");
	api->CreateShader = loadProc("glCreateShader");
	api->GetTransformFeedbackVarying = loadProc("glGetTransformFeedbackVarying");
	api->AttachShader = loadProc("glAttachShader");
	api->UniformMatrix2x3dv = mg_glUniformMatrix2x3dv_noimpl;
	api->ProgramUniform3uiv = loadProc("glProgramUniform3uiv");
	api->MultiDrawArraysIndirect = mg_glMultiDrawArraysIndirect_noimpl;
	api->Uniform2iv = loadProc("glUniform2iv");
	api->BindBufferRange = loadProc("glBindBufferRange");
	api->TexParameteriv = loadProc("glTexParameteriv");
	api->VertexAttribL3d = mg_glVertexAttribL3d_noimpl;
	api->TexImage3DMultisample = mg_glTexImage3DMultisample_noimpl;
	api->ClearTexSubImage = mg_glClearTexSubImage_noimpl;
	api->VertexAttrib4Nusv = mg_glVertexAttrib4Nusv_noimpl;
	api->InvalidateSubFramebuffer = loadProc("glInvalidateSubFramebuffer");
	api->GetShaderInfoLog = loadProc("glGetShaderInfoLog");
	api->VertexAttribP4ui = mg_glVertexAttribP4ui_noimpl;
	api->Viewport = loadProc("glViewport");
	api->BlendFunci = mg_glBlendFunci_noimpl;
	api->PolygonOffset = loadProc("glPolygonOffset");
	api->ProgramUniform2ui = loadProc("glProgramUniform2ui");
	api->SamplerParameteri = loadProc("glSamplerParameteri");
	api->GetFramebufferParameteriv = loadProc("glGetFramebufferParameteriv");
	api->VertexAttribI2iv = mg_glVertexAttribI2iv_noimpl;
	api->ObjectLabel = mg_glObjectLabel_noimpl;
	api->CompressedTexImage1D = mg_glCompressedTexImage1D_noimpl;
	api->InvalidateTexSubImage = mg_glInvalidateTexSubImage_noimpl;
	api->BindBuffersRange = mg_glBindBuffersRange_noimpl;
	api->CopyBufferSubData = loadProc("glCopyBufferSubData");
	api->VertexAttrib4Nbv = mg_glVertexAttrib4Nbv_noimpl;
	api->ObjectPtrLabel = mg_glObjectPtrLabel_noimpl;
	api->ProgramUniform3d = mg_glProgramUniform3d_noimpl;
	api->GetProgramPipelineiv = loadProc("glGetProgramPipelineiv");
	api->TexStorage3DMultisample = mg_glTexStorage3DMultisample_noimpl;
	api->VertexAttribL3dv = mg_glVertexAttribL3dv_noimpl;
	api->DeleteFramebuffers = loadProc("glDeleteFramebuffers");
	api->CheckFramebufferStatus = loadProc("glCheckFramebufferStatus");
	api->VertexAttribL2dv = mg_glVertexAttribL2dv_noimpl;
	api->ProgramUniform1dv = mg_glProgramUniform1dv_noimpl;
	api->VertexAttrib2f = loadProc("glVertexAttrib2f");
	api->GetVertexAttribIuiv = loadProc("glGetVertexAttribIuiv");
	api->StencilOp = loadProc("glStencilOp");
	api->VertexAttrib3d = mg_glVertexAttrib3d_noimpl;
	api->PointParameteri = mg_glPointParameteri_noimpl;
	api->VertexAttribI1uiv = mg_glVertexAttribI1uiv_noimpl;
	api->ClearBufferfv = loadProc("glClearBufferfv");
	api->BindFragDataLocationIndexed = mg_glBindFragDataLocationIndexed_noimpl;
	api->ProgramUniform1d = mg_glProgramUniform1d_noimpl;
	api->PointParameteriv = mg_glPointParameteriv_noimpl;
	api->FlushMappedBufferRange = loadProc("glFlushMappedBufferRange");
	api->TextureView = mg_glTextureView_noimpl;
	api->GetProgramPipelineInfoLog = loadProc("glGetProgramPipelineInfoLog");
	api->CopyTexImage2D = loadProc("glCopyTexImage2D");
	api->ProgramUniform3dv = mg_glProgramUniform3dv_noimpl;
	api->QueryCounter = mg_glQueryCounter_noimpl;
	api->GetUniformfv = loadProc("glGetUniformfv");
	api->ClearStencil = loadProc("glClearStencil");
	api->GetProgramiv = loadProc("glGetProgramiv");
	api->UniformSubroutinesuiv = mg_glUniformSubroutinesuiv_noimpl;
	api->GetProgramStageiv = mg_glGetProgramStageiv_noimpl;
	api->Uniform1iv = loadProc("glUniform1iv");
	api->GetVertexAttribPointerv = loadProc("glGetVertexAttribPointerv");
	api->TexSubImage1D = mg_glTexSubImage1D_noimpl;
	api->StencilFuncSeparate = loadProc("glStencilFuncSeparate");
	api->GetSubroutineIndex = mg_glGetSubroutineIndex_noimpl;
	api->DrawElementsInstanced = loadProc("glDrawElementsInstanced");
	api->BlendFuncSeparatei = mg_glBlendFuncSeparatei_noimpl;
	api->ProgramUniformMatrix3x2dv = mg_glProgramUniformMatrix3x2dv_noimpl;
	api->GetActiveUniformsiv = loadProc("glGetActiveUniformsiv");
	api->UniformMatrix3fv = loadProc("glUniformMatrix3fv");
	api->ProgramUniformMatrix3x4dv = mg_glProgramUniformMatrix3x4dv_noimpl;
	api->GetSamplerParameterIuiv = mg_glGetSamplerParameterIuiv_noimpl;
	api->VertexAttribI4i = loadProc("glVertexAttribI4i");
	api->BlendEquationSeparate = loadProc("glBlendEquationSeparate");
	api->UniformMatrix4x2fv = loadProc("glUniformMatrix4x2fv");
	api->TexParameterIiv = mg_glTexParameterIiv_noimpl;
	api->DrawTransformFeedbackStream = mg_glDrawTransformFeedbackStream_noimpl;
	api->VertexAttribI1iv = mg_glVertexAttribI1iv_noimpl;
	api->GetUniformIndices = loadProc("glGetUniformIndices");
	api->GetShaderiv = loadProc("glGetShaderiv");
	api->GetActiveUniform = loadProc("glGetActiveUniform");
	api->Uniform3uiv = loadProc("glUniform3uiv");
	api->PatchParameteri = mg_glPatchParameteri_noimpl;
	api->ProgramUniformMatrix2dv = mg_glProgramUniformMatrix2dv_noimpl;
	api->WaitSync = loadProc("glWaitSync");
	api->ClearTexImage = mg_glClearTexImage_noimpl;
	api->DepthRangeIndexed = mg_glDepthRangeIndexed_noimpl;
	api->GetTexParameterIiv = mg_glGetTexParameterIiv_noimpl;
	api->DepthRange = mg_glDepthRange_noimpl;
	api->GetActiveAttrib = loadProc("glGetActiveAttrib");
	api->IsRenderbuffer = loadProc("glIsRenderbuffer");
	api->ClearBufferiv = loadProc("glClearBufferiv");
	api->ProgramUniform3fv = loadProc("glProgramUniform3fv");
	api->VertexAttribI3uiv = mg_glVertexAttribI3uiv_noimpl;
	api->UseProgram = loadProc("glUseProgram");
	api->GetActiveSubroutineName = mg_glGetActiveSubroutineName_noimpl;
	api->ProgramUniformMatrix3fv = loadProc("glProgramUniformMatrix3fv");
	api->ProgramUniformMatrix4x3dv = mg_glProgramUniformMatrix4x3dv_noimpl;
	api->UniformMatrix4x3dv = mg_glUniformMatrix4x3dv_noimpl;
	api->ProgramUniform4dv = mg_glProgramUniform4dv_noimpl;
	api->GetBufferSubData = mg_glGetBufferSubData_noimpl;
	api->VertexAttrib4uiv = mg_glVertexAttrib4uiv_noimpl;
	api->VertexAttrib1f = loadProc("glVertexAttrib1f");
	api->VertexAttrib4usv = mg_glVertexAttrib4usv_noimpl;
	api->DebugMessageInsert = mg_glDebugMessageInsert_noimpl;
	api->EndTransformFeedback = loadProc("glEndTransformFeedback");
	api->TexImage2DMultisample = mg_glTexImage2DMultisample_noimpl;
	api->BindTransformFeedback = loadProc("glBindTransformFeedback");
	api->Uniform3dv = mg_glUniform3dv_noimpl;
	api->UniformMatrix3x2dv = mg_glUniformMatrix3x2dv_noimpl;
	api->GetSamplerParameteriv = loadProc("glGetSamplerParameteriv");
	api->VertexAttribP3uiv = mg_glVertexAttribP3uiv_noimpl;
	api->Uniform4d = mg_glUniform4d_noimpl;
	api->ProgramUniformMatrix3dv = mg_glProgramUniformMatrix3dv_noimpl;
	api->ProgramUniform3ui = loadProc("glProgramUniform3ui");
	api->DeleteVertexArrays = loadProc("glDeleteVertexArrays");
	api->TexParameteri = loadProc("glTexParameteri");
	api->DrawElementsInstancedBaseVertex = mg_glDrawElementsInstancedBaseVertex_noimpl;
	api->GetQueryObjectui64v = mg_glGetQueryObjectui64v_noimpl;
	api->VertexAttrib4Niv = mg_glVertexAttrib4Niv_noimpl;
	api->SamplerParameterfv = loadProc("glSamplerParameterfv");
	api->VertexAttribI4bv = mg_glVertexAttribI4bv_noimpl;
	api->ProgramUniform1i = loadProc("glProgramUniform1i");
	api->ProgramUniformMatrix4x2dv = mg_glProgramUniformMatrix4x2dv_noimpl;
	api->GetSynciv = loadProc("glGetSynciv");
	api->VertexAttrib3f = loadProc("glVertexAttrib3f");
	api->GetQueryObjectiv = mg_glGetQueryObjectiv_noimpl;
	api->GetProgramInfoLog = loadProc("glGetProgramInfoLog");
	api->GetActiveUniformBlockiv = loadProc("glGetActiveUniformBlockiv");
	api->GenQueries = loadProc("glGenQueries");
	api->ProgramUniformMatrix4x3fv = loadProc("glProgramUniformMatrix4x3fv");
	api->TexBuffer = mg_glTexBuffer_noimpl;
	api->ShaderStorageBlockBinding = mg_glShaderStorageBlockBinding_noimpl;
	api->Disable = loadProc("glDisable");
	api->VertexAttribI3ui = mg_glVertexAttribI3ui_noimpl;
	api->IsSampler = loadProc("glIsSampler");
	api->ActiveShaderProgram = loadProc("glActiveShaderProgram");
	api->BindVertexArray = loadProc("glBindVertexArray");
	api->UniformMatrix2x3fv = loadProc("glUniformMatrix2x3fv");
	api->DrawArraysInstanced = loadProc("glDrawArraysInstanced");
	api->VertexAttribI2uiv = mg_glVertexAttribI2uiv_noimpl;
	api->GetQueryObjecti64v = mg_glGetQueryObjecti64v_noimpl;
	api->GetStringi = loadProc("glGetStringi");
	api->BindProgramPipeline = loadProc("glBindProgramPipeline");
	api->BindFramebuffer = loadProc("glBindFramebuffer");
	api->VertexAttrib1d = mg_glVertexAttrib1d_noimpl;
	api->RenderbufferStorage = loadProc("glRenderbufferStorage");
	api->ReleaseShaderCompiler = loadProc("glReleaseShaderCompiler");
	api->Uniform2i = loadProc("glUniform2i");
	api->DrawBuffer = mg_glDrawBuffer_noimpl;
	api->DeleteRenderbuffers = loadProc("glDeleteRenderbuffers");
	api->DeleteBuffers = loadProc("glDeleteBuffers");
	api->GenFramebuffers = loadProc("glGenFramebuffers");
	api->ProgramUniformMatrix4dv = mg_glProgramUniformMatrix4dv_noimpl;
	api->ProgramUniform3f = loadProc("glProgramUniform3f");
	api->ProgramUniform2iv = loadProc("glProgramUniform2iv");
	api->BlendBarrier = mg_glBlendBarrier_noimpl;
	api->VertexAttribL2d = mg_glVertexAttribL2d_noimpl;
	api->CompressedTexSubImage2D = loadProc("glCompressedTexSubImage2D");
	api->UniformMatrix2fv = loadProc("glUniformMatrix2fv");
	api->SamplerParameterf = loadProc("glSamplerParameterf");
	api->UniformMatrix4fv = loadProc("glUniformMatrix4fv");
	api->VertexAttribI2ui = mg_glVertexAttribI2ui_noimpl;
	api->BindTextures = mg_glBindTextures_noimpl;
	api->Uniform3d = mg_glUniform3d_noimpl;
	api->ViewportIndexedfv = mg_glViewportIndexedfv_noimpl;
	api->VertexAttribI4sv = mg_glVertexAttribI4sv_noimpl;
	api->LineWidth = loadProc("glLineWidth");
	api->GetVertexAttribfv = loadProc("glGetVertexAttribfv");
	api->VertexAttribI3iv = mg_glVertexAttribI3iv_noimpl;
	api->Uniform1dv = mg_glUniform1dv_noimpl;
	api->CullFace = loadProc("glCullFace");
	api->CreateProgram = loadProc("glCreateProgram");
	api->Uniform4i = loadProc("glUniform4i");
	api->UniformMatrix4x3fv = loadProc("glUniformMatrix4x3fv");
	api->GetAttribLocation = loadProc("glGetAttribLocation");
	api->GetShaderPrecisionFormat = loadProc("glGetShaderPrecisionFormat");
	api->Uniform4iv = loadProc("glUniform4iv");
	api->CompressedTexSubImage3D = loadProc("glCompressedTexSubImage3D");
	api->BindImageTextures = mg_glBindImageTextures_noimpl;
	api->GetBufferParameteri64v = loadProc("glGetBufferParameteri64v");
	api->FrontFace = loadProc("glFrontFace");
	api->PopDebugGroup = mg_glPopDebugGroup_noimpl;
	api->VertexAttrib1sv = mg_glVertexAttrib1sv_noimpl;
	api->InvalidateBufferData = mg_glInvalidateBufferData_noimpl;
	api->IsVertexArray = loadProc("glIsVertexArray");
	api->ScissorArrayv = mg_glScissorArrayv_noimpl;
	api->ValidateProgram = loadProc("glValidateProgram");
	api->Uniform2uiv = loadProc("glUniform2uiv");
	api->TexSubImage2D = loadProc("glTexSubImage2D");
	api->DebugMessageControl = mg_glDebugMessageControl_noimpl;
	api->FramebufferParameteri = loadProc("glFramebufferParameteri");
	api->GetUniformLocation = loadProc("glGetUniformLocation");
	api->TexStorage3D = loadProc("glTexStorage3D");
	api->PixelStoref = mg_glPixelStoref_noimpl;
	api->DepthRangef = loadProc("glDepthRangef");
	api->VertexAttribI3i = mg_glVertexAttribI3i_noimpl;
	api->Uniform1uiv = loadProc("glUniform1uiv");
	api->Disablei = mg_glDisablei_noimpl;
	api->GetInternalformati64v = mg_glGetInternalformati64v_noimpl;
	api->ProgramUniformMatrix2x3dv = mg_glProgramUniformMatrix2x3dv_noimpl;
	api->GetProgramResourceIndex = loadProc("glGetProgramResourceIndex");
	api->BlendColor = loadProc("glBlendColor");
	api->GenSamplers = loadProc("glGenSamplers");
	api->ColorMaski = mg_glColorMaski_noimpl;
	api->GetGraphicsResetStatus = mg_glGetGraphicsResetStatus_noimpl;
	api->VertexAttribI4uiv = loadProc("glVertexAttribI4uiv");
	api->CreateShaderProgramv = loadProc("glCreateShaderProgramv");
	api->DeleteSamplers = loadProc("glDeleteSamplers");
	api->VertexAttrib3s = mg_glVertexAttrib3s_noimpl;
	api->DrawTransformFeedback = mg_glDrawTransformFeedback_noimpl;
	api->VertexAttribL1d = mg_glVertexAttribL1d_noimpl;
	api->DrawElementsInstancedBaseVertexBaseInstance = mg_glDrawElementsInstancedBaseVertexBaseInstance_noimpl;
	api->ClearBufferSubData = mg_glClearBufferSubData_noimpl;
	api->VertexAttribLFormat = mg_glVertexAttribLFormat_noimpl;
	api->Uniform2dv = mg_glUniform2dv_noimpl;
	api->CopyTexSubImage3D = loadProc("glCopyTexSubImage3D");
	api->CopyTexImage1D = mg_glCopyTexImage1D_noimpl;
	api->FramebufferTexture3D = mg_glFramebufferTexture3D_noimpl;
	api->VertexAttribL4d = mg_glVertexAttribL4d_noimpl;
	api->UnmapBuffer = loadProc("glUnmapBuffer");
	api->GetQueryIndexediv = mg_glGetQueryIndexediv_noimpl;
	api->FenceSync = loadProc("glFenceSync");
	api->DispatchComputeIndirect = loadProc("glDispatchComputeIndirect");
	api->SamplerParameterIuiv = mg_glSamplerParameterIuiv_noimpl;
	api->GetFragDataLocation = loadProc("glGetFragDataLocation");
	api->GetUniformdv = mg_glGetUniformdv_noimpl;
	api->TexImage3D = loadProc("glTexImage3D");
	api->ValidateProgramPipeline = loadProc("glValidateProgramPipeline");
	api->LinkProgram = loadProc("glLinkProgram");
	api->DeleteQueries = loadProc("glDeleteQueries");
	api->FramebufferTexture1D = mg_glFramebufferTexture1D_noimpl;
	api->GetActiveSubroutineUniformName = mg_glGetActiveSubroutineUniformName_noimpl;
	api->ProgramUniformMatrix3x2fv = loadProc("glProgramUniformMatrix3x2fv");
	api->GetTexParameteriv = loadProc("glGetTexParameteriv");
	api->ProvokingVertex = mg_glProvokingVertex_noimpl;
	api->BindAttribLocation = loadProc("glBindAttribLocation");
	api->VertexAttrib3fv = loadProc("glVertexAttrib3fv");
	api->GetActiveUniformBlockName = loadProc("glGetActiveUniformBlockName");
	api->DrawArrays = loadProc("glDrawArrays");
	api->GetnUniformuiv = mg_glGetnUniformuiv_noimpl;
	api->ProgramUniform1uiv = loadProc("glProgramUniform1uiv");
	api->DrawElementsIndirect = loadProc("glDrawElementsIndirect");
	api->VertexAttribI4usv = mg_glVertexAttribI4usv_noimpl;
	api->BlendEquationSeparatei = mg_glBlendEquationSeparatei_noimpl;
	api->DrawElements = loadProc("glDrawElements");
	api->GetShaderSource = loadProc("glGetShaderSource");
	api->TransformFeedbackVaryings = loadProc("glTransformFeedbackVaryings");
	api->GetError = loadProc("glGetError");
	api->IsBuffer = loadProc("glIsBuffer");
	api->ClearBufferuiv = loadProc("glClearBufferuiv");
	api->GetVertexAttribiv = loadProc("glGetVertexAttribiv");
	api->GetProgramResourceName = loadProc("glGetProgramResourceName");
	api->Uniform2ui = loadProc("glUniform2ui");
	api->StencilFunc = loadProc("glStencilFunc");
	api->Enablei = mg_glEnablei_noimpl;
	api->SamplerParameteriv = loadProc("glSamplerParameteriv");
	api->GetInteger64i_v = loadProc("glGetInteger64i_v");
	api->ProgramUniform4i = loadProc("glProgramUniform4i");
	api->Uniform4ui = loadProc("glUniform4ui");
	api->UniformMatrix2x4fv = loadProc("glUniformMatrix2x4fv");
	api->ReadnPixels = mg_glReadnPixels_noimpl;
	api->DrawTransformFeedbackInstanced = mg_glDrawTransformFeedbackInstanced_noimpl;
	api->PointSize = mg_glPointSize_noimpl;
	api->ProgramUniformMatrix4fv = loadProc("glProgramUniformMatrix4fv");
	api->ViewportArrayv = mg_glViewportArrayv_noimpl;
	api->StencilOpSeparate = loadProc("glStencilOpSeparate");
	api->Uniform3ui = loadProc("glUniform3ui");
	api->Uniform4uiv = loadProc("glUniform4uiv");
	api->Uniform3iv = loadProc("glUniform3iv");
	api->Uniform4f = loadProc("glUniform4f");
	api->FramebufferTexture2D = loadProc("glFramebufferTexture2D");
	api->GetIntegeri_v = loadProc("glGetIntegeri_v");
	api->MultiDrawElements = mg_glMultiDrawElements_noimpl;
	api->UniformMatrix4x2dv = mg_glUniformMatrix4x2dv_noimpl;
	api->ProgramUniformMatrix2x3fv = loadProc("glProgramUniformMatrix2x3fv");
	api->CopyTexSubImage1D = mg_glCopyTexSubImage1D_noimpl;
	api->TexSubImage3D = loadProc("glTexSubImage3D");
	api->GetActiveSubroutineUniformiv = mg_glGetActiveSubroutineUniformiv_noimpl;
	api->GenProgramPipelines = loadProc("glGenProgramPipelines");
	api->ProgramUniform4iv = loadProc("glProgramUniform4iv");
	api->UniformMatrix3x4fv = loadProc("glUniformMatrix3x4fv");
	api->UniformBlockBinding = loadProc("glUniformBlockBinding");
	api->DepthRangeArrayv = mg_glDepthRangeArrayv_noimpl;
	api->TexParameterfv = loadProc("glTexParameterfv");
	api->MapBuffer = mg_glMapBuffer_noimpl;
	api->DeleteProgramPipelines = loadProc("glDeleteProgramPipelines");
	api->MinSampleShading = mg_glMinSampleShading_noimpl;
	api->PauseTransformFeedback = loadProc("glPauseTransformFeedback");
	api->EndQueryIndexed = mg_glEndQueryIndexed_noimpl;
	api->GetProgramBinary = loadProc("glGetProgramBinary");
	api->ProgramUniform2i = loadProc("glProgramUniform2i");
	api->DepthMask = loadProc("glDepthMask");
	api->ActiveTexture = loadProc("glActiveTexture");
	api->UseProgramStages = loadProc("glUseProgramStages");
	api->PatchParameterfv = mg_glPatchParameterfv_noimpl;
	api->ShaderBinary = loadProc("glShaderBinary");
	api->GetFloatv = loadProc("glGetFloatv");
	api->ProgramUniform1f = loadProc("glProgramUniform1f");
	api->TexImage1D = mg_glTexImage1D_noimpl;
	api->ProgramUniform2uiv = loadProc("glProgramUniform2uiv");
	api->ClearBufferData = mg_glClearBufferData_noimpl;
	api->UniformMatrix3dv = mg_glUniformMatrix3dv_noimpl;
	api->CompressedTexImage2D = loadProc("glCompressedTexImage2D");
	api->VertexAttrib4fv = loadProc("glVertexAttrib4fv");
	api->GetProgramResourceiv = loadProc("glGetProgramResourceiv");
	api->GetString = loadProc("glGetString");
	api->ProgramUniformMatrix2fv = loadProc("glProgramUniformMatrix2fv");
	api->GetVertexAttribLdv = mg_glGetVertexAttribLdv_noimpl;
	api->VertexAttrib4Nubv = mg_glVertexAttrib4Nubv_noimpl;
	api->TexBufferRange = mg_glTexBufferRange_noimpl;
	api->UniformMatrix3x4dv = mg_glUniformMatrix3x4dv_noimpl;
	api->GetProgramInterfaceiv = loadProc("glGetProgramInterfaceiv");
	api->TexParameterIuiv = mg_glTexParameterIuiv_noimpl;
	api->DeleteShader = loadProc("glDeleteShader");
	api->GetFloati_v = mg_glGetFloati_v_noimpl;
	api->DrawTransformFeedbackStreamInstanced = mg_glDrawTransformFeedbackStreamInstanced_noimpl;
	api->VertexAttrib4s = mg_glVertexAttrib4s_noimpl;
}

void mg_gl_load_gles32(mg_gl_api* api, mg_gl_load_proc loadProc)
{
	api->name = "gles32";
	api->PointParameterfv = mg_glPointParameterfv_noimpl;
	api->Uniform3fv = loadProc("glUniform3fv");
	api->Uniform1i = loadProc("glUniform1i");
	api->VertexAttribP3ui = mg_glVertexAttribP3ui_noimpl;
	api->VertexAttrib4sv = mg_glVertexAttrib4sv_noimpl;
	api->GetBufferParameteriv = loadProc("glGetBufferParameteriv");
	api->ProgramUniform2dv = mg_glProgramUniform2dv_noimpl;
	api->ClampColor = mg_glClampColor_noimpl;
	api->CompressedTexImage3D = loadProc("glCompressedTexImage3D");
	api->ProgramUniformMatrix2x4fv = loadProc("glProgramUniformMatrix2x4fv");
	api->ProgramUniform2d = mg_glProgramUniform2d_noimpl;
	api->BindBuffer = loadProc("glBindBuffer");
	api->GetUniformBlockIndex = loadProc("glGetUniformBlockIndex");
	api->InvalidateFramebuffer = loadProc("glInvalidateFramebuffer");
	api->PixelStorei = loadProc("glPixelStorei");
	api->BindTexture = loadProc("glBindTexture");
	api->VertexAttrib4Nuiv = mg_glVertexAttrib4Nuiv_noimpl;
	api->IsTexture = loadProc("glIsTexture");
	api->VertexAttrib4d = mg_glVertexAttrib4d_noimpl;
	api->ProgramUniformMatrix2x4dv = mg_glProgramUniformMatrix2x4dv_noimpl;
	api->GetObjectLabel = loadProc("glGetObjectLabel");
	api->BeginConditionalRender = mg_glBeginConditionalRender_noimpl;
	api->IsFramebuffer = loadProc("glIsFramebuffer");
	api->CompileShader = loadProc("glCompileShader");
	api->VertexAttribBinding = loadProc("glVertexAttribBinding");
	api->VertexAttribL1dv = mg_glVertexAttribL1dv_noimpl;
	api->Uniform1fv = loadProc("glUniform1fv");
	api->TexImage2D = loadProc("glTexImage2D");
	api->Flush = loadProc("glFlush");
	api->VertexAttribP2uiv = mg_glVertexAttribP2uiv_noimpl;
	api->IsProgram = loadProc("glIsProgram");
	api->ProgramUniform4fv = loadProc("glProgramUniform4fv");
	api->VertexAttribLPointer = mg_glVertexAttribLPointer_noimpl;
	api->ClientWaitSync = loadProc("glClientWaitSync");
	api->Uniform1d = mg_glUniform1d_noimpl;
	api->ProgramUniform1ui = loadProc("glProgramUniform1ui");
	api->ColorMask = loadProc("glColorMask");
	api->ClearDepth = mg_glClearDepth_noimpl;
	api->GetInteger64v = loadProc("glGetInteger64v");
	api->VertexAttribP2ui = mg_glVertexAttribP2ui_noimpl;
	api->VertexAttrib2dv = mg_glVertexAttrib2dv_noimpl;
	api->VertexAttribI4ui = loadProc("glVertexAttribI4ui");
	api->BlendEquationi = loadProc("glBlendEquationi");
	api->DrawRangeElements = loadProc("glDrawRangeElements");
	api->InvalidateTexImage = mg_glInvalidateTexImage_noimpl;
	api->SampleMaski = loadProc("glSampleMaski");
	api->GetProgramResourceLocationIndex = mg_glGetProgramResourceLocationIndex_noimpl;
	api->VertexAttrib4dv = mg_glVertexAttrib4dv_noimpl;
	api->BindFragDataLocation = mg_glBindFragDataLocation_noimpl;
	api->GetFragDataIndex = mg_glGetFragDataIndex_noimpl;
	api->GetTexLevelParameterfv = loadProc("glGetTexLevelParameterfv");
	api->VertexAttribP4uiv = mg_glVertexAttribP4uiv_noimpl;
	api->MultiDrawArrays = mg_glMultiDrawArrays_noimpl;
	api->IsTransformFeedback = loadProc("glIsTransformFeedback");
	api->GetUniformiv = loadProc("glGetUniformiv");
	api->BufferData = loadProc("glBufferData");
	api->GetCompressedTexImage = mg_glGetCompressedTexImage_noimpl;
	api->VertexAttrib3sv = mg_glVertexAttrib3sv_noimpl;
	api->IsQuery = loadProc("glIsQuery");
	api->ClearColor = loadProc("glClearColor");
	api->BlendFunc = loadProc("glBlendFunc");
	api->GetDoublei_v = mg_glGetDoublei_v_noimpl;
	api->FramebufferTexture = loadProc("glFramebufferTexture");
	api->StencilMaskSeparate = loadProc("glStencilMaskSeparate");
	api->PrimitiveRestartIndex = mg_glPrimitiveRestartIndex_noimpl;
	api->VertexAttribP1ui = mg_glVertexAttribP1ui_noimpl;
	api->VertexAttribIFormat = loadProc("glVertexAttribIFormat");
	api->MemoryBarrier = loadProc("glMemoryBarrier");
	api->GetSubroutineUniformLocation = mg_glGetSubroutineUniformLocation_noimpl;
	api->BindRenderbuffer = loadProc("glBindRenderbuffer");
	api->PushDebugGroup = loadProc("glPushDebugGroup");
	api->GenTextures = loadProc("glGenTextures");
	api->GetIntegerv = loadProc("glGetIntegerv");
	api->GetQueryObjectuiv = loadProc("glGetQueryObjectuiv");
	api->Uniform4fv = loadProc("glUniform4fv");
	api->Hint = loadProc("glHint");
	api->TexParameterf = loadProc("glTexParameterf");
	api->ProgramUniform2fv = loadProc("glProgramUniform2fv");
	api->DrawRangeElementsBaseVertex = loadProc("glDrawRangeElementsBaseVertex");
	api->Clear = loadProc("glClear");
	api->BindBufferBase = loadProc("glBindBufferBase");
	api->GetQueryiv = loadProc("glGetQueryiv");
	api->ProgramBinary = loadProc("glProgramBinary");
	api->ScissorIndexedv = mg_glScissorIndexedv_noimpl;
	api->VertexAttrib1fv = loadProc("glVertexAttrib1fv");
	api->TexStorage2D = loadProc("glTexStorage2D");
	api->VertexAttrib4f = loadProc("glVertexAttrib4f");
	api->ProgramParameteri = loadProc("glProgramParameteri");
	api->Enable = loadProc("glEnable");
	api->GetBufferPointerv = loadProc("glGetBufferPointerv");
	api->LogicOp = mg_glLogicOp_noimpl;
	api->DepthFunc = loadProc("glDepthFunc");
	api->VertexAttrib1dv = mg_glVertexAttrib1dv_noimpl;
	api->Uniform2d = mg_glUniform2d_noimpl;
	api->DetachShader = loadProc("glDetachShader");
	api->VertexBindingDivisor = loadProc("glVertexBindingDivisor");
	api->IsProgramPipeline = loadProc("glIsProgramPipeline");
	api->ProgramUniform1fv = loadProc("glProgramUniform1fv");
	api->CopyTexSubImage2D = loadProc("glCopyTexSubImage2D");
	api->VertexAttrib2fv = loadProc("glVertexAttrib2fv");
	api->GetDoublev = mg_glGetDoublev_noimpl;
	api->ResumeTransformFeedback = loadProc("glResumeTransformFeedback");
	api->ProgramUniform4d = mg_glProgramUniform4d_noimpl;
	api->ProgramUniform4uiv = loadProc("glProgramUniform4uiv");
	api->DispatchCompute = loadProc("glDispatchCompute");
	api->VertexAttrib4bv = mg_glVertexAttrib4bv_noimpl;
	api->GetSamplerParameterfv = loadProc("glGetSamplerParameterfv");
	api->ProgramUniform3iv = loadProc("glProgramUniform3iv");
	api->VertexAttrib1s = mg_glVertexAttrib1s_noimpl;
	api->VertexAttribI2i = mg_glVertexAttribI2i_noimpl;
	api->SampleCoverage = loadProc("glSampleCoverage");
	api->BufferSubData = loadProc("glBufferSubData");
	api->VertexAttribI1ui = mg_glVertexAttribI1ui_noimpl;
	api->EndConditionalRender = mg_glEndConditionalRender_noimpl;
	api->GetPointerv = loadProc("glGetPointerv");
	api->GetnUniformiv = loadProc("glGetnUniformiv");
	api->BlendEquation = loadProc("glBlendEquation");
	api->VertexAttribI4iv = loadProc("glVertexAttribI4iv");
	api->GetnUniformfv = loadProc("glGetnUniformfv");
	api->VertexAttrib4Nsv = mg_glVertexAttrib4Nsv_noimpl;
	api->Uniform2fv = loadProc("glUniform2fv");
	api->Uniform3f = loadProc("glUniform3f");
	api->GenerateMipmap = loadProc("glGenerateMipmap");
	api->GenRenderbuffers = loadProc("glGenRenderbuffers");
	api->DrawElementsBaseVertex = loadProc("glDrawElementsBaseVertex");
	api->BindVertexBuffers = mg_glBindVertexBuffers_noimpl;
	api->Scissor = loadProc("glScissor");
	api->MapBufferRange = loadProc("glMapBufferRange");
	api->ProgramUniformMatrix4x2fv = loadProc("glProgramUniformMatrix4x2fv");
	api->GetTexParameterfv = loadProc("glGetTexParameterfv");
	api->Uniform2f = loadProc("glUniform2f");
	api->VertexAttribFormat = loadProc("glVertexAttribFormat");
	api->UniformMatrix2dv = mg_glUniformMatrix2dv_noimpl;
	api->IsEnabled = loadProc("glIsEnabled");
	api->ClearBufferfi = loadProc("glClearBufferfi");
	api->GetRenderbufferParameteriv = loadProc("glGetRenderbufferParameteriv");
	api->FramebufferTextureLayer = loadProc("glFramebufferTextureLayer");
	api->PointParameterf = mg_glPointParameterf_noimpl;
	api->GenVertexArrays = loadProc("glGenVertexArrays");
	api->GetAttachedShaders = loadProc("glGetAttachedShaders");
	api->FramebufferRenderbuffer = loadProc("glFramebufferRenderbuffer");
	api->DeleteTextures = loadProc("glDeleteTextures");
	api->BeginQuery = loadProc("glBeginQuery");
	api->Uniform4dv = mg_glUniform4dv_noimpl;
	api->VertexAttribIPointer = loadProc("glVertexAttribIPointer");
	api->GetSamplerParameterIiv = loadProc("glGetSamplerParameterIiv");
	api->BeginQueryIndexed = mg_glBeginQueryIndexed_noimpl;
	api->BeginTransformFeedback = loadProc("glBeginTransformFeedback");
	api->Uniform3i = loadProc("glUniform3i");
	api->GetActiveUniformName = mg_glGetActiveUniformName_noimpl;
	api->GetProgramResourceLocation = loadProc("glGetProgramResourceLocation");
	api->ShaderSource = loadProc("glShaderSource");
	api->SamplerParameterIiv = loadProc("glSamplerParameterIiv");
	api->Finish = loadProc("glFinish");
	api->DrawArraysInstancedBaseInstance = mg_glDrawArraysInstancedBaseInstance_noimpl;
	api->DeleteProgram = loadProc("glDeleteProgram");
	api->MultiDrawElementsBaseVertex = mg_glMultiDrawElementsBaseVertex_noimpl;
	api->ReadBuffer = loadProc("glReadBuffer");
	api->GenBuffers = loadProc("glGenBuffers");
	api->ClearDepthf = loadProc("glClearDepthf");
	api->VertexAttribPointer = loadProc("glVertexAttribPointer");
	api->VertexAttribL4dv = mg_glVertexAttribL4dv_noimpl;
	api->TexStorage2DMultisample = loadProc("glTexStorage2DMultisample");
	api->BindSamplers = mg_glBindSamplers_noimpl;
	api->EnableVertexAttribArray = loadProc("glEnableVertexAttribArray");
	api->VertexAttrib4ubv = mg_glVertexAttrib4ubv_noimpl;
	api->GetDebugMessageLog = loadProc("glGetDebugMessageLog");
	api->DisableVertexAttribArray = loadProc("glDisableVertexAttribArray");
	api->DrawElementsInstancedBaseInstance = mg_glDrawElementsInstancedBaseInstance_noimpl;
	api->PolygonMode = mg_glPolygonMode_noimpl;
	api->VertexAttribP1uiv = mg_glVertexAttribP1uiv_noimpl;
	api->ProgramUniform1iv = loadProc("glProgramUniform1iv");
	api->VertexAttribI1i = mg_glVertexAttribI1i_noimpl;
	api->GetTexLevelParameteriv = loadProc("glGetTexLevelParameteriv");
	api->IsSync = loadProc("glIsSync");
	api->TexStorage1D = mg_glTexStorage1D_noimpl;
	api->GetVertexAttribIiv = loadProc("glGetVertexAttribIiv");
	api->IsEnabledi = loadProc("glIsEnabledi");
	api->MultiDrawElementsIndirect = mg_glMultiDrawElementsIndirect_noimpl;
	api->GetBooleani_v = loadProc("glGetBooleani_v");
	api->GetInternalformativ = loadProc("glGetInternalformativ");
	api->VertexAttribI4ubv = mg_glVertexAttribI4ubv_noimpl;
	api->VertexAttrib2s = mg_glVertexAttrib2s_noimpl;
	api->GetBooleanv = loadProc("glGetBooleanv");
	api->VertexAttrib4iv = mg_glVertexAttrib4iv_noimpl;
	api->GetObjectPtrLabel = loadProc("glGetObjectPtrLabel");
	api->UniformMatrix2x4dv = mg_glUniformMatrix2x4dv_noimpl;
	api->ProgramUniform4ui = loadProc("glProgramUniform4ui");
	api->GetVertexAttribdv = mg_glGetVertexAttribdv_noimpl;
	api->ViewportIndexedf = mg_glViewportIndexedf_noimpl;
	api->DeleteSync = loadProc("glDeleteSync");
	api->CopyImageSubData = loadProc("glCopyImageSubData");
	api->PrimitiveBoundingBox = loadProc("glPrimitiveBoundingBox");
	api->ScissorIndexed = mg_glScissorIndexed_noimpl;
	api->GenTransformFeedbacks = loadProc("glGenTransformFeedbacks");
	api->MemoryBarrierByRegion = loadProc("glMemoryBarrierByRegion");
	api->DeleteTransformFeedbacks = loadProc("glDeleteTransformFeedbacks");
	api->ProgramUniform4f = loadProc("glProgramUniform4f");
	api->BindBuffersBase = mg_glBindBuffersBase_noimpl;
	api->GetTexParameterIuiv = loadProc("glGetTexParameterIuiv");
	api->IsShader = loadProc("glIsShader");
	api->ProgramUniform3i = loadProc("glProgramUniform3i");
	api->GetActiveAtomicCounterBufferiv = mg_glGetActiveAtomicCounterBufferiv_noimpl;
	api->ProgramUniformMatrix3x4fv = loadProc("glProgramUniformMatrix3x4fv");
	api->BufferStorage = mg_glBufferStorage_noimpl;
	api->GetUniformSubroutineuiv = mg_glGetUniformSubroutineuiv_noimpl;
	api->RenderbufferStorageMultisample = loadProc("glRenderbufferStorageMultisample");
	api->GetMultisamplefv = loadProc("glGetMultisamplefv");
	api->VertexAttribDivisor = loadProc("glVertexAttribDivisor");
	api->StencilMask = loadProc("glStencilMask");
	api->BindSampler = loadProc("glBindSampler");
	api->UniformMatrix4dv = mg_glUniformMatrix4dv_noimpl;
	api->BindImageTexture = loadProc("glBindImageTexture");
	api->DrawBuffers = loadProc("glDrawBuffers");
	api->VertexAttrib4Nub = mg_glVertexAttrib4Nub_noimpl;
	api->GetTexImage = mg_glGetTexImage_noimpl;
	api->VertexAttrib3dv = mg_glVertexAttrib3dv_noimpl;
	api->BlitFramebuffer = loadProc("glBlitFramebuffer");
	api->VertexAttrib2d = mg_glVertexAttrib2d_noimpl;
	api->Uniform1ui = loadProc("glUniform1ui");
	api->InvalidateBufferSubData = mg_glInvalidateBufferSubData_noimpl;
	api->EndQuery = loadProc("glEndQuery");
	api->GetUniformuiv = loadProc("glGetUniformuiv");
	api->GetFramebufferAttachmentParameteriv = loadProc("glGetFramebufferAttachmentParameteriv");
	api->ProgramUniform2f = loadProc("glProgramUniform2f");
	api->UniformMatrix3x2fv = loadProc("glUniformMatrix3x2fv");
	api->BindVertexBuffer = loadProc("glBindVertexBuffer");
	api->VertexAttrib2sv = mg_glVertexAttrib2sv_noimpl;
	api->Uniform1f = loadProc("glUniform1f");
	api->DebugMessageCallback = loadProc("glDebugMessageCallback");
	api->ReadPixels = loadProc("glReadPixels");
	api->CompressedTexSubImage1D = mg_glCompressedTexSubImage1D_noimpl;
	api->DrawArraysIndirect = loadProc("glDrawArraysIndirect");
	api->BlendFuncSeparate = loadProc("glBlendFuncSeparate");
	api->CreateShader = loadProc("glCreateShader");
	api->GetTransformFeedbackVarying = loadProc("glGetTransformFeedbackVarying");
	api->AttachShader = loadProc("glAttachShader");
	api->UniformMatrix2x3dv = mg_glUniformMatrix2x3dv_noimpl;
	api->ProgramUniform3uiv = loadProc("glProgramUniform3uiv");
	api->MultiDrawArraysIndirect = mg_glMultiDrawArraysIndirect_noimpl;
	api->Uniform2iv = loadProc("glUniform2iv");
	api->BindBufferRange = loadProc("glBindBufferRange");
	api->TexParameteriv = loadProc("glTexParameteriv");
	api->VertexAttribL3d = mg_glVertexAttribL3d_noimpl;
	api->TexImage3DMultisample = mg_glTexImage3DMultisample_noimpl;
	api->ClearTexSubImage = mg_glClearTexSubImage_noimpl;
	api->VertexAttrib4Nusv = mg_glVertexAttrib4Nusv_noimpl;
	api->InvalidateSubFramebuffer = loadProc("glInvalidateSubFramebuffer");
	api->GetShaderInfoLog = loadProc("glGetShaderInfoLog");
	api->VertexAttribP4ui = mg_glVertexAttribP4ui_noimpl;
	api->Viewport = loadProc("glViewport");
	api->BlendFunci = loadProc("glBlendFunci");
	api->PolygonOffset = loadProc("glPolygonOffset");
	api->ProgramUniform2ui = loadProc("glProgramUniform2ui");
	api->SamplerParameteri = loadProc("glSamplerParameteri");
	api->GetFramebufferParameteriv = loadProc("glGetFramebufferParameteriv");
	api->VertexAttribI2iv = mg_glVertexAttribI2iv_noimpl;
	api->ObjectLabel = loadProc("glObjectLabel");
	api->CompressedTexImage1D = mg_glCompressedTexImage1D_noimpl;
	api->InvalidateTexSubImage = mg_glInvalidateTexSubImage_noimpl;
	api->BindBuffersRange = mg_glBindBuffersRange_noimpl;
	api->CopyBufferSubData = loadProc("glCopyBufferSubData");
	api->VertexAttrib4Nbv = mg_glVertexAttrib4Nbv_noimpl;
	api->ObjectPtrLabel = loadProc("glObjectPtrLabel");
	api->ProgramUniform3d = mg_glProgramUniform3d_noimpl;
	api->GetProgramPipelineiv = loadProc("glGetProgramPipelineiv");
	api->TexStorage3DMultisample = loadProc("glTexStorage3DMultisample");
	api->VertexAttribL3dv = mg_glVertexAttribL3dv_noimpl;
	api->DeleteFramebuffers = loadProc("glDeleteFramebuffers");
	api->CheckFramebufferStatus = loadProc("glCheckFramebufferStatus");
	api->VertexAttribL2dv = mg_glVertexAttribL2dv_noimpl;
	api->ProgramUniform1dv = mg_glProgramUniform1dv_noimpl;
	api->VertexAttrib2f = loadProc("glVertexAttrib2f");
	api->GetVertexAttribIuiv = loadProc("glGetVertexAttribIuiv");
	api->StencilOp = loadProc("glStencilOp");
	api->VertexAttrib3d = mg_glVertexAttrib3d_noimpl;
	api->PointParameteri = mg_glPointParameteri_noimpl;
	api->VertexAttribI1uiv = mg_glVertexAttribI1uiv_noimpl;
	api->ClearBufferfv = loadProc("glClearBufferfv");
	api->BindFragDataLocationIndexed = mg_glBindFragDataLocationIndexed_noimpl;
	api->ProgramUniform1d = mg_glProgramUniform1d_noimpl;
	api->PointParameteriv = mg_glPointParameteriv_noimpl;
	api->FlushMappedBufferRange = loadProc("glFlushMappedBufferRange");
	api->TextureView = mg_glTextureView_noimpl;
	api->GetProgramPipelineInfoLog = loadProc("glGetProgramPipelineInfoLog");
	api->CopyTexImage2D = loadProc("glCopyTexImage2D");
	api->ProgramUniform3dv = mg_glProgramUniform3dv_noimpl;
	api->QueryCounter = mg_glQueryCounter_noimpl;
	api->GetUniformfv = loadProc("glGetUniformfv");
	api->ClearStencil = loadProc("glClearStencil");
	api->GetProgramiv = loadProc("glGetProgramiv");
	api->UniformSubroutinesuiv = mg_glUniformSubroutinesuiv_noimpl;
	api->GetProgramStageiv = mg_glGetProgramStageiv_noimpl;
	api->Uniform1iv = loadProc("glUniform1iv");
	api->GetVertexAttribPointerv = loadProc("glGetVertexAttribPointerv");
	api->TexSubImage1D = mg_glTexSubImage1D_noimpl;
	api->StencilFuncSeparate = loadProc("glStencilFuncSeparate");
	api->GetSubroutineIndex = mg_glGetSubroutineIndex_noimpl;
	api->DrawElementsInstanced = loadProc("glDrawElementsInstanced");
	api->BlendFuncSeparatei = loadProc("glBlendFuncSeparatei");
	api->ProgramUniformMatrix3x2dv = mg_glProgramUniformMatrix3x2dv_noimpl;
	api->GetActiveUniformsiv = loadProc("glGetActiveUniformsiv");
	api->UniformMatrix3fv = loadProc("glUniformMatrix3fv");
	api->ProgramUniformMatrix3x4dv = mg_glProgramUniformMatrix3x4dv_noimpl;
	api->GetSamplerParameterIuiv = loadProc("glGetSamplerParameterIuiv");
	api->VertexAttribI4i = loadProc("glVertexAttribI4i");
	api->BlendEquationSeparate = loadProc("glBlendEquationSeparate");
	api->UniformMatrix4x2fv = loadProc("glUniformMatrix4x2fv");
	api->TexParameterIiv = loadProc("glTexParameterIiv");
	api->DrawTransformFeedbackStream = mg_glDrawTransformFeedbackStream_noimpl;
	api->VertexAttribI1iv = mg_glVertexAttribI1iv_noimpl;
	api->GetUniformIndices = loadProc("glGetUniformIndices");
	api->GetShaderiv = loadProc("glGetShaderiv");
	api->GetActiveUniform = loadProc("glGetActiveUniform");
	api->Uniform3uiv = loadProc("glUniform3uiv");
	api->PatchParameteri = loadProc("glPatchParameteri");
	api->ProgramUniformMatrix2dv = mg_glProgramUniformMatrix2dv_noimpl;
	api->WaitSync = loadProc("glWaitSync");
	api->ClearTexImage = mg_glClearTexImage_noimpl;
	api->DepthRangeIndexed = mg_glDepthRangeIndexed_noimpl;
	api->GetTexParameterIiv = loadProc("glGetTexParameterIiv");
	api->DepthRange = mg_glDepthRange_noimpl;
	api->GetActiveAttrib = loadProc("glGetActiveAttrib");
	api->IsRenderbuffer = loadProc("glIsRenderbuffer");
	api->ClearBufferiv = loadProc("glClearBufferiv");
	api->ProgramUniform3fv = loadProc("glProgramUniform3fv");
	api->VertexAttribI3uiv = mg_glVertexAttribI3uiv_noimpl;
	api->UseProgram = loadProc("glUseProgram");
	api->GetActiveSubroutineName = mg_glGetActiveSubroutineName_noimpl;
	api->ProgramUniformMatrix3fv = loadProc("glProgramUniformMatrix3fv");
	api->ProgramUniformMatrix4x3dv = mg_glProgramUniformMatrix4x3dv_noimpl;
	api->UniformMatrix4x3dv = mg_glUniformMatrix4x3dv_noimpl;
	api->ProgramUniform4dv = mg_glProgramUniform4dv_noimpl;
	api->GetBufferSubData = mg_glGetBufferSubData_noimpl;
	api->VertexAttrib4uiv = mg_glVertexAttrib4uiv_noimpl;
	api->VertexAttrib1f = loadProc("glVertexAttrib1f");
	api->VertexAttrib4usv = mg_glVertexAttrib4usv_noimpl;
	api->DebugMessageInsert = loadProc("glDebugMessageInsert");
	api->EndTransformFeedback = loadProc("glEndTransformFeedback");
	api->TexImage2DMultisample = mg_glTexImage2DMultisample_noimpl;
	api->BindTransformFeedback = loadProc("glBindTransformFeedback");
	api->Uniform3dv = mg_glUniform3dv_noimpl;
	api->UniformMatrix3x2dv = mg_glUniformMatrix3x2dv_noimpl;
	api->GetSamplerParameteriv = loadProc("glGetSamplerParameteriv");
	api->VertexAttribP3uiv = mg_glVertexAttribP3uiv_noimpl;
	api->Uniform4d = mg_glUniform4d_noimpl;
	api->ProgramUniformMatrix3dv = mg_glProgramUniformMatrix3dv_noimpl;
	api->ProgramUniform3ui = loadProc("glProgramUniform3ui");
	api->DeleteVertexArrays = loadProc("glDeleteVertexArrays");
	api->TexParameteri = loadProc("glTexParameteri");
	api->DrawElementsInstancedBaseVertex = loadProc("glDrawElementsInstancedBaseVertex");
	api->GetQueryObjectui64v = mg_glGetQueryObjectui64v_noimpl;
	api->VertexAttrib4Niv = mg_glVertexAttrib4Niv_noimpl;
	api->SamplerParameterfv = loadProc("glSamplerParameterfv");
	api->VertexAttribI4bv = mg_glVertexAttribI4bv_noimpl;
	api->ProgramUniform1i = loadProc("glProgramUniform1i");
	api->ProgramUniformMatrix4x2dv = mg_glProgramUniformMatrix4x2dv_noimpl;
	api->GetSynciv = loadProc("glGetSynciv");
	api->VertexAttrib3f = loadProc("glVertexAttrib3f");
	api->GetQueryObjectiv = mg_glGetQueryObjectiv_noimpl;
	api->GetProgramInfoLog = loadProc("glGetProgramInfoLog");
	api->GetActiveUniformBlockiv = loadProc("glGetActiveUniformBlockiv");
	api->GenQueries = loadProc("glGenQueries");
	api->ProgramUniformMatrix4x3fv = loadProc("glProgramUniformMatrix4x3fv");
	api->TexBuffer = loadProc("glTexBuffer");
	api->ShaderStorageBlockBinding = mg_glShaderStorageBlockBinding_noimpl;
	api->Disable = loadProc("glDisable");
	api->VertexAttribI3ui = mg_glVertexAttribI3ui_noimpl;
	api->IsSampler = loadProc("glIsSampler");
	api->ActiveShaderProgram = loadProc("glActiveShaderProgram");
	api->BindVertexArray = loadProc("glBindVertexArray");
	api->UniformMatrix2x3fv = loadProc("glUniformMatrix2x3fv");
	api->DrawArraysInstanced = loadProc("glDrawArraysInstanced");
	api->VertexAttribI2uiv = mg_glVertexAttribI2uiv_noimpl;
	api->GetQueryObjecti64v = mg_glGetQueryObjecti64v_noimpl;
	api->GetStringi = loadProc("glGetStringi");
	api->BindProgramPipeline = loadProc("glBindProgramPipeline");
	api->BindFramebuffer = loadProc("glBindFramebuffer");
	api->VertexAttrib1d = mg_glVertexAttrib1d_noimpl;
	api->RenderbufferStorage = loadProc("glRenderbufferStorage");
	api->ReleaseShaderCompiler = loadProc("glReleaseShaderCompiler");
	api->Uniform2i = loadProc("glUniform2i");
	api->DrawBuffer = mg_glDrawBuffer_noimpl;
	api->DeleteRenderbuffers = loadProc("glDeleteRenderbuffers");
	api->DeleteBuffers = loadProc("glDeleteBuffers");
	api->GenFramebuffers = loadProc("glGenFramebuffers");
	api->ProgramUniformMatrix4dv = mg_glProgramUniformMatrix4dv_noimpl;
	api->ProgramUniform3f = loadProc("glProgramUniform3f");
	api->ProgramUniform2iv = loadProc("glProgramUniform2iv");
	api->BlendBarrier = loadProc("glBlendBarrier");
	api->VertexAttribL2d = mg_glVertexAttribL2d_noimpl;
	api->CompressedTexSubImage2D = loadProc("glCompressedTexSubImage2D");
	api->UniformMatrix2fv = loadProc("glUniformMatrix2fv");
	api->SamplerParameterf = loadProc("glSamplerParameterf");
	api->UniformMatrix4fv = loadProc("glUniformMatrix4fv");
	api->VertexAttribI2ui = mg_glVertexAttribI2ui_noimpl;
	api->BindTextures = mg_glBindTextures_noimpl;
	api->Uniform3d = mg_glUniform3d_noimpl;
	api->ViewportIndexedfv = mg_glViewportIndexedfv_noimpl;
	api->VertexAttribI4sv = mg_glVertexAttribI4sv_noimpl;
	api->LineWidth = loadProc("glLineWidth");
	api->GetVertexAttribfv = loadProc("glGetVertexAttribfv");
	api->VertexAttribI3iv = mg_glVertexAttribI3iv_noimpl;
	api->Uniform1dv = mg_glUniform1dv_noimpl;
	api->CullFace = loadProc("glCullFace");
	api->CreateProgram = loadProc("glCreateProgram");
	api->Uniform4i = loadProc("glUniform4i");
	api->UniformMatrix4x3fv = loadProc("glUniformMatrix4x3fv");
	api->GetAttribLocation = loadProc("glGetAttribLocation");
	api->GetShaderPrecisionFormat = loadProc("glGetShaderPrecisionFormat");
	api->Uniform4iv = loadProc("glUniform4iv");
	api->CompressedTexSubImage3D = loadProc("glCompressedTexSubImage3D");
	api->BindImageTextures = mg_glBindImageTextures_noimpl;
	api->GetBufferParameteri64v = loadProc("glGetBufferParameteri64v");
	api->FrontFace = loadProc("glFrontFace");
	api->PopDebugGroup = loadProc("glPopDebugGroup");
	api->VertexAttrib1sv = mg_glVertexAttrib1sv_noimpl;
	api->InvalidateBufferData = mg_glInvalidateBufferData_noimpl;
	api->IsVertexArray = loadProc("glIsVertexArray");
	api->ScissorArrayv = mg_glScissorArrayv_noimpl;
	api->ValidateProgram = loadProc("glValidateProgram");
	api->Uniform2uiv = loadProc("glUniform2uiv");
	api->TexSubImage2D = loadProc("glTexSubImage2D");
	api->DebugMessageControl = loadProc("glDebugMessageControl");
	api->FramebufferParameteri = loadProc("glFramebufferParameteri");
	api->GetUniformLocation = loadProc("glGetUniformLocation");
	api->TexStorage3D = loadProc("glTexStorage3D");
	api->PixelStoref = mg_glPixelStoref_noimpl;
	api->DepthRangef = loadProc("glDepthRangef");
	api->VertexAttribI3i = mg_glVertexAttribI3i_noimpl;
	api->Uniform1uiv = loadProc("glUniform1uiv");
	api->Disablei = loadProc("glDisablei");
	api->GetInternalformati64v = mg_glGetInternalformati64v_noimpl;
	api->ProgramUniformMatrix2x3dv = mg_glProgramUniformMatrix2x3dv_noimpl;
	api->GetProgramResourceIndex = loadProc("glGetProgramResourceIndex");
	api->BlendColor = loadProc("glBlendColor");
	api->GenSamplers = loadProc("glGenSamplers");
	api->ColorMaski = loadProc("glColorMaski");
	api->GetGraphicsResetStatus = loadProc("glGetGraphicsResetStatus");
	api->VertexAttribI4uiv = loadProc("glVertexAttribI4uiv");
	api->CreateShaderProgramv = loadProc("glCreateShaderProgramv");
	api->DeleteSamplers = loadProc("glDeleteSamplers");
	api->VertexAttrib3s = mg_glVertexAttrib3s_noimpl;
	api->DrawTransformFeedback = mg_glDrawTransformFeedback_noimpl;
	api->VertexAttribL1d = mg_glVertexAttribL1d_noimpl;
	api->DrawElementsInstancedBaseVertexBaseInstance = mg_glDrawElementsInstancedBaseVertexBaseInstance_noimpl;
	api->ClearBufferSubData = mg_glClearBufferSubData_noimpl;
	api->VertexAttribLFormat = mg_glVertexAttribLFormat_noimpl;
	api->Uniform2dv = mg_glUniform2dv_noimpl;
	api->CopyTexSubImage3D = loadProc("glCopyTexSubImage3D");
	api->CopyTexImage1D = mg_glCopyTexImage1D_noimpl;
	api->FramebufferTexture3D = mg_glFramebufferTexture3D_noimpl;
	api->VertexAttribL4d = mg_glVertexAttribL4d_noimpl;
	api->UnmapBuffer = loadProc("glUnmapBuffer");
	api->GetQueryIndexediv = mg_glGetQueryIndexediv_noimpl;
	api->FenceSync = loadProc("glFenceSync");
	api->DispatchComputeIndirect = loadProc("glDispatchComputeIndirect");
	api->SamplerParameterIuiv = loadProc("glSamplerParameterIuiv");
	api->GetFragDataLocation = loadProc("glGetFragDataLocation");
	api->GetUniformdv = mg_glGetUniformdv_noimpl;
	api->TexImage3D = loadProc("glTexImage3D");
	api->ValidateProgramPipeline = loadProc("glValidateProgramPipeline");
	api->LinkProgram = loadProc("glLinkProgram");
	api->DeleteQueries = loadProc("glDeleteQueries");
	api->FramebufferTexture1D = mg_glFramebufferTexture1D_noimpl;
	api->GetActiveSubroutineUniformName = mg_glGetActiveSubroutineUniformName_noimpl;
	api->ProgramUniformMatrix3x2fv = loadProc("glProgramUniformMatrix3x2fv");
	api->GetTexParameteriv = loadProc("glGetTexParameteriv");
	api->ProvokingVertex = mg_glProvokingVertex_noimpl;
	api->BindAttribLocation = loadProc("glBindAttribLocation");
	api->VertexAttrib3fv = loadProc("glVertexAttrib3fv");
	api->GetActiveUniformBlockName = loadProc("glGetActiveUniformBlockName");
	api->DrawArrays = loadProc("glDrawArrays");
	api->GetnUniformuiv = loadProc("glGetnUniformuiv");
	api->ProgramUniform1uiv = loadProc("glProgramUniform1uiv");
	api->DrawElementsIndirect = loadProc("glDrawElementsIndirect");
	api->VertexAttribI4usv = mg_glVertexAttribI4usv_noimpl;
	api->BlendEquationSeparatei = loadProc("glBlendEquationSeparatei");
	api->DrawElements = loadProc("glDrawElements");
	api->GetShaderSource = loadProc("glGetShaderSource");
	api->TransformFeedbackVaryings = loadProc("glTransformFeedbackVaryings");
	api->GetError = loadProc("glGetError");
	api->IsBuffer = loadProc("glIsBuffer");
	api->ClearBufferuiv = loadProc("glClearBufferuiv");
	api->GetVertexAttribiv = loadProc("glGetVertexAttribiv");
	api->GetProgramResourceName = loadProc("glGetProgramResourceName");
	api->Uniform2ui = loadProc("glUniform2ui");
	api->StencilFunc = loadProc("glStencilFunc");
	api->Enablei = loadProc("glEnablei");
	api->SamplerParameteriv = loadProc("glSamplerParameteriv");
	api->GetInteger64i_v = loadProc("glGetInteger64i_v");
	api->ProgramUniform4i = loadProc("glProgramUniform4i");
	api->Uniform4ui = loadProc("glUniform4ui");
	api->UniformMatrix2x4fv = loadProc("glUniformMatrix2x4fv");
	api->ReadnPixels = loadProc("glReadnPixels");
	api->DrawTransformFeedbackInstanced = mg_glDrawTransformFeedbackInstanced_noimpl;
	api->PointSize = mg_glPointSize_noimpl;
	api->ProgramUniformMatrix4fv = loadProc("glProgramUniformMatrix4fv");
	api->ViewportArrayv = mg_glViewportArrayv_noimpl;
	api->StencilOpSeparate = loadProc("glStencilOpSeparate");
	api->Uniform3ui = loadProc("glUniform3ui");
	api->Uniform4uiv = loadProc("glUniform4uiv");
	api->Uniform3iv = loadProc("glUniform3iv");
	api->Uniform4f = loadProc("glUniform4f");
	api->FramebufferTexture2D = loadProc("glFramebufferTexture2D");
	api->GetIntegeri_v = loadProc("glGetIntegeri_v");
	api->MultiDrawElements = mg_glMultiDrawElements_noimpl;
	api->UniformMatrix4x2dv = mg_glUniformMatrix4x2dv_noimpl;
	api->ProgramUniformMatrix2x3fv = loadProc("glProgramUniformMatrix2x3fv");
	api->CopyTexSubImage1D = mg_glCopyTexSubImage1D_noimpl;
	api->TexSubImage3D = loadProc("glTexSubImage3D");
	api->GetActiveSubroutineUniformiv = mg_glGetActiveSubroutineUniformiv_noimpl;
	api->GenProgramPipelines = loadProc("glGenProgramPipelines");
	api->ProgramUniform4iv = loadProc("glProgramUniform4iv");
	api->UniformMatrix3x4fv = loadProc("glUniformMatrix3x4fv");
	api->UniformBlockBinding = loadProc("glUniformBlockBinding");
	api->DepthRangeArrayv = mg_glDepthRangeArrayv_noimpl;
	api->TexParameterfv = loadProc("glTexParameterfv");
	api->MapBuffer = mg_glMapBuffer_noimpl;
	api->DeleteProgramPipelines = loadProc("glDeleteProgramPipelines");
	api->MinSampleShading = loadProc("glMinSampleShading");
	api->PauseTransformFeedback = loadProc("glPauseTransformFeedback");
	api->EndQueryIndexed = mg_glEndQueryIndexed_noimpl;
	api->GetProgramBinary = loadProc("glGetProgramBinary");
	api->ProgramUniform2i = loadProc("glProgramUniform2i");
	api->DepthMask = loadProc("glDepthMask");
	api->ActiveTexture = loadProc("glActiveTexture");
	api->UseProgramStages = loadProc("glUseProgramStages");
	api->PatchParameterfv = mg_glPatchParameterfv_noimpl;
	api->ShaderBinary = loadProc("glShaderBinary");
	api->GetFloatv = loadProc("glGetFloatv");
	api->ProgramUniform1f = loadProc("glProgramUniform1f");
	api->TexImage1D = mg_glTexImage1D_noimpl;
	api->ProgramUniform2uiv = loadProc("glProgramUniform2uiv");
	api->ClearBufferData = mg_glClearBufferData_noimpl;
	api->UniformMatrix3dv = mg_glUniformMatrix3dv_noimpl;
	api->CompressedTexImage2D = loadProc("glCompressedTexImage2D");
	api->VertexAttrib4fv = loadProc("glVertexAttrib4fv");
	api->GetProgramResourceiv = loadProc("glGetProgramResourceiv");
	api->GetString = loadProc("glGetString");
	api->ProgramUniformMatrix2fv = loadProc("glProgramUniformMatrix2fv");
	api->GetVertexAttribLdv = mg_glGetVertexAttribLdv_noimpl;
	api->VertexAttrib4Nubv = mg_glVertexAttrib4Nubv_noimpl;
	api->TexBufferRange = loadProc("glTexBufferRange");
	api->UniformMatrix3x4dv = mg_glUniformMatrix3x4dv_noimpl;
	api->GetProgramInterfaceiv = loadProc("glGetProgramInterfaceiv");
	api->TexParameterIuiv = loadProc("glTexParameterIuiv");
	api->DeleteShader = loadProc("glDeleteShader");
	api->GetFloati_v = mg_glGetFloati_v_noimpl;
	api->DrawTransformFeedbackStreamInstanced = mg_glDrawTransformFeedbackStreamInstanced_noimpl;
	api->VertexAttrib4s = mg_glVertexAttrib4s_noimpl;
}

void mg_gl_select_api(mg_gl_api* api){ __mgGLAPI = api; }
void mg_gl_deselect_api(){ __mgGLAPI = &__mgGLNoAPI; }
mg_gl_api* mg_gl_get_api(void) { return(__mgGLAPI); }

