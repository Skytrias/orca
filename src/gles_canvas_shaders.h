/*********************************************************************
*
*	file: gles_canvas_shaders.h
*	note: string literals auto-generated by embed_text.py
*	date: 02/022023
*
**********************************************************************/
#ifndef __GLES_CANVAS_SHADERS_H__
#define __GLES_CANVAS_SHADERS_H__


//NOTE: string imported from src\gles_canvas_shaders\gles_canvas_fragment.glsl
const char* gles_canvas_fragment = 
"#version 310 es\n"
"\n"
"precision mediump float;\n"
"layout(std430) buffer;\n"
"\n"
"struct vertex {\n"
"	vec2 pos;\n"
"	vec4 cubic;\n"
"	vec2 uv;\n"
"	vec4 color;\n"
"	vec4 clip;\n"
"	int zIndex;\n"
"};\n"
"\n"
"layout(binding = 0) buffer vertexBufferSSBO {\n"
"	vertex elements[];\n"
"} vertexBuffer ;\n"
"\n"
"layout(binding = 1) buffer indexBufferSSBO {\n"
"	uint elements[];\n"
"} indexBuffer ;\n"
"\n"
"layout(location = 0) uniform int indexCount;\n"
"layout(location = 1) uniform vec4 clearColor;\n"
"\n"
"layout(location = 0) out vec4 fragColor;\n"
"\n"
"bool is_top_left(ivec2 a, ivec2 b)\n"
"{\n"
"	return( (a.y == b.y && b.x < a.x)\n"
"	      ||(b.y < a.y));\n"
"}\n"
"\n"
"int orient2d(ivec2 a, ivec2 b, ivec2 p)\n"
"{\n"
"	return((b.x-a.x)*(p.y-a.y) - (b.y-a.y)*(p.x-a.x));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	const float subPixelFactor = 16.;\n"
"	const int sampleCount = 8;\n"
"\n"
"	ivec2 centerPoint = ivec2(round(gl_FragCoord.xy * subPixelFactor));\n"
"	ivec2 samplePoints[sampleCount] = ivec2[sampleCount](centerPoint + ivec2(1, 3),\n"
"	                                                     centerPoint + ivec2(-1, -3),\n"
"	                                                     centerPoint + ivec2(5, -1),\n"
"	                                                     centerPoint + ivec2(-3, 5),\n"
"	                                                     centerPoint + ivec2(-5, -5),\n"
"	                                                     centerPoint + ivec2(-7, 1),\n"
"	                                                     centerPoint + ivec2(3, -7),\n"
"	                                                     centerPoint + ivec2(7, 7));\n"
"\n"
"	vec4 sampleColor[sampleCount];\n"
"	vec4 currentColor[sampleCount];\n"
"    int currentZIndex[sampleCount];\n"
"    int flipCount[sampleCount];\n"
"\n"
"    for(int i=0; i<sampleCount; i++)\n"
"    {\n"
"		currentZIndex[i] = -1;\n"
"		flipCount[i] = 0;\n"
"		sampleColor[i] = clearColor;\n"
"		currentColor[i] = clearColor;\n"
"    }\n"
"\n"
"    for(int triangleIndex=0; triangleIndex<indexCount; triangleIndex+=3)\n"
"    {\n"
"		uint i0 = indexBuffer.elements[triangleIndex];\n"
"		uint i1 = indexBuffer.elements[triangleIndex+1];\n"
"		uint i2 = indexBuffer.elements[triangleIndex+2];\n"
"\n"
"		ivec2 p0 = ivec2(vertexBuffer.elements[i0].pos * subPixelFactor + vec2(0.5, 0.5));\n"
"		ivec2 p1 = ivec2(vertexBuffer.elements[i1].pos * subPixelFactor + vec2(0.5, 0.5));\n"
"		ivec2 p2 = ivec2(vertexBuffer.elements[i2].pos * subPixelFactor + vec2(0.5, 0.5));\n"
"\n"
"		int zIndex = vertexBuffer.elements[i0].zIndex;\n"
"		vec4 color = vertexBuffer.elements[i0].color;\n"
"\n"
"		//NOTE(martin): reorder triangle counter-clockwise and compute bias for each edge\n"
"		int cw = (p1 - p0).x*(p2 - p0).y - (p1 - p0).y*(p2 - p0).x;\n"
"		if(cw < 0)\n"
"		{\n"
"			uint tmpIndex = i1;\n"
"			i1 = i2;\n"
"			i2 = tmpIndex;\n"
"\n"
"			ivec2 tmpPoint = p1;\n"
"			p1 = p2;\n"
"			p2 = tmpPoint;\n"
"		}\n"
"\n"
"		vec4 cubic0 = vertexBuffer.elements[i0].cubic;\n"
"		vec4 cubic1 = vertexBuffer.elements[i1].cubic;\n"
"		vec4 cubic2 = vertexBuffer.elements[i2].cubic;\n"
"\n"
"		int bias0 = is_top_left(p1, p2) ? 0 : -1;\n"
"		int bias1 = is_top_left(p2, p0) ? 0 : -1;\n"
"		int bias2 = is_top_left(p0, p1) ? 0 : -1;\n"
"\n"
"		for(int sampleIndex = 0; sampleIndex < sampleCount; sampleIndex++)\n"
"		{\n"
"			ivec2 samplePoint = samplePoints[sampleIndex];\n"
"\n"
"			int w0 = orient2d(p1, p2, samplePoint);\n"
"			int w1 = orient2d(p2, p0, samplePoint);\n"
"			int w2 = orient2d(p0, p1, samplePoint);\n"
"\n"
"			if((w0+bias0) >= 0 && (w1+bias1) >= 0 && (w2+bias2) >= 0)\n"
"			{\n"
"				vec4 cubic = (cubic0*float(w0) + cubic1*float(w1) + cubic2*float(w2))/(float(w0)+float(w1)+float(w2));\n"
"\n"
"				float eps = 0.0001;\n"
"				if(cubic.w*(cubic.x*cubic.x*cubic.x - cubic.y*cubic.z) <= eps)\n"
"				{\n"
"					if(zIndex == currentZIndex[sampleIndex])\n"
"					{\n"
"						flipCount[sampleIndex]++;\n"
"					}\n"
"					else\n"
"					{\n"
"						if((flipCount[sampleIndex] & 0x01) != 0)\n"
"						{\n"
"							sampleColor[sampleIndex] = currentColor[sampleIndex];\n"
"						}\n"
"						currentColor[sampleIndex] = sampleColor[sampleIndex]*(1.-color.a) + color.a*color;\n"
"						currentZIndex[sampleIndex] = zIndex;\n"
"						flipCount[sampleIndex] = 1;\n"
"					}\n"
"				}\n"
"			}\n"
"		}\n"
"    }\n"
"    vec4 pixelColor = vec4(0);\n"
"    for(int sampleIndex = 0; sampleIndex < sampleCount; sampleIndex++)\n"
"    {\n"
"    	if((flipCount[sampleIndex] & 0x01) != 0)\n"
"    	{\n"
"			sampleColor[sampleIndex] = currentColor[sampleIndex];\n"
"    	}\n"
"    	pixelColor += sampleColor[sampleIndex];\n"
"	}\n"
"    fragColor = pixelColor/float(sampleCount);\n"
"}\n";

//NOTE: string imported from src\gles_canvas_shaders\gles_canvas_vertex.glsl
const char* gles_canvas_vertex = 
"#version 310 es\n"
"\n"
"precision mediump float;\n"
"\n"
"void main()\n"
"{\n"
"    float x = float(((uint(gl_VertexID) + 2u) / 3u)%2u);\n"
"    float y = float(((uint(gl_VertexID) + 1u) / 3u)%2u);\n"
"\n"
"    gl_Position = vec4(-1.0f + x*2.0f, -1.0f+y*2.0f, 0.0f, 1.0f);\n"
"}\n";

#endif // __GLES_CANVAS_SHADERS_H__
