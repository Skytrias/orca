/*********************************************************************
*
*	file: gles_canvas_shaders.h
*	note: string literals auto-generated by embed_text.py
*	date: 02/022023
*
**********************************************************************/
#ifndef __GLES_CANVAS_SHADERS_H__
#define __GLES_CANVAS_SHADERS_H__


//NOTE: string imported from src\gles_canvas_shaders\gles_canvas_fragment.glsl
const char* gles_canvas_fragment = 
"#version 310 es\n"
"\n"
"precision mediump float;\n"
"layout(std430) buffer;\n"
"\n"
"struct vertex {\n"
"	vec2 pos;\n"
"	vec4 cubic;\n"
"	vec2 uv;\n"
"	vec4 color;\n"
"	vec4 clip;\n"
"	int zIndex;\n"
"};\n"
"\n"
"layout(binding = 0) buffer vertexBufferSSBO {\n"
"	vertex elements[];\n"
"} vertexBuffer ;\n"
"\n"
"layout(binding = 1) buffer indexBufferSSBO {\n"
"	uint elements[];\n"
"} indexBuffer ;\n"
"\n"
"layout(location = 0) uniform int indexCount;\n"
"layout(location = 1) uniform vec4 clearColor;\n"
"\n"
"layout(location = 0) out vec4 fragColor;\n"
"\n"
"bool is_top_left(ivec2 a, ivec2 b)\n"
"{\n"
"	return( (a.y == b.y && b.x < a.x)\n"
"	      ||(b.y < a.y));\n"
"}\n"
"\n"
"int orient2d(ivec2 a, ivec2 b, ivec2 p)\n"
"{\n"
"	return((b.x-a.x)*(p.y-a.y) - (b.y-a.y)*(p.x-a.x));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"	float subPixelFactor = 16.;\n"
"\n"
"    vec4 pixelColor = clearColor;\n"
"    vec4 currentColor = clearColor;\n"
"\n"
"	ivec2 samplePoint = ivec2(gl_FragCoord.xy * subPixelFactor + vec2(0.5, 0.5));\n"
"\n"
"    int currentZIndex = -1;\n"
"    int flipCount = 0;\n"
"\n"
"\n"
"    for(int i=0; i<indexCount; i+=3)\n"
"    {\n"
"		uint i0 = indexBuffer.elements[i];\n"
"		uint i1 = indexBuffer.elements[i+1];\n"
"		uint i2 = indexBuffer.elements[i+2];\n"
"\n"
"		ivec2 p0 = ivec2(vertexBuffer.elements[i0].pos * subPixelFactor + vec2(0.5, 0.5));\n"
"		ivec2 p1 = ivec2(vertexBuffer.elements[i1].pos * subPixelFactor + vec2(0.5, 0.5));\n"
"		ivec2 p2 = ivec2(vertexBuffer.elements[i2].pos * subPixelFactor + vec2(0.5, 0.5));\n"
"\n"
"		int zIndex = vertexBuffer.elements[i0].zIndex;\n"
"		vec4 color = vertexBuffer.elements[i0].color;\n"
"\n"
"		//NOTE(martin): reorder triangle counter-clockwise and compute bias for each edge\n"
"		int cw = (p1 - p0).x*(p2 - p0).y - (p1 - p0).y*(p2 - p0).x;\n"
"		if(cw < 0)\n"
"		{\n"
"			uint tmpIndex = i1;\n"
"			i1 = i2;\n"
"			i2 = tmpIndex;\n"
"\n"
"			ivec2 tmpPoint = p1;\n"
"			p1 = p2;\n"
"			p2 = tmpPoint;\n"
"		}\n"
"\n"
"		vec4 cubic0 = vertexBuffer.elements[i0].cubic;\n"
"		vec4 cubic1 = vertexBuffer.elements[i1].cubic;\n"
"		vec4 cubic2 = vertexBuffer.elements[i2].cubic;\n"
"\n"
"		int bias0 = is_top_left(p1, p2) ? 0 : -1;\n"
"		int bias1 = is_top_left(p2, p0) ? 0 : -1;\n"
"		int bias2 = is_top_left(p0, p1) ? 0 : -1;\n"
"\n"
"		int w0 = orient2d(p1, p2, samplePoint);\n"
"		int w1 = orient2d(p2, p0, samplePoint);\n"
"		int w2 = orient2d(p0, p1, samplePoint);\n"
"\n"
"		if((w0+bias0) >= 0 && (w1+bias1) >= 0 && (w2+bias2) >= 0)\n"
"		{\n"
"			vec4 cubic = (cubic0*float(w0) + cubic1*float(w1) + cubic2*float(w2))/(float(w0)+float(w1)+float(w2));\n"
"\n"
"			float eps = 0.0001;\n"
"			if(cubic.w*(cubic.x*cubic.x*cubic.x - cubic.y*cubic.z) <= eps)\n"
"			{\n"
"				if(zIndex == currentZIndex)\n"
"				{\n"
"					flipCount++;\n"
"				}\n"
"				else\n"
"				{\n"
"					if((flipCount & 0x01) != 0)\n"
"					{\n"
"						pixelColor = currentColor;\n"
"					}\n"
"					currentColor = pixelColor*(1.-color.a) + color.a*color;\n"
"					currentZIndex = zIndex;\n"
"					flipCount = 1;\n"
"				}\n"
"			}\n"
"		}\n"
"    }\n"
"    if((flipCount & 0x01) != 0)\n"
"    {\n"
"		pixelColor = currentColor;\n"
"    }\n"
"\n"
"    fragColor = pixelColor;\n"
"}\n";

//NOTE: string imported from src\gles_canvas_shaders\gles_canvas_vertex.glsl
const char* gles_canvas_vertex = 
"#version 310 es\n"
"\n"
"precision mediump float;\n"
"\n"
"void main()\n"
"{\n"
"    float x = float(((uint(gl_VertexID) + 2u) / 3u)%2u);\n"
"    float y = float(((uint(gl_VertexID) + 1u) / 3u)%2u);\n"
"\n"
"    gl_Position = vec4(-1.0f + x*2.0f, -1.0f+y*2.0f, 0.0f, 1.0f);\n"
"}\n";

#endif // __GLES_CANVAS_SHADERS_H__
