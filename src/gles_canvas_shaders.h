/*********************************************************************
*
*	file: gles_canvas_shaders.h
*	note: string literals auto-generated by embed_text.py
*	date: 01/022023
*
**********************************************************************/
#ifndef __GLES_CANVAS_SHADERS_H__
#define __GLES_CANVAS_SHADERS_H__


//NOTE: string imported from src\gles_canvas_shaders\gles_canvas_fragment.glsl
const char* gles_canvas_fragment = 
"#version 310 es\n"
"\n"
"precision mediump float;\n"
"layout(std430) buffer;\n"
"\n"
"struct vertex {\n"
"	vec2 pos;\n"
"	vec4 cubic;\n"
"	vec2 uv;\n"
"	vec4 color;\n"
"	vec4 clip;\n"
"	int zIndex;\n"
"};\n"
"\n"
"layout(binding = 0) buffer vertexBufferSSBO {\n"
"	vertex elements[];\n"
"} vertexBuffer ;\n"
"\n"
"layout(binding = 1) buffer indexBufferSSBO {\n"
"	uint elements[];\n"
"} indexBuffer ;\n"
"\n"
"layout(location = 0) uniform int indexCount;\n"
"layout(location = 0) out vec4 fragColor;\n"
"\n"
"bool is_top_left(vec2 a, vec2 b)\n"
"{\n"
"	return( (a.y == b.y && b.x < a.x)\n"
"	      ||(b.y < a.y));\n"
"}\n"
"\n"
"float orient2d(vec2 a, vec2 b, vec2 c)\n"
"{\n"
"	//////////////////////////////////////////////////////////////////////////////////////////\n"
"	//TODO(martin): FIX this. This is a **horrible** quick hack to fix the precision issues\n"
"	//              arising when a, b, and c are close. But it degrades when a, c, and c\n"
"	//              are big. The proper solution is to change the expression to avoid\n"
"	//              precision loss but I'm too busy/lazy to do it now.\n"
"	//////////////////////////////////////////////////////////////////////////////////////////\n"
"	a *= 10.;\n"
"	b *= 10.;\n"
"	c *= 10.;\n"
"	return((b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x));\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    vec4 pixelColor = vec4(0.0, 1.0, 0.0, 1.0);\n"
"    vec4 currentColor = vec4(0., 0., 0., 1.0);\n"
"\n"
"	vec2 samplePoint = gl_FragCoord.xy;\n"
"\n"
"    int currentZIndex = -1;\n"
"    int flipCount = 0;\n"
"\n"
"\n"
"    for(int i=0; i<indexCount; i+=3)\n"
"    {\n"
"		uint i0 = indexBuffer.elements[i];\n"
"		uint i1 = indexBuffer.elements[i+1];\n"
"		uint i2 = indexBuffer.elements[i+2];\n"
"\n"
"		vec2 p0 = vertexBuffer.elements[i0].pos;\n"
"		vec2 p1 = vertexBuffer.elements[i1].pos;\n"
"		vec2 p2 = vertexBuffer.elements[i2].pos;\n"
"\n"
"		int zIndex = vertexBuffer.elements[i0].zIndex;\n"
"		vec4 color = vertexBuffer.elements[i0].color;\n"
"\n"
"		//NOTE(martin): reorder triangle counter-clockwise and compute bias for each edge\n"
"		float cw = (p1 - p0).x*(p2 - p0).y - (p1 - p0).y*(p2 - p0).x;\n"
"		if(cw < 0.)\n"
"		{\n"
"			uint tmpIndex = i1;\n"
"			i1 = i2;\n"
"			i2 = tmpIndex;\n"
"\n"
"			vec2 tmpPoint = p1;\n"
"			p1 = p2;\n"
"			p2 = tmpPoint;\n"
"		}\n"
"\n"
"		vec4 cubic0 = vertexBuffer.elements[i0].cubic;\n"
"		vec4 cubic1 = vertexBuffer.elements[i1].cubic;\n"
"		vec4 cubic2 = vertexBuffer.elements[i2].cubic;\n"
"\n"
"		int bias0 = is_top_left(p1, p2) ? 0 : -1;\n"
"		int bias1 = is_top_left(p2, p0) ? 0 : -1;\n"
"		int bias2 = is_top_left(p0, p1) ? 0 : -1;\n"
"\n"
"		float w0 = orient2d(p1, p2, samplePoint);\n"
"		float w1 = orient2d(p2, p0, samplePoint);\n"
"		float w2 = orient2d(p0, p1, samplePoint);\n"
"\n"
"		if((int(w0)+bias0) >= 0 && (int(w1)+bias1) >= 0 && (int(w2)+bias2) >= 0)\n"
"		{\n"
"			//TODO check cubic\n"
"			vec4 cubic = (cubic0*w0 + cubic1*w1 + cubic2*w2)/(w0+w1+w2);\n"
"\n"
"			float eps = 0.0001;\n"
"			if(cubic.w*(cubic.x*cubic.x*cubic.x - cubic.y*cubic.z) <= eps)\n"
"			{\n"
"				if(zIndex == currentZIndex)\n"
"				{\n"
"					flipCount++;\n"
"				}\n"
"				else\n"
"				{\n"
"					if((flipCount & 0x01) != 0)\n"
"					{\n"
"						pixelColor = currentColor;\n"
"					}\n"
"					currentColor = pixelColor*(1.-color.a) + color.a*color;\n"
"					currentZIndex = zIndex;\n"
"					flipCount = 1;\n"
"				}\n"
"			}\n"
"		}\n"
"    }\n"
"    if((flipCount & 0x01) != 0)\n"
"    {\n"
"		pixelColor = currentColor;\n"
"    }\n"
"\n"
"    fragColor = pixelColor;\n"
"}\n";

//NOTE: string imported from src\gles_canvas_shaders\gles_canvas_vertex.glsl
const char* gles_canvas_vertex = 
"#version 310 es\n"
"\n"
"precision mediump float;\n"
"\n"
"void main()\n"
"{\n"
"    float x = float(((uint(gl_VertexID) + 2u) / 3u)%2u);\n"
"    float y = float(((uint(gl_VertexID) + 1u) / 3u)%2u);\n"
"\n"
"    gl_Position = vec4(-1.0f + x*2.0f, -1.0f+y*2.0f, 0.0f, 1.0f);\n"
"}\n";

#endif // __GLES_CANVAS_SHADERS_H__
