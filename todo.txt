
Overview
--------
[.] Make backend selection easier
	[.] option macros to select backend-specific APIs to include when building an app
		(ie, include gl_api.h when using gl backend)
	[ ] error on bad option macro combinations
	[ ] write doc about backend option macros

[>] Image API and backend
	[ ] Build image atlas on top
	[ ] Baked fonts?

[x] Allow different versions of GL/GLES to co-exist
[>] Allow selecting version of GL/GLES context when creating surface
	- pass/set attributes when creating surface?

[/] Keep dummy window/dummy context around for gl context creation, and don't reload wgl functions every time

[.] Reintroduce GLES surface
	[?] See how we can isolate platform-specific stuff and just deal with egl there...

[.] Back surface by child windows and implement moving frame/hiding/overlay
	[x] osx gles surface
		[ ] Sort out gles contents scaling for high dpi
	[ ] win32 opengl surfaces
	[ ] win32 gles surface

	[/] could have an internal, per-platform mp_layer struct that handles resizing/hiding etc...
		-> avoid duplication of frame/hiding and duplication of egl code.

	[ ] then check that we can make GLES and GL surfaces co-exist in the app

[!] Make linking with libEGL optional, even if EGL backend is compiled in milepost?
[!] Bundle examples with their own resources?? (e.g. avoiding clashes in metal libs files in bin directory)
[!] Fix canvas shader precision issue on OSX
[!] Fix canvas perf issue on OSX
[!] osx: Remove need to include objc defs from osx_app.h in egl impl. Also properly guard angle backend attribute (must be metal on osx and default on win32)

[ ] Delegated drawing API+Impl



[ ] Make building apps simpler
	[ ] single include path
	[ ] script for embedding dependencies / create app bundle


[?] Backport canvas to GLES

Clean+Fixes
-----------

[>] drop the "mg_" prefix for internal functions (and declare them static)

[x] Rename MG_GL_CANVAS_TILE_ARRAY_SIZE/LENGTH unambiguously and make it consistent between C and glsl code
[x] Clean shaders (folder/filenames, version string, debug flags, ...)
	[x] Simplify shader names, prefix embedded strings by "glsl_"
	[x] Extract shader compilation in a function
	[x] Add version strings/common structs in canvas code (maybe revisit later when we have multiple versions, but ok for now)
	[x] Check return of compilation. If failed, cleanup and return NULL backend

[x] Clean-up context on error and return nil handle
	[/] Could return non-nil "invalid" handle and set error flags in handle

[x] Destroy canvas backend properly
[x] Destroy surface properly
[x] Destroy window properly

[>] Make surface backend and canvas backend compile-time and run-time selections easier

[ ] GL loader: allow using different GL versions (eg using a desktop GL surface and a GLES surface in the same app).
[ ] Allow selection different versions of GL/GLES

[!] Decide what to do when user exceeds the limit of triangles
[?] Size tile arrays dynamically when canvas size changes?

Bug hunt
--------
[!] Check if very slow shader can crash the driver and what we might to to prevent that (eg waiting for compute to finish before blit? because slow compute shader should certainly _not_ crash?) or break shader invocation into multiple passes when there's a lot of tiles/triangles

[!]	Investigate artifact when shifting positions of vertices by (0.5, 0.5) before multiplying
    by subpixel precision and truncating... -> ie sampling at the middle of pixels vs at integer coordinates...
    > seems to happen on tile boundaries
	[ ] What alignment gives crisp-ier lines?

[!] decide how to handle overflow in cross-product computation in triangle rasterizing code
    - could reduce subpixel precision (but only to some extent, since we need subpixel precision for msaa)
    - could try to center all coords around 0 to maximize usable range
    - could use int64_t and i64vec (but it has a big perf cost)
    - could precompute some int64_t computation...

[!] handle pathological case where there are a lot of triangle on the same tile
	> can we detect the first solid triangle covering the whole tile?

[!] handle pathological case where there are a lot of very small triangles (eg when zooming out)
	> do we need the same precision then?

[!] Investigate why WM_MOUSEMOVE messages seem to lag behing mouse cursor

Canvas renderer
---------------
[.] Perf
	[x] Split vertex data into per-vertex and per-shape data. Keep only pos, cubics, and shapeID in vertex data
	[?] use half-floats or short fixed-point for pos and uv, packing them in two ints
	[?] pre-compute triangle edges/bounding boxes?

[x] Add surface scaling for high dpi surfaces and check that our fonts are rendered smoothly
[x] Allow setting swap interval
	[!] Allow swap interval of 0 on macos

[x] Use clip rects in tiling/drawing pass

[/] backport to GLES?
[/] Handle changing monitors/dpi

[ ] Ghostscript tiger stress test? -> need an svg loader, and a way to flush external command list

-----------
[.] Check changes in macos version
	[x] Restructure macos version to use mp_app_internal.h/mp_app.c
	[x] test new run loop structure on macos
	[x] Fix resize crash when there's no surface
	[>] separate data for key and mouse event?
	[>] Simplify event structs
		[ ] use isARepeat in macos keyDown event and simplify update key state

	[x] use surfaces to define restricted drawing locations
		[x] Implement with NSView subviews on osx
			[/] Maybe switch to just using CALayers?

	[ ] Cleanup graphics backend compile-time/runtime selection
	[ ] Cleanup graphics resource handles

[.] GLES 3.0 surface on OSX
[x] GLES 3.1 surface on Win32
[.] GLES vector graphics on win32
	[x] Fix triangle rasterization precision issues
		-> we do not want to snap vertex coordinates to integers though, but use fixed point with 4 or 8 bits of subpixel precision
		-> convert verts pos to fixed point
		-> do orient2d in fixed point
	[!] Check precision/possible overflow when using barycentric coords

	[x] Set backround clear color
	[x] Multi-sampling
	[!] Avoid first useless (degenerate) triangle on every path

	[>] rethink image rendering API to avoid forcing atlas into the renderer (which limits image size and usage patterns)
		[x] Break triangle stream into batches to allow using different textures
		[>] Design and implement basic image API
		[ ] Design image atlas api on top of it
		[ ] gles image atlas logic
		[ ] textured rendering in shader

	[ ] port back the image stuff to mac
		[ ] use bindless textures on mac?

	[ ] Image rendering test app
	[ ] Text rendering test app
	[?] Little test drawing app?

	[.] Assess perf
		[x] Tiling
		[>] Reduce size of data sent to GPU
		[ ] experiment with persistently mapped buffer?
		[?] Precomputing triangle edges/biases?

[ ] Implement surfaces with child windows on win32
	[/] Maybe implement compositing directly in d3d and opengl compat extension...
[ ] Cleanup routines

Windows port
------------
[.] Finish events handling
	[x] window
	[x] mouse move/buttons/enter/leave
	[x] mouse wheel
	[.] keys
		[!] set key label
	[x] text input
	[/] pathdrop

[x] Unify app struct and window structs for different platforms?
	> define common app and window struct in mp_app_internal.h
	> this file conditionally includes platform specific headers, win32_app.h, osx_app.h, etc...
	> these define a macro to fill the common app and window structures with platform specific stuff.
	> Common app/window proc are defined in mp_app.c
	> Platform specific stuff is defined in platform specific files win32_app.c, osx_app.m, etc...
	(mp_app.c can 'see' platform specific stuff, so ObjectiveC defs pose a problem, but we can define id as void*
	when not in ObjC...)

[.] Implement input polling
	[ ] Simplify input polling API names
	[/] Try to simplify input state and polling once we have UI usage code

[ ] Finish win32 window create flags and properties query/setting

[ ] Implement clipboard
[ ] Implement file dialogs
[ ] Impement resource path... -> maybe in abstracted file handling

[ ] Clean backend selection (compile time and runtime)
[ ] Finish OpenGL loader
[ ] Test compute shaders
[ ] Initial version of vector graphics backend
[ ] Check integration of UI.

[ ] Remove unused APIs



Misc
----
[ ] Clean-up file structure
	[ ] Move stb libs to ext/

[ ] Renaming/clean-up pass
	[ ] Separate Internal/API functions in mp_app.c
	[ ] Remove MP_EVENT_KEYBOARD_MODS
	[ ] Rename MP_EVENT_HIDE/SHOW to MINMIZE/UNMINIMIZE
	[ ] Remove frame
	[ ] Remove sequence from char event?
	[ ] Replace frame_event with mp_rect
	[ ] Document/unify quit/request_quit etc
	[ ] Document/unify close/request_close etc
	[ ] Cleanup window management
	[ ] Remove unused run loop constructs
	[ ]

Shortlist
---------
[x] let pass flat args in ui_size_push() and ui_box_set_size()
[x] separate style stacks
[x] animation time stack
[>] margins? as part of size, or different styling stack?

[ ] Let build code set target style directly, and animate from current to target
[ ] filter styles stack by tag
[ ] image backgrounds/gradients?
[ ] animating open/close widgets?

[.] Text box widget
	[ ] Draw selection
	[ ] Set cursor on click
	[ ] Scroll to cursor

Canvas Drawing
--------------
[.] Correctly handle resizing / viewport
	[x] associate surfaces with mp_windows
	[x] window resize resizes surface. Surface always renders to whole mp_window
	[x] Add ability to create sub-views, and create surfaces for these
		- window comes with a main view, so we can get a surface for the whole window
	[>] Clean native mp_window_data struct (don't need to cache a lot of stuff here)

[.] Add images bliting
	[x] Clean, rename uv vs texUV stuff
	[>] Destroy stuff
	[>] More unified handle system
	[.] Rounded images (sortof)
	[ ] path clipped images

[ ] Add color gradients?
[ ] Make canvas implicit?
[/] Handle based error signaling
[/] Allow polling events in main thread, and updating/rendering in background thread.

[x] font metrics shouldn't depend on surface, & font
    shouldn't really depend on canvas either???
	> meaning we should be able to pass fonts without canvas in ui
	> and only pass canvas when drawing at the end...

UI
--
[x] Make gui context implicit?
[x] Uniform ui_box struct + cache widgets
[x] Prune unused boxes
[.] Layout boxes
	[x] basic two pass layout
	[x] Layout from start or end
	[>] Add overflow flags to layout, & solve conflicts

[x] Temporarily push transform and text flip when rendering UI, so that the coord system is y down, origin at top left
[x] Canvas render the same size on a high-dpi surface
	> it works with abstract 'pixel' units, which are transformed to pixels in the shader, according to backing store scaling

[.] Style struct and style stack
	[ ] Maybe use individual stack for different style attributes
[x] Pass initial style in ui_begin_frame()

[.] Draw boxes
	[x] use flags to enable/disable drawing each feature
	[ ] active/hovered transitions

[x] Change input state handling a move it to app layer
[x] Compute signals for ui_box
[x] Use ui_size_push() and pass axis instead of ui_width/height_push()
[>] Use value is ui_size as margin when kind == text or == children?

[ ] Allow animating sizes according to hot/active?

[ ] Basic helpers
	[.] button
	[.] slider (or rather, scroll bar)
	[.] simple spacers
		[ ] have a flag for non-cached stuff
	[.] scrolling panel
		[ ] Allow/disallow scrolling in x/y
		[ ] Scroll with mousewheel
		[/] add margins to scrollbars (disallow scrollbars crossing)

[?] Maybe let builder code handle "active"/"hot" state, since it
    depends on the widgets
    [ ] On the other hand, this state must be set before layouting, in
        particular font/fontSize -> maybe do a pass for static layout,
        instead of doing it in box creation...
    [ ] this way we can compute styling after user has set active/hot, but before layout
	> Maybe just let user set style selector, and provide persistent state bits that can
	> be used in any way? (to replace eg active/hot?) or perhaps not needed if we have just
	> 'dragging' state


[x] Mask mouse outside of parent rects -> maintain clip stack and clip mouse against it
[x] Mask mouse below panels/other widgets
[x] popups and tooltips
	[x] allow pushing/popping boxes irrespective of parent/child relation
	[x] ui_begin_frame() prepares two containers, user ui goes in the first one
	[x] tooltips and menus go to the second one
	[x] Add menus
[ ] line editing widget

Misc
----
[x] Split metal surface and metal painter (but put them in the same compilation unit?)
[x] Have only one rect struct
[x] Shorten mp_string to str8

[ ] Better/Simpler time API

[/] Frame throttling
	[x] For now, we always wait on vblank during mg_surface_present(), regardless of target fps
	[ ] Then actually get the correct display interval from the surface's current monitor
	[ ] Allow waiting for more display interval than one? (ie allow throttling at 30fps for a 60fps display)

[/] split osx_app and move all platform independant stuff outside

[ ] Sort out mg_matrix_push/pop() -> transform vs. set...
