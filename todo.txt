
Windows port
------------
[.] Finish events handling
	[x] window
	[x] mouse move/buttons/enter/leave
	[x] mouse wheel
	[.] keys
		[!] set key label
	[x] text input
	[/] pathdrop

[x] Unify app struct and window structs for different platforms?
	> define common app and window struct in mp_app_internal.h
	> this file conditionally includes platform specific headers, win32_app.h, osx_app.h, etc...
	> these define a macro to fill the common app and window structures with platform specific stuff.
	> Common app/window proc are defined in mp_app.c
	> Platform specific stuff is defined in platform specific files win32_app.c, osx_app.m, etc...
	(mp_app.c can 'see' platform specific stuff, so ObjectiveC defs pose a problem, but we can define id as void*
	when not in ObjC...)

[.] Check changes in macos version
	[x] Restructure macos version to use mp_app_internal.h/mp_app.c
	[x] test new run loop structure on macos
	[x] Fix resize crash when there's no surface
	[>] separate data for key and mouse event?
	[>] Simplify event structs
		[ ] use isARepeat in macos keyDown event and simplify update key state

	[>] Clarify how we want to do view handling across platforms
		[.] use surfaces to define restricted drawing locations
			[x] Implement with NSView subviews on osx
				[/] Maybe switch to just using CALayers?
			[ ] Clarify metal-specific surface API
			    > right now mg_surface doesn't really give access to directly drawing in metal
				we only need render encoder from the surface? -> if we just want to issue draw calls.
				We'll likely need the command buffer if we want other passes?  or also have get_compute_encoder().
				We only need the command buffer/command queue if we want to manually create encoders, eg with different clear color

				-> get pixel format / command buffer / texture
				(don't get drawable as it is specific to the kind of target (window or image))
				-> as helper, get simple encoders in the command buffer

				maybe even _just_ get a CAMetalDrawable and pixel format, and let user code create commandQueue, buffers, encoders...
				-> but we need to present the drawable to a specific commandbuffer
				-> so, maybe the view should also maintain a command buffer
				-> pixel format, drawable, command buffer, + helpers for encoders(passes)

				--> but then, mg_surface doesn't really abstract anything (usage code needs to know which kind of surface it is to be able to draw inside it)
				(well, it abstracts the creation of the context and the presentation...)

				maybe we should actually abstract over that, a la sokol_gfx... And then the 2D vector graphics uses this abstract API?
				-> but this is a bigger endeavour

				Maybe keep surface simple, write an opengl version, then try to port painter to opengl version,
				and then we will have more info to decide if we want to abstract over the different APIs.

				Do surfaces for different graphics API even need to be abstracted? don't we always know which surface we're using?



		->> how much do we abstract graphics API vs how much we give access to native calls...

		ie we could abstract shaders, buffers, textures, pipeline, encoders, etc... but also provide access to native data structures




	[ ] Cleanup graphics backend compile-time/runtime selection
	[ ] Implement surfaces with child windows on win32
		[/] Maybe implement compositing directly in d3d and opengl compat extension...

[.] Implement input polling
	[ ] Simplify input polling API names
	[/] Try to simplify input state and polling once we have UI usage code

[ ] Finish win32 window create flags and properties query/setting

[ ] Implement clipboard
[ ] Implement file dialogs
[ ] Impement resource path... -> maybe in abstracted file handling

[ ] Clean backend selection (compile time and runtime)
[ ] Finish OpenGL loader
[ ] Test compute shaders
[ ] Initial version of vector graphics backend
[ ] Check integration of UI.

[ ] Remove unused APIs

[ ] OpenGL backend on OSX
[ ] Port vector graphics to OpenGL
[ ] Check OpenGL vector graphics on windows


Misc
----
[ ] Clean-up file structure
	[ ] Move stb libs to ext/

[ ] Renaming/clean-up pass
	[ ] Separate Internal/API functions in mp_app.c
	[ ] Remove MP_EVENT_KEYBOARD_MODS
	[ ] Rename MP_EVENT_HIDE/SHOW to MINMIZE/UNMINIMIZE
	[ ] Remove frame
	[ ] Remove sequence from char event?
	[ ] Replace frame_event with mp_rect
	[ ] Document/unify quit/request_quit etc
	[ ] Document/unify close/request_close etc
	[ ] Cleanup window management
	[ ] Remove unused run loop constructs
	[ ]

Shortlist
---------
[x] let pass flat args in ui_size_push() and ui_box_set_size()
[x] separate style stacks
[x] animation time stack
[>] margins? as part of size, or different styling stack?

[ ] Let build code set target style directly, and animate from current to target
[ ] filter styles stack by tag
[ ] image backgrounds/gradients?
[ ] animating open/close widgets?

[.] Text box widget
	[ ] Draw selection
	[ ] Set cursor on click
	[ ] Scroll to cursor

Canvas Drawing
--------------
[.] Correctly handle resizing / viewport
	[x] associate surfaces with mp_windows
	[x] window resize resizes surface. Surface always renders to whole mp_window
	[x] Add ability to create sub-views, and create surfaces for these
		- window comes with a main view, so we can get a surface for the whole window
	[>] Clean native mp_window_data struct (don't need to cache a lot of stuff here)

[.] Add images bliting
	[x] Clean, rename uv vs texUV stuff
	[>] Destroy stuff
	[>] More unified handle system
	[.] Rounded images (sortof)
	[ ] path clipped images

[ ] Add color gradients?
[ ] Make canvas implicit?
[/] Handle based error signaling
[/] Allow polling events in main thread, and updating/rendering in background thread.

[x] font metrics shouldn't depend on surface, & font
    shouldn't really depend on canvas either???
	> meaning we should be able to pass fonts without canvas in ui
	> and only pass canvas when drawing at the end...

UI
--
[x] Make gui context implicit?
[x] Uniform ui_box struct + cache widgets
[x] Prune unused boxes
[.] Layout boxes
	[x] basic two pass layout
	[x] Layout from start or end
	[>] Add overflow flags to layout, & solve conflicts

[x] Temporarily push transform and text flip when rendering UI, so that the coord system is y down, origin at top left
[x] Canvas render the same size on a high-dpi surface
	> it works with abstract 'pixel' units, which are transformed to pixels in the shader, according to backing store scaling

[.] Style struct and style stack
	[ ] Maybe use individual stack for different style attributes
[x] Pass initial style in ui_begin_frame()

[.] Draw boxes
	[x] use flags to enable/disable drawing each feature
	[ ] active/hovered transitions

[x] Change input state handling a move it to app layer
[x] Compute signals for ui_box
[x] Use ui_size_push() and pass axis instead of ui_width/height_push()
[>] Use value is ui_size as margin when kind == text or == children?

[ ] Allow animating sizes according to hot/active?

[ ] Basic helpers
	[.] button
	[.] slider (or rather, scroll bar)
	[.] simple spacers
		[ ] have a flag for non-cached stuff
	[.] scrolling panel
		[ ] Allow/disallow scrolling in x/y
		[ ] Scroll with mousewheel
		[/] add margins to scrollbars (disallow scrollbars crossing)

[?] Maybe let builder code handle "active"/"hot" state, since it
    depends on the widgets
    [ ] On the other hand, this state must be set before layouting, in
        particular font/fontSize -> maybe do a pass for static layout,
        instead of doing it in box creation...
    [ ] this way we can compute styling after user has set active/hot, but before layout
	> Maybe just let user set style selector, and provide persistent state bits that can
	> be used in any way? (to replace eg active/hot?) or perhaps not needed if we have just
	> 'dragging' state


[x] Mask mouse outside of parent rects -> maintain clip stack and clip mouse against it
[x] Mask mouse below panels/other widgets
[x] popups and tooltips
	[x] allow pushing/popping boxes irrespective of parent/child relation
	[x] ui_begin_frame() prepares two containers, user ui goes in the first one
	[x] tooltips and menus go to the second one
	[x] Add menus
[ ] line editing widget

Misc
----
[x] Split metal surface and metal painter (but put them in the same compilation unit?)
[x] Have only one rect struct
[x] Shorten mp_string to str8

[ ] Better/Simpler time API

[/] Frame throttling
	[x] For now, we always wait on vblank during mg_surface_present(), regardless of target fps
	[ ] Then actually get the correct display interval from the surface's current monitor
	[ ] Allow waiting for more display interval than one? (ie allow throttling at 30fps for a 60fps display)

[/] split osx_app and move all platform independant stuff outside

[ ] Sort out mg_matrix_push/pop() -> transform vs. set...
